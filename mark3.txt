In archive ./stage/lib/avr/atmega328p/gcc/libmark3c.a:

atomic.c.o:     file format elf32-avr


blocking.c.o:     file format elf32-avr


Disassembly of section .text.BlockingObject_Block:

00000000 <BlockingObject_Block>:
#define __FILE_ID__ 	BLOCKING_C       //!< File ID used in kernel trace calls

#if KERNEL_USE_SEMAPHORE || KERNEL_USE_MUTEX
//---------------------------------------------------------------------------
void BlockingObject_Block( ThreadList_t *pstList_, Thread_t *pstThread_ )
{
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17
   4:	cf 93       	push	r28
   6:	df 93       	push	r29
   8:	8c 01       	movw	r16, r24
   a:	eb 01       	movw	r28, r22
    KERNEL_ASSERT( pstThread_ );
    KERNEL_TRACE_1( STR_THREAD_BLOCK_1, (K_USHORT)Thread_GetID( pstThread_ ) );
	
    // Remove the thread from its current thread list (the "owner" list)
    // ... And add the thread to this object's block list    
    Scheduler_Remove( pstThread_ );
   c:	cb 01       	movw	r24, r22
   e:	0e 94 00 00 	call	0	; 0x0 <BlockingObject_Block>
    ThreadList_Add( pstList_, pstThread_ );
  12:	be 01       	movw	r22, r28
  14:	c8 01       	movw	r24, r16
  16:	0e 94 00 00 	call	0	; 0x0 <BlockingObject_Block>
    
    // Set the "current" list location to the blocklist for this thread
    Thread_SetCurrent( pstThread_, pstList_ );
  1a:	1f 87       	std	Y+15, r17	; 0x0f
  1c:	0e 87       	std	Y+14, r16	; 0x0e
    Thread_SetState( pstThread_, THREAD_STATE_BLOCKED );
  1e:	82 e0       	ldi	r24, 0x02	; 2
  20:	8b 87       	std	Y+11, r24	; 0x0b
}
  22:	df 91       	pop	r29
  24:	cf 91       	pop	r28
  26:	1f 91       	pop	r17
  28:	0f 91       	pop	r16
  2a:	08 95       	ret

Disassembly of section .text.BlockingObject_UnBlock:

00000000 <BlockingObject_UnBlock>:

//---------------------------------------------------------------------------
void BlockingObject_UnBlock( Thread_t *pstThread_ )
{
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	ec 01       	movw	r28, r24
    KERNEL_ASSERT( pstThread_ );
    KERNEL_TRACE_1( STR_THREAD_UNBLOCK_1, (K_USHORT)Thread_GetID( pstThread_ ) );
    
	// Remove the thread from its current thread list (the "owner" list)
    ThreadList_Remove( Thread_GetCurrent( pstThread_ ), pstThread_ );
   6:	bc 01       	movw	r22, r24
   8:	8e 85       	ldd	r24, Y+14	; 0x0e
   a:	9f 85       	ldd	r25, Y+15	; 0x0f
   c:	0e 94 00 00 	call	0	; 0x0 <BlockingObject_UnBlock>
    
    // Put the thread back in its active owner's list.  This is usually
    // the ready-queue at the thread's original priority.    
    Scheduler_Add( pstThread_ );
  10:	ce 01       	movw	r24, r28
  12:	0e 94 00 00 	call	0	; 0x0 <BlockingObject_UnBlock>
    
    // Tag the thread's current list location to its owner
    Thread_SetCurrent( pstThread_, Thread_GetOwner( pstThread_ ) );
  16:	88 89       	ldd	r24, Y+16	; 0x10
  18:	99 89       	ldd	r25, Y+17	; 0x11
  1a:	9f 87       	std	Y+15, r25	; 0x0f
  1c:	8e 87       	std	Y+14, r24	; 0x0e
    Thread_SetState( pstThread_, THREAD_STATE_READY );
  1e:	81 e0       	ldi	r24, 0x01	; 1
  20:	8b 87       	std	Y+11, r24	; 0x0b
}
  22:	df 91       	pop	r29
  24:	cf 91       	pop	r28
  26:	08 95       	ret

driver.c.o:     file format elf32-avr


Disassembly of section .text.DriverList_Init:

00000000 <DriverList_Init>:
//---------------------------------------------------------------------------
void DriverList_Init( void )
{
    // Ensure we always have at least one entry - a default in case no match
    // is found (/dev/null)
    DoubleLinkList_Init( (DoubleLinkList_t*)&m_clDriverList );
   0:	10 92 00 00 	sts	0x0000, r1
   4:	10 92 00 00 	sts	0x0000, r1
   8:	10 92 00 00 	sts	0x0000, r1
   c:	10 92 00 00 	sts	0x0000, r1
    DoubleLinkList_Add( (DoubleLinkList_t*)&m_clDriverList, (LinkListNode_t*)&stDevNull);
  10:	60 e0       	ldi	r22, 0x00	; 0
  12:	70 e0       	ldi	r23, 0x00	; 0
  14:	80 e0       	ldi	r24, 0x00	; 0
  16:	90 e0       	ldi	r25, 0x00	; 0
  18:	0c 94 00 00 	jmp	0	; 0x0 <DriverList_Init>

Disassembly of section .text.DriverList_Add:

00000000 <DriverList_Add>:
}

//---------------------------------------------------------------------------
void DriverList_Add( Driver_t *pstDriver_ )
{
    DoubleLinkList_Add( (DoubleLinkList_t*)&m_clDriverList, (LinkListNode_t*)pstDriver_ );
   0:	bc 01       	movw	r22, r24
   2:	80 e0       	ldi	r24, 0x00	; 0
   4:	90 e0       	ldi	r25, 0x00	; 0
   6:	0c 94 00 00 	jmp	0	; 0x0 <DriverList_Add>

Disassembly of section .text.DriverList_FindByPath:

00000000 <DriverList_FindByPath>:
}

//---------------------------------------------------------------------------
Driver_t *DriverList_FindByPath( const K_CHAR *m_pcPath )
{
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
	KERNEL_ASSERT( m_pcPath );
    Driver_t *pstTemp;

    pstTemp = (Driver_t*)(LinkList_GetHead( (LinkList_t*)&m_clDriverList ) );
   4:	e0 91 00 00 	lds	r30, 0x0000
   8:	f0 91 00 00 	lds	r31, 0x0000
	
    // Iterate through the list of drivers until we find a match, or we
    // exhaust our list of installed drivers
	while (pstTemp)
   c:	30 97       	sbiw	r30, 0x00	; 0
   e:	01 f0       	breq	.+0      	; 0x10 <DriverList_FindByPath+0x10>
  10:	dc 01       	movw	r26, r24
  12:	c6 81       	ldd	r28, Z+6	; 0x06
  14:	d7 81       	ldd	r29, Z+7	; 0x07
static K_UCHAR DrvCmp( const K_CHAR *szStr1_, const K_CHAR *szStr2_ )
{
	K_CHAR *szTmp1 = (K_CHAR*) szStr1_;
	K_CHAR *szTmp2 = (K_CHAR*) szStr2_;

	while (*szTmp1 && *szTmp2)
  16:	3d 91       	ld	r19, X+
  18:	33 23       	and	r19, r19
  1a:	01 f0       	breq	.+0      	; 0x1c <DriverList_FindByPath+0x1c>
  1c:	29 91       	ld	r18, Y+
  1e:	22 23       	and	r18, r18
  20:	01 f0       	breq	.+0      	; 0x22 <DriverList_FindByPath+0x22>
	{
		if (*szTmp1++ != *szTmp2++)
  22:	32 17       	cp	r19, r18
  24:	01 f0       	breq	.+0      	; 0x26 <DriverList_FindByPath+0x26>
  26:	00 c0       	rjmp	.+0      	; 0x28 <DriverList_FindByPath+0x28>
			return pstTemp;
		}
        pstTemp = (Driver_t*)(LinkListNode_GetNext( (LinkListNode_t*)pstTemp ) );
	}
    // No matching driver found - return a pointer to our /dev/null driver
    return &stDevNull;
  28:	80 e0       	ldi	r24, 0x00	; 0
  2a:	90 e0       	ldi	r25, 0x00	; 0
  2c:	00 c0       	rjmp	.+0      	; 0x2e <DriverList_FindByPath+0x2e>
			return 0;
		}
	}

	// Both terminate at the same length
	if (!(*szTmp1) && !(*szTmp2))
  2e:	28 81       	ld	r18, Y
  30:	21 11       	cpse	r18, r1
  32:	00 c0       	rjmp	.+0      	; 0x34 <DriverList_FindByPath+0x34>
  34:	cf 01       	movw	r24, r30
  36:	00 c0       	rjmp	.+0      	; 0x38 <DriverList_FindByPath+0x38>

        if( DrvCmp( m_pcPath, Driver_GetPath( pstTemp ) ) )
		{
			return pstTemp;
		}
        pstTemp = (Driver_t*)(LinkListNode_GetNext( (LinkListNode_t*)pstTemp ) );
  38:	01 90       	ld	r0, Z+
  3a:	f0 81       	ld	r31, Z
  3c:	e0 2d       	mov	r30, r0
  3e:	00 c0       	rjmp	.+0      	; 0x40 <DriverList_FindByPath+0x40>
	}
    // No matching driver found - return a pointer to our /dev/null driver
    return &stDevNull;
}
  40:	df 91       	pop	r29
  42:	cf 91       	pop	r28
  44:	08 95       	ret

Disassembly of section .text.Driver_SetName:

00000000 <Driver_SetName>:

//---------------------------------------------------------------------------
void Driver_SetName( Driver_t *pstDriver_, const K_CHAR *pcName_ )
{
    pstDriver_->szName = pcName_;
   0:	fc 01       	movw	r30, r24
   2:	77 83       	std	Z+7, r23	; 0x07
   4:	66 83       	std	Z+6, r22	; 0x06
   6:	08 95       	ret

Disassembly of section .text.Driver_GetPath:

00000000 <Driver_GetPath>:

//---------------------------------------------------------------------------
const K_CHAR *Driver_GetPath( Driver_t *pstDriver_ )
{
    return pstDriver_->szName;
}
   0:	fc 01       	movw	r30, r24
   2:	86 81       	ldd	r24, Z+6	; 0x06
   4:	97 81       	ldd	r25, Z+7	; 0x07
   6:	08 95       	ret

Disassembly of section .text.Driver_Open:

00000000 <Driver_Open>:

//---------------------------------------------------------------------------
K_UCHAR Driver_Open( Driver_t *pstDriver_ )
{
    if ( pstDriver_->pstVTable->pfOpen )
   0:	dc 01       	movw	r26, r24
   2:	14 96       	adiw	r26, 0x04	; 4
   4:	ed 91       	ld	r30, X+
   6:	fc 91       	ld	r31, X
   8:	15 97       	sbiw	r26, 0x05	; 5
   a:	01 90       	ld	r0, Z+
   c:	f0 81       	ld	r31, Z
   e:	e0 2d       	mov	r30, r0
  10:	30 97       	sbiw	r30, 0x00	; 0
  12:	01 f0       	breq	.+0      	; 0x14 <Driver_Open+0x14>
    {
        return pstDriver_->pstVTable->pfOpen( pstDriver_ );
  14:	09 94       	ijmp
    }
    return 0;
}
  16:	80 e0       	ldi	r24, 0x00	; 0
  18:	08 95       	ret

Disassembly of section .text.Driver_Close:

00000000 <Driver_Close>:
//---------------------------------------------------------------------------
K_UCHAR Driver_Close( Driver_t *pstDriver_ )
{
    if ( pstDriver_->pstVTable->pfClose )
   0:	dc 01       	movw	r26, r24
   2:	14 96       	adiw	r26, 0x04	; 4
   4:	ed 91       	ld	r30, X+
   6:	fc 91       	ld	r31, X
   8:	15 97       	sbiw	r26, 0x05	; 5
   a:	02 80       	ldd	r0, Z+2	; 0x02
   c:	f3 81       	ldd	r31, Z+3	; 0x03
   e:	e0 2d       	mov	r30, r0
  10:	30 97       	sbiw	r30, 0x00	; 0
  12:	01 f0       	breq	.+0      	; 0x14 <Driver_Close+0x14>
    {
        return pstDriver_->pstVTable->pfClose( pstDriver_ );
  14:	09 94       	ijmp
    }
    return 0;
}
  16:	80 e0       	ldi	r24, 0x00	; 0
  18:	08 95       	ret

Disassembly of section .text.Driver_Read:

00000000 <Driver_Read>:

//---------------------------------------------------------------------------
K_USHORT Driver_Read( Driver_t *pstDriver_, K_USHORT usSize_, K_UCHAR *pucData_ )
{
    if ( pstDriver_->pstVTable->pfRead )
   0:	dc 01       	movw	r26, r24
   2:	14 96       	adiw	r26, 0x04	; 4
   4:	ed 91       	ld	r30, X+
   6:	fc 91       	ld	r31, X
   8:	15 97       	sbiw	r26, 0x05	; 5
   a:	04 80       	ldd	r0, Z+4	; 0x04
   c:	f5 81       	ldd	r31, Z+5	; 0x05
   e:	e0 2d       	mov	r30, r0
  10:	30 97       	sbiw	r30, 0x00	; 0
  12:	01 f0       	breq	.+0      	; 0x14 <Driver_Read+0x14>
    {
        return pstDriver_->pstVTable->pfRead( pstDriver_, usSize_, pucData_ );
  14:	09 94       	ijmp
    }
    return usSize_;
}
  16:	cb 01       	movw	r24, r22
  18:	08 95       	ret

Disassembly of section .text.Driver_Write:

00000000 <Driver_Write>:
//---------------------------------------------------------------------------
K_USHORT Driver_Write( Driver_t *pstDriver_, K_USHORT usSize_, K_UCHAR *pucData_ )
{
    if ( pstDriver_->pstVTable->pfWrite )
   0:	dc 01       	movw	r26, r24
   2:	14 96       	adiw	r26, 0x04	; 4
   4:	ed 91       	ld	r30, X+
   6:	fc 91       	ld	r31, X
   8:	15 97       	sbiw	r26, 0x05	; 5
   a:	06 80       	ldd	r0, Z+6	; 0x06
   c:	f7 81       	ldd	r31, Z+7	; 0x07
   e:	e0 2d       	mov	r30, r0
  10:	30 97       	sbiw	r30, 0x00	; 0
  12:	01 f0       	breq	.+0      	; 0x14 <Driver_Write+0x14>
    {
        return pstDriver_->pstVTable->pfWrite( pstDriver_, usSize_, pucData_ );
  14:	09 94       	ijmp
    }
    return usSize_;
}
  16:	cb 01       	movw	r24, r22
  18:	08 95       	ret

Disassembly of section .text.Driver_Control:

00000000 <Driver_Control>:
//---------------------------------------------------------------------------
K_USHORT Driver_Control( Driver_t *pstDriver_, K_USHORT usEvent_, K_USHORT usInSize_, K_UCHAR *pucIn_, K_USHORT usOutSize_, K_UCHAR *pucOut_)
{
   0:	ef 92       	push	r14
   2:	ff 92       	push	r15
   4:	0f 93       	push	r16
   6:	1f 93       	push	r17
    if ( pstDriver_->pstVTable->pfControl )
   8:	dc 01       	movw	r26, r24
   a:	14 96       	adiw	r26, 0x04	; 4
   c:	ed 91       	ld	r30, X+
   e:	fc 91       	ld	r31, X
  10:	15 97       	sbiw	r26, 0x05	; 5
  12:	00 84       	ldd	r0, Z+8	; 0x08
  14:	f1 85       	ldd	r31, Z+9	; 0x09
  16:	e0 2d       	mov	r30, r0
  18:	30 97       	sbiw	r30, 0x00	; 0
  1a:	01 f0       	breq	.+0      	; 0x1c <Driver_Control+0x1c>
    {
        return pstDriver_->pstVTable->pfControl( pstDriver_, usEvent_, usInSize_, pucIn_, usOutSize_, pucOut_);
  1c:	09 95       	icall
  1e:	00 c0       	rjmp	.+0      	; 0x20 <Driver_Control+0x20>
    }
    return 0;
  20:	80 e0       	ldi	r24, 0x00	; 0
  22:	90 e0       	ldi	r25, 0x00	; 0
}
  24:	1f 91       	pop	r17
  26:	0f 91       	pop	r16
  28:	ff 90       	pop	r15
  2a:	ef 90       	pop	r14
  2c:	08 95       	ret

eventflag.c.o:     file format elf32-avr


Disassembly of section .text.TimedEventFlag_Callback:

00000000 <TimedEventFlag_Callback>:
 *
 * \param pstOwner_ Thread_t to wake
 * \param pvData_ Pointer to the event-flag object
 */
void TimedEventFlag_Callback(Thread_t *pstOwner_, void *pvData_)
{
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	ec 01       	movw	r28, r24
}

//---------------------------------------------------------------------------
void EventFlag_WakeMe( EventFlag_t *pstFlag_, Thread_t *pstChosenOne_)
{
    BlockingObject_UnBlock( pstChosenOne_ );
   6:	0e 94 00 00 	call	0	; 0x0 <TimedEventFlag_Callback>
void TimedEventFlag_Callback(Thread_t *pstOwner_, void *pvData_)
{
    EventFlag_t *pstEventFlag = (EventFlag_t*)(pvData_);

	EventFlag_WakeMe( pstEventFlag, pstOwner_ );
	Thread_SetExpired( pstOwner_, true );
   a:	81 e0       	ldi	r24, 0x01	; 1
   c:	8a ab       	std	Y+50, r24	; 0x32
	Thread_SetEventFlagMask( pstOwner_, 0 );
   e:	19 8e       	std	Y+25, r1	; 0x19
  10:	18 8e       	std	Y+24, r1	; 0x18
	
	if (Thread_GetCurPriority( pstOwner_ ) >=
	    Thread_GetCurPriority( Scheduler_GetCurrentThread() )) 
  12:	e0 91 00 00 	lds	r30, 0x0000
  16:	f0 91 00 00 	lds	r31, 0x0000

	EventFlag_WakeMe( pstEventFlag, pstOwner_ );
	Thread_SetExpired( pstOwner_, true );
	Thread_SetEventFlagMask( pstOwner_, 0 );
	
	if (Thread_GetCurPriority( pstOwner_ ) >=
  1a:	9a 85       	ldd	r25, Y+10	; 0x0a
  1c:	82 85       	ldd	r24, Z+10	; 0x0a
  1e:	98 17       	cp	r25, r24
  20:	00 f0       	brcs	.+0      	; 0x22 <TimedEventFlag_Callback+0x22>
	    Thread_GetCurPriority( Scheduler_GetCurrentThread() )) 
	{
        Thread_Yield();
    }
}
  22:	df 91       	pop	r29
  24:	cf 91       	pop	r28
	Thread_SetEventFlagMask( pstOwner_, 0 );
	
	if (Thread_GetCurPriority( pstOwner_ ) >=
	    Thread_GetCurPriority( Scheduler_GetCurrentThread() )) 
	{
        Thread_Yield();
  26:	0c 94 00 00 	jmp	0	; 0x0 <TimedEventFlag_Callback>
    }
}
  2a:	df 91       	pop	r29
  2c:	cf 91       	pop	r28
  2e:	08 95       	ret

Disassembly of section .text.EventFlag_Wait_i:

00000000 <EventFlag_Wait_i>:
#if KERNEL_USE_TIMEOUTS
    K_USHORT EventFlag_Wait_i( EventFlag_t *pstFlag_, K_USHORT usMask_, EventFlagOperation_t eMode_, K_ULONG ulTimeMS_)
#else
    K_USHORT EventFlag_Wait_i( EventFlag_t *pstFlag_, K_USHORT usMask_, EventFlagOperation_t eMode_)
#endif
{
   0:	cf 92       	push	r12
   2:	df 92       	push	r13
   4:	ef 92       	push	r14
   6:	ff 92       	push	r15
   8:	0f 93       	push	r16
   a:	1f 93       	push	r17
   c:	cf 93       	push	r28
   e:	df 93       	push	r29
  10:	cd b7       	in	r28, 0x3d	; 61
  12:	de b7       	in	r29, 0x3e	; 62
  14:	6c 97       	sbiw	r28, 0x1c	; 28
  16:	0f b6       	in	r0, 0x3f	; 63
  18:	f8 94       	cli
  1a:	de bf       	out	0x3e, r29	; 62
  1c:	0f be       	out	0x3f, r0	; 63
  1e:	cd bf       	out	0x3d, r28	; 61
  20:	6c 01       	movw	r12, r24
  22:	f4 2e       	mov	r15, r20
  24:	a9 01       	movw	r20, r18
  26:	98 01       	movw	r18, r16
    K_BOOL bUseTimer = false;
#endif

    // Ensure we're operating in a critical section while we determine
    // whether or not we need to block the current thread on this object.
    CS_ENTER();
  28:	8f b7       	in	r24, 0x3f	; 63
  2a:	88 8f       	std	Y+24, r24	; 0x18
  2c:	f8 94       	cli

    // Check to see whether or not the current mask matches any of the
    // desired bits.
	Thread_SetEventFlagMask( g_pstCurrent, usMask_ );
  2e:	e0 91 00 00 	lds	r30, 0x0000
  32:	f0 91 00 00 	lds	r31, 0x0000
  36:	71 8f       	std	Z+25, r23	; 0x19
  38:	60 8f       	std	Z+24, r22	; 0x18

    if ((eMode_ == EVENT_FLAG_ALL) || (eMode_ == EVENT_FLAG_ALL_CLEAR))
  3a:	8f 2d       	mov	r24, r15
  3c:	8d 7f       	andi	r24, 0xFD	; 253
  3e:	01 f4       	brne	.+0      	; 0x40 <EventFlag_Wait_i+0x40>
    {
        // Check to see if the flags in their current state match all of
        // the set flags in the event flag group, with this mask.
        if ((pstFlag_->m_usSetMask & usMask_) == usMask_)
  40:	d6 01       	movw	r26, r12
  42:	17 96       	adiw	r26, 0x07	; 7
  44:	8d 91       	ld	r24, X+
  46:	9c 91       	ld	r25, X
  48:	18 97       	sbiw	r26, 0x08	; 8
  4a:	86 23       	and	r24, r22
  4c:	97 23       	and	r25, r23
  4e:	86 17       	cp	r24, r22
  50:	97 07       	cpc	r25, r23
  52:	01 f4       	brne	.+0      	; 0x54 <EventFlag_Wait_i+0x54>
  54:	00 c0       	rjmp	.+0      	; 0x56 <EventFlag_Wait_i+0x56>
        {
            bMatch = true;
			Thread_SetEventFlagMask( g_pstCurrent, usMask_ );
        }
    }
    else if ((eMode_ == EVENT_FLAG_ANY) || (eMode_ == EVENT_FLAG_ANY_CLEAR))
  56:	81 30       	cpi	r24, 0x01	; 1
  58:	01 f4       	brne	.+0      	; 0x5a <EventFlag_Wait_i+0x5a>
    {
        // Check to see if the existing flags match any of the set flags in
        // the event flag group  with this mask
        if (pstFlag_->m_usSetMask & usMask_)
  5a:	d6 01       	movw	r26, r12
  5c:	17 96       	adiw	r26, 0x07	; 7
  5e:	8d 91       	ld	r24, X+
  60:	9c 91       	ld	r25, X
  62:	18 97       	sbiw	r26, 0x08	; 8
  64:	86 23       	and	r24, r22
  66:	97 23       	and	r25, r23
  68:	00 97       	sbiw	r24, 0x00	; 0
  6a:	01 f0       	breq	.+0      	; 0x6c <EventFlag_Wait_i+0x6c>
        {
            bMatch = true;
            Thread_SetEventFlagMask( g_pstCurrent, pstFlag_->m_usSetMask & usMask_);
  6c:	91 8f       	std	Z+25, r25	; 0x19
  6e:	80 8f       	std	Z+24, r24	; 0x18
    K_BOOL bThreadYield = false;
    K_BOOL bMatch = false;

#if KERNEL_USE_TIMEOUTS
    Timer_t clEventTimer;
    K_BOOL bUseTimer = false;
  70:	10 e0       	ldi	r17, 0x00	; 0
    K_USHORT EventFlag_Wait_i( EventFlag_t *pstFlag_, K_USHORT usMask_, EventFlagOperation_t eMode_, K_ULONG ulTimeMS_)
#else
    K_USHORT EventFlag_Wait_i( EventFlag_t *pstFlag_, K_USHORT usMask_, EventFlagOperation_t eMode_)
#endif
{
    K_BOOL bThreadYield = false;
  72:	80 e0       	ldi	r24, 0x00	; 0
        // Switch threads immediately
        Thread_Yield();
    }

    // Exit the critical section and return back to normal execution
    CS_EXIT();
  74:	98 8d       	ldd	r25, Y+24	; 0x18
  76:	9f bf       	out	0x3f, r25	; 63
    //!! If the Yield operation causes a new thread to be chosen, there will
    //!! Be a context switch at the above CS_EXIT().  The original calling
    //!! thread will not return back until a matching SetFlags call is made
    //!! or a timeout occurs.
#if KERNEL_USE_TIMEOUTS
    if (bUseTimer && bThreadYield)
  78:	11 23       	and	r17, r17
  7a:	01 f0       	breq	.+0      	; 0x7c <EventFlag_Wait_i+0x7c>
  7c:	88 23       	and	r24, r24
  7e:	01 f0       	breq	.+0      	; 0x80 <EventFlag_Wait_i+0x80>
    {
		Timer_Stop( &clEventTimer );
  80:	ce 01       	movw	r24, r28
  82:	01 96       	adiw	r24, 0x01	; 1
  84:	0e 94 00 00 	call	0	; 0x0 <EventFlag_Wait_i>
    }
#endif

    return Thread_GetEventFlagMask( g_pstCurrent );
  88:	e0 91 00 00 	lds	r30, 0x0000
  8c:	f0 91 00 00 	lds	r31, 0x0000
  90:	80 8d       	ldd	r24, Z+24	; 0x18
  92:	91 8d       	ldd	r25, Z+25	; 0x19
}
  94:	6c 96       	adiw	r28, 0x1c	; 28
  96:	0f b6       	in	r0, 0x3f	; 63
  98:	f8 94       	cli
  9a:	de bf       	out	0x3e, r29	; 62
  9c:	0f be       	out	0x3f, r0	; 63
  9e:	cd bf       	out	0x3d, r28	; 61
  a0:	df 91       	pop	r29
  a2:	cf 91       	pop	r28
  a4:	1f 91       	pop	r17
  a6:	0f 91       	pop	r16
  a8:	ff 90       	pop	r15
  aa:	ef 90       	pop	r14
  ac:	df 90       	pop	r13
  ae:	cf 90       	pop	r12
  b0:	08 95       	ret
    // We're unable to match this pattern as-is, so we must block.
    if (!bMatch)
    {
        // Reset the current thread's event flag mask & mode
		Thread_SetEventFlagMask( g_pstCurrent, usMask_ );
		Thread_SetEventFlagMode( g_pstCurrent, eMode_ );
  b2:	f2 8e       	std	Z+26, r15	; 0x1a

#if KERNEL_USE_TIMEOUTS
        if (ulTimeMS_)
  b4:	21 15       	cp	r18, r1
  b6:	31 05       	cpc	r19, r1
  b8:	41 05       	cpc	r20, r1
  ba:	51 05       	cpc	r21, r1
  bc:	01 f0       	breq	.+0      	; 0xbe <EventFlag_Wait_i+0xbe>
        {
			Thread_SetExpired( g_pstCurrent, false );
  be:	12 aa       	std	Z+50, r1	; 0x32
            
			Timer_Init( &clEventTimer );
  c0:	ce 01       	movw	r24, r28
  c2:	01 96       	adiw	r24, 0x01	; 1
  c4:	29 8f       	std	Y+25, r18	; 0x19
  c6:	3a 8f       	std	Y+26, r19	; 0x1a
  c8:	4b 8f       	std	Y+27, r20	; 0x1b
  ca:	5c 8f       	std	Y+28, r21	; 0x1c
  cc:	0e 94 00 00 	call	0	; 0x0 <EventFlag_Wait_i>
			Timer_Start( &clEventTimer, false, ulTimeMS_, TimedEventFlag_Callback, (void*)pstFlag_);
  d0:	76 01       	movw	r14, r12
  d2:	00 e0       	ldi	r16, 0x00	; 0
  d4:	10 e0       	ldi	r17, 0x00	; 0
  d6:	29 8d       	ldd	r18, Y+25	; 0x19
  d8:	3a 8d       	ldd	r19, Y+26	; 0x1a
  da:	4b 8d       	ldd	r20, Y+27	; 0x1b
  dc:	5c 8d       	ldd	r21, Y+28	; 0x1c
  de:	60 e0       	ldi	r22, 0x00	; 0
  e0:	ce 01       	movw	r24, r28
  e2:	01 96       	adiw	r24, 0x01	; 1
  e4:	0e 94 00 00 	call	0	; 0x0 <EventFlag_Wait_i>
            bUseTimer = true;
  e8:	11 e0       	ldi	r17, 0x01	; 1
        }
#endif

        // Add the thread to the object's block-list.
        BlockingObject_Block( (ThreadList_t*)pstFlag_, g_pstCurrent);
  ea:	60 91 00 00 	lds	r22, 0x0000
  ee:	70 91 00 00 	lds	r23, 0x0000
  f2:	c6 01       	movw	r24, r12
  f4:	0e 94 00 00 	call	0	; 0x0 <EventFlag_Wait_i>
    // and must therefore rerun the scheduler to determine what thread to
    // switch to.
    if (bThreadYield)
    {
        // Switch threads immediately
        Thread_Yield();
  f8:	0e 94 00 00 	call	0	; 0x0 <EventFlag_Wait_i>

        // Add the thread to the object's block-list.
        BlockingObject_Block( (ThreadList_t*)pstFlag_, g_pstCurrent);

        // Trigger that
        bThreadYield = true;
  fc:	81 e0       	ldi	r24, 0x01	; 1
  fe:	00 c0       	rjmp	.+0      	; 0x100 <EventFlag_Wait_i+0x100>
    K_BOOL bThreadYield = false;
    K_BOOL bMatch = false;

#if KERNEL_USE_TIMEOUTS
    Timer_t clEventTimer;
    K_BOOL bUseTimer = false;
 100:	10 e0       	ldi	r17, 0x00	; 0
 102:	00 c0       	rjmp	.+0      	; 0x104 <__SREG__+0xc5>

Disassembly of section .text.EventFlag_Init:

00000000 <EventFlag_Init>:
/*!
  \brief Init Initializes the EventFlag_t object prior to use.
 */
void EventFlag_Init( EventFlag_t *pstFlag_ ) 
{ 
	pstFlag_->m_usSetMask = 0; 
   0:	fc 01       	movw	r30, r24
   2:	10 86       	std	Z+8, r1	; 0x08
   4:	17 82       	std	Z+7, r1	; 0x07
	ThreadList_Init( (ThreadList_t*)pstFlag_ );
   6:	0c 94 00 00 	jmp	0	; 0x0 <EventFlag_Init>

Disassembly of section .text.EventFlag_Wait:

00000000 <EventFlag_Wait>:
    return Thread_GetEventFlagMask( g_pstCurrent );
}

//---------------------------------------------------------------------------
K_USHORT EventFlag_Wait( EventFlag_t *pstFlag_, K_USHORT usMask_, EventFlagOperation_t eMode_)
{
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17
#if KERNEL_USE_TIMEOUTS
    return EventFlag_Wait_i( pstFlag_, usMask_, eMode_, 0);
   4:	00 e0       	ldi	r16, 0x00	; 0
   6:	10 e0       	ldi	r17, 0x00	; 0
   8:	98 01       	movw	r18, r16
   a:	0e 94 00 00 	call	0	; 0x0 <EventFlag_Wait>
#else
    return EventFlag_Wait_i( pstFlag_, usMask_, eMode_);
#endif
}
   e:	1f 91       	pop	r17
  10:	0f 91       	pop	r16
  12:	08 95       	ret

Disassembly of section .text.EventFlag_TimedWait:

00000000 <EventFlag_TimedWait>:

#if KERNEL_USE_TIMEOUTS
//---------------------------------------------------------------------------
K_USHORT EventFlag_TimedWait( EventFlag_t *pstFlag_, K_USHORT usMask_, EventFlagOperation_t eMode_, K_ULONG ulTimeMS_)
{
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17
    return EventFlag_Wait_i( pstFlag_, usMask_, eMode_, ulTimeMS_);
   4:	0e 94 00 00 	call	0	; 0x0 <EventFlag_TimedWait>
}
   8:	1f 91       	pop	r17
   a:	0f 91       	pop	r16
   c:	08 95       	ret

Disassembly of section .text.EventFlag_Set:

00000000 <EventFlag_Set>:
#endif

//---------------------------------------------------------------------------
void EventFlag_Set( EventFlag_t *pstFlag_, K_USHORT usMask_)
{
   0:	7f 92       	push	r7
   2:	8f 92       	push	r8
   4:	9f 92       	push	r9
   6:	af 92       	push	r10
   8:	bf 92       	push	r11
   a:	cf 92       	push	r12
   c:	df 92       	push	r13
   e:	ef 92       	push	r14
  10:	ff 92       	push	r15
  12:	0f 93       	push	r16
  14:	1f 93       	push	r17
  16:	cf 93       	push	r28
  18:	df 93       	push	r29
  1a:	1f 92       	push	r1
  1c:	cd b7       	in	r28, 0x3d	; 61
  1e:	de b7       	in	r29, 0x3e	; 62
  20:	7c 01       	movw	r14, r24
    Thread_t *pstPrev;
    Thread_t *pstCurrent;
    K_BOOL bReschedule = false;
    K_USHORT usNewMask;

    CS_ENTER();
  22:	8f b7       	in	r24, 0x3f	; 63
  24:	89 83       	std	Y+1, r24	; 0x01
  26:	f8 94       	cli

    // Walk through the whole block list, checking to see whether or not
    // the current flag set now matches any/all of the masks and modes of
    // the threads involved.

    pstFlag_->m_usSetMask |= usMask_;
  28:	f7 01       	movw	r30, r14
  2a:	27 81       	ldd	r18, Z+7	; 0x07
  2c:	30 85       	ldd	r19, Z+8	; 0x08
  2e:	26 2b       	or	r18, r22
  30:	37 2b       	or	r19, r23
  32:	30 87       	std	Z+8, r19	; 0x08
  34:	27 83       	std	Z+7, r18	; 0x07

    // Start at the head of the list, and iterate through until we hit the
    // "head" element in the list again.  Ensure that we handle the case where
    // we remove the first or last elements in the list, or if there's only
    // one element in the list.
    pstCurrent = (Thread_t*)(LinkList_GetHead( (LinkList_t*)pstFlag_ ));
  36:	00 81       	ld	r16, Z
  38:	11 81       	ldd	r17, Z+1	; 0x01

    // Do nothing when there are no objects blocking.
    if (pstCurrent)
  3a:	01 15       	cp	r16, r1
  3c:	11 05       	cpc	r17, r1
  3e:	01 f4       	brne	.+0      	; 0x40 <EventFlag_Set+0x40>
  40:	00 c0       	rjmp	.+0      	; 0x42 <EventFlag_Set+0x42>
                }
            }
        }
        // To keep looping, ensure that there's something in the list, and
        // that the next item isn't the head of the list.
        while (pstPrev != (Thread_t*)LinkList_GetTail( (LinkList_t*)pstFlag_ ) );
  42:	42 81       	ldd	r20, Z+2	; 0x02
  44:	53 81       	ldd	r21, Z+3	; 0x03

    // Walk through the whole block list, checking to see whether or not
    // the current flag set now matches any/all of the masks and modes of
    // the threads involved.

    pstFlag_->m_usSetMask |= usMask_;
  46:	69 01       	movw	r12, r18
                }
            }
        }
        // To keep looping, ensure that there's something in the list, and
        // that the next item isn't the head of the list.
        while (pstPrev != (Thread_t*)LinkList_GetTail( (LinkList_t*)pstFlag_ ) );
  48:	f8 01       	movw	r30, r16
  4a:	b1 2c       	mov	r11, r1
            // match the object's flag mask.
            else if ((EVENT_FLAG_ALL == eThreadMode) || (EVENT_FLAG_ALL_CLEAR == eThreadMode))
            {
                if ((usThreadMask & pstFlag_->m_usSetMask) == usThreadMask)
                {
                    Thread_SetEventFlagMode( pstPrev, EVENT_FLAG_PENDING_UNBLOCK );
  4c:	85 e0       	ldi	r24, 0x05	; 5
  4e:	98 2e       	mov	r9, r24
        // see whether or not the current flags match the event-flag conditions
        // on the thread.
        do
        {
            pstPrev = pstCurrent;
            pstCurrent = (Thread_t*)(LinkListNode_GetNext( (LinkListNode_t*)pstCurrent ) );
  50:	a0 80       	ld	r10, Z
  52:	81 80       	ldd	r8, Z+1	; 0x01

            // Read the thread's event mask/mode
            K_USHORT usThreadMask = Thread_GetEventFlagMask( pstPrev );
  54:	80 8d       	ldd	r24, Z+24	; 0x18
  56:	91 8d       	ldd	r25, Z+25	; 0x19
            EventFlagOperation_t eThreadMode = Thread_GetEventFlagMode( pstPrev );
  58:	72 8c       	ldd	r7, Z+26	; 0x1a

            // For the "any" mode - unblock the blocked threads if one or more bits
            // in the thread's bitmask match the object's bitmask
            if ((EVENT_FLAG_ANY == eThreadMode) || (EVENT_FLAG_ANY_CLEAR == eThreadMode))
  5a:	a7 2d       	mov	r26, r7
  5c:	ad 7f       	andi	r26, 0xFD	; 253
  5e:	a1 30       	cpi	r26, 0x01	; 1
  60:	01 f4       	brne	.+0      	; 0x62 <EventFlag_Set+0x62>
            {
                if (usThreadMask & pstFlag_->m_usSetMask)
  62:	d9 01       	movw	r26, r18
  64:	a8 23       	and	r26, r24
  66:	b9 23       	and	r27, r25
  68:	10 97       	sbiw	r26, 0x00	; 0
  6a:	01 f0       	breq	.+0      	; 0x6c <EventFlag_Set+0x6c>
                {
                    Thread_SetEventFlagMode( pstPrev, EVENT_FLAG_PENDING_UNBLOCK );
  6c:	92 8e       	std	Z+26, r9	; 0x1a
                    Thread_SetEventFlagMask( pstPrev, pstFlag_->m_usSetMask & usThreadMask );
  6e:	b1 8f       	std	Z+25, r27	; 0x19
  70:	a0 8f       	std	Z+24, r26	; 0x18
                    bReschedule = true;

                    // If the "clear" variant is set, then clear the bits in the mask
                    // that caused the thread to unblock.
                    if (EVENT_FLAG_ANY_CLEAR == eThreadMode)
  72:	a3 e0       	ldi	r26, 0x03	; 3
  74:	7a 12       	cpse	r7, r26
  76:	00 c0       	rjmp	.+0      	; 0x78 <EventFlag_Set+0x78>
  78:	00 c0       	rjmp	.+0      	; 0x7a <EventFlag_Set+0x7a>
                    }
                }
            }
            // For the "all" mode, every set bit in the thread's requested bitmask must
            // match the object's flag mask.
            else if ((EVENT_FLAG_ALL == eThreadMode) || (EVENT_FLAG_ALL_CLEAR == eThreadMode))
  7a:	a1 11       	cpse	r26, r1
  7c:	00 c0       	rjmp	.+0      	; 0x7e <EventFlag_Set+0x7e>
            {
                if ((usThreadMask & pstFlag_->m_usSetMask) == usThreadMask)
  7e:	d9 01       	movw	r26, r18
  80:	a8 23       	and	r26, r24
  82:	b9 23       	and	r27, r25
  84:	a8 17       	cp	r26, r24
  86:	b9 07       	cpc	r27, r25
  88:	01 f4       	brne	.+0      	; 0x8a <EventFlag_Set+0x8a>
                {
                    Thread_SetEventFlagMode( pstPrev, EVENT_FLAG_PENDING_UNBLOCK );
  8a:	92 8e       	std	Z+26, r9	; 0x1a
                    Thread_SetEventFlagMask( pstPrev, usThreadMask);
                    bReschedule = true;

                    // If the "clear" variant is set, then clear the bits in the mask
                    // that caused the thread to unblock.
                    if (EVENT_FLAG_ALL_CLEAR == eThreadMode)
  8c:	82 e0       	ldi	r24, 0x02	; 2
  8e:	78 12       	cpse	r7, r24
  90:	00 c0       	rjmp	.+0      	; 0x92 <EventFlag_Set+0x92>
                    {
                        usNewMask &=~ (usThreadMask & usMask_);
  92:	cd 01       	movw	r24, r26
  94:	86 23       	and	r24, r22
  96:	97 23       	and	r25, r23
  98:	80 95       	com	r24
  9a:	90 95       	com	r25
  9c:	c8 22       	and	r12, r24
  9e:	d9 22       	and	r13, r25
            {
                if ((usThreadMask & pstFlag_->m_usSetMask) == usThreadMask)
                {
                    Thread_SetEventFlagMode( pstPrev, EVENT_FLAG_PENDING_UNBLOCK );
                    Thread_SetEventFlagMask( pstPrev, usThreadMask);
                    bReschedule = true;
  a0:	bb 24       	eor	r11, r11
  a2:	b3 94       	inc	r11
                }
            }
        }
        // To keep looping, ensure that there's something in the list, and
        // that the next item isn't the head of the list.
        while (pstPrev != (Thread_t*)LinkList_GetTail( (LinkList_t*)pstFlag_ ) );
  a4:	e4 17       	cp	r30, r20
  a6:	f5 07       	cpc	r31, r21
  a8:	01 f0       	breq	.+0      	; 0xaa <EventFlag_Set+0xaa>
        // see whether or not the current flags match the event-flag conditions
        // on the thread.
        do
        {
            pstPrev = pstCurrent;
            pstCurrent = (Thread_t*)(LinkListNode_GetNext( (LinkListNode_t*)pstCurrent ) );
  aa:	ea 2d       	mov	r30, r10
  ac:	f8 2d       	mov	r31, r8
  ae:	00 c0       	rjmp	.+0      	; 0xb0 <EventFlag_Set+0xb0>
            if (Thread_GetEventFlagMode( pstPrev ) == EVENT_FLAG_PENDING_UNBLOCK)
            {
                BlockingObject_UnBlock( pstPrev );
            }
        }
        while (!bIsTail);
  b0:	08 15       	cp	r16, r8
  b2:	19 05       	cpc	r17, r9
  b4:	01 f0       	breq	.+0      	; 0xb6 <EventFlag_Set+0xb6>
        pstCurrent = (Thread_t*)(LinkList_GetHead( (LinkList_t*)pstFlag_ ));
        K_BOOL bIsTail = false;
        do
        {
            pstPrev = pstCurrent;
            pstCurrent = (Thread_t*)(LinkListNode_GetNext( (LinkListNode_t*)pstCurrent ));
  b6:	07 2d       	mov	r16, r7
  b8:	1a 2d       	mov	r17, r10
  ba:	f8 01       	movw	r30, r16
  bc:	70 80       	ld	r7, Z
  be:	a1 80       	ldd	r10, Z+1	; 0x01

            // Check to see if this is the condition to terminate the loop
            if (pstPrev == (Thread_t*)(LinkList_GetTail( (LinkList_t*)pstFlag_ )))
  c0:	f7 01       	movw	r30, r14
  c2:	82 80       	ldd	r8, Z+2	; 0x02
  c4:	93 80       	ldd	r9, Z+3	; 0x03
                bIsTail = true;
            }

            // If the first pass indicated that this thread should be
            // unblocked, then unblock the thread
            if (Thread_GetEventFlagMode( pstPrev ) == EVENT_FLAG_PENDING_UNBLOCK)
  c6:	f8 01       	movw	r30, r16
  c8:	82 8d       	ldd	r24, Z+26	; 0x1a
  ca:	85 30       	cpi	r24, 0x05	; 5
  cc:	01 f4       	brne	.+0      	; 0xce <EventFlag_Set+0xce>
            {
                BlockingObject_UnBlock( pstPrev );
  ce:	c8 01       	movw	r24, r16
  d0:	0e 94 00 00 	call	0	; 0x0 <EventFlag_Set>
  d4:	00 c0       	rjmp	.+0      	; 0xd6 <EventFlag_Set+0xd6>
        }
        while (!bIsTail);
    }

    // If we awoke any threads, re-run the scheduler
    if (bReschedule)
  d6:	bb 20       	and	r11, r11
  d8:	01 f0       	breq	.+0      	; 0xda <EventFlag_Set+0xda>
    {
        Thread_Yield();
  da:	0e 94 00 00 	call	0	; 0x0 <EventFlag_Set>
  de:	00 c0       	rjmp	.+0      	; 0xe0 <EventFlag_Set+0xe0>

    // Walk through the whole block list, checking to see whether or not
    // the current flag set now matches any/all of the masks and modes of
    // the threads involved.

    pstFlag_->m_usSetMask |= usMask_;
  e0:	69 01       	movw	r12, r18
        Thread_Yield();
    }

    // Update the bitmask based on any "clear" operations performed along
    // the way
    pstFlag_->m_usSetMask = usNewMask;
  e2:	f7 01       	movw	r30, r14
  e4:	d0 86       	std	Z+8, r13	; 0x08
  e6:	c7 82       	std	Z+7, r12	; 0x07

    // Restore interrupts - will potentially cause a context switch if a
    // thread is unblocked.
    CS_EXIT();
  e8:	89 81       	ldd	r24, Y+1	; 0x01
  ea:	8f bf       	out	0x3f, r24	; 63
}
  ec:	0f 90       	pop	r0
  ee:	df 91       	pop	r29
  f0:	cf 91       	pop	r28
  f2:	1f 91       	pop	r17
  f4:	0f 91       	pop	r16
  f6:	ff 90       	pop	r15
  f8:	ef 90       	pop	r14
  fa:	df 90       	pop	r13
  fc:	cf 90       	pop	r12
  fe:	bf 90       	pop	r11
 100:	af 90       	pop	r10
 102:	9f 90       	pop	r9
 104:	8f 90       	pop	r8
 106:	7f 90       	pop	r7
 108:	08 95       	ret

Disassembly of section .text.EventFlag_Clear:

00000000 <EventFlag_Clear>:

//---------------------------------------------------------------------------
void EventFlag_Clear( EventFlag_t *pstFlag_, K_USHORT usMask_)
{
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	1f 92       	push	r1
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
    // Just clear the bitfields in the local object.
    CS_ENTER();
   a:	2f b7       	in	r18, 0x3f	; 63
   c:	29 83       	std	Y+1, r18	; 0x01
   e:	f8 94       	cli
    pstFlag_->m_usSetMask &= ~usMask_;
  10:	60 95       	com	r22
  12:	70 95       	com	r23
  14:	fc 01       	movw	r30, r24
  16:	27 81       	ldd	r18, Z+7	; 0x07
  18:	30 85       	ldd	r19, Z+8	; 0x08
  1a:	26 23       	and	r18, r22
  1c:	37 23       	and	r19, r23
  1e:	30 87       	std	Z+8, r19	; 0x08
  20:	27 83       	std	Z+7, r18	; 0x07
    CS_EXIT();
  22:	89 81       	ldd	r24, Y+1	; 0x01
  24:	8f bf       	out	0x3f, r24	; 63
}
  26:	0f 90       	pop	r0
  28:	df 91       	pop	r29
  2a:	cf 91       	pop	r28
  2c:	08 95       	ret

Disassembly of section .text.EventFlag_GetMask:

00000000 <EventFlag_GetMask>:

//---------------------------------------------------------------------------
K_USHORT EventFlag_GetMask( EventFlag_t *pstFlag_ )
{
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	1f 92       	push	r1
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
    // Return the presently held event flag values in this object.  Ensure
    // we get this within a critical section to guarantee atomicity.
    K_USHORT usReturn;
    CS_ENTER();
   a:	2f b7       	in	r18, 0x3f	; 63
   c:	29 83       	std	Y+1, r18	; 0x01
   e:	f8 94       	cli
    usReturn = pstFlag_->m_usSetMask;
  10:	fc 01       	movw	r30, r24
  12:	87 81       	ldd	r24, Z+7	; 0x07
  14:	90 85       	ldd	r25, Z+8	; 0x08
    CS_EXIT();
  16:	29 81       	ldd	r18, Y+1	; 0x01
  18:	2f bf       	out	0x3f, r18	; 63
    return usReturn;
}
  1a:	0f 90       	pop	r0
  1c:	df 91       	pop	r29
  1e:	cf 91       	pop	r28
  20:	08 95       	ret

ll.c.o:     file format elf32-avr


Disassembly of section .text.DoubleLinkList_Add:

00000000 <DoubleLinkList_Add>:
#endif
#define __FILE_ID__ 	LL_C        //!< File ID used in kernel trace calls

//---------------------------------------------------------------------------
void DoubleLinkList_Add( DoubleLinkList_t *pstList_, LinkListNode_t *node_)
{
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	dc 01       	movw	r26, r24
   6:	fb 01       	movw	r30, r22
	KERNEL_ASSERT( node_ );
	
    // Add a node to the end of the linked list.
    if (!pstList_->m_pstHead)
   8:	8d 91       	ld	r24, X+
   a:	9c 91       	ld	r25, X
   c:	11 97       	sbiw	r26, 0x01	; 1
   e:	89 2b       	or	r24, r25
  10:	01 f4       	brne	.+0      	; 0x12 <DoubleLinkList_Add+0x12>
    {
        // If the list is empty, initilize the nodes
        pstList_->m_pstHead = node_;
  12:	11 96       	adiw	r26, 0x01	; 1
  14:	7c 93       	st	X, r23
  16:	6e 93       	st	-X, r22
        pstList_->m_pstTail = node_;
  18:	13 96       	adiw	r26, 0x03	; 3
  1a:	7c 93       	st	X, r23
  1c:	6e 93       	st	-X, r22
  1e:	12 97       	sbiw	r26, 0x02	; 2

        pstList_->m_pstHead->prev = NULL;
  20:	13 82       	std	Z+3, r1	; 0x03
  22:	12 82       	std	Z+2, r1	; 0x02
        pstList_->m_pstTail->next = NULL;
  24:	11 82       	std	Z+1, r1	; 0x01
  26:	10 82       	st	Z, r1
        return;
  28:	00 c0       	rjmp	.+0      	; 0x2a <DoubleLinkList_Add+0x2a>
    }
    
    // Move the tail node, and assign it to the new node just passed in
    pstList_->m_pstTail->next = node_;
  2a:	12 96       	adiw	r26, 0x02	; 2
  2c:	cd 91       	ld	r28, X+
  2e:	dc 91       	ld	r29, X
  30:	13 97       	sbiw	r26, 0x03	; 3
  32:	79 83       	std	Y+1, r23	; 0x01
  34:	68 83       	st	Y, r22
    node_->prev = pstList_->m_pstTail;
  36:	d3 83       	std	Z+3, r29	; 0x03
  38:	c2 83       	std	Z+2, r28	; 0x02
    node_->next = NULL;    
  3a:	11 82       	std	Z+1, r1	; 0x01
  3c:	10 82       	st	Z, r1
    pstList_->m_pstTail = node_;
  3e:	13 96       	adiw	r26, 0x03	; 3
  40:	7c 93       	st	X, r23
  42:	6e 93       	st	-X, r22
  44:	12 97       	sbiw	r26, 0x02	; 2
}
  46:	df 91       	pop	r29
  48:	cf 91       	pop	r28
  4a:	08 95       	ret

Disassembly of section .text.DoubleLinkList_Remove:

00000000 <DoubleLinkList_Remove>:

//---------------------------------------------------------------------------
void DoubleLinkList_Remove( DoubleLinkList_t *pstList_, LinkListNode_t *node_)
{
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	dc 01       	movw	r26, r24
   6:	fb 01       	movw	r30, r22
	KERNEL_ASSERT( node_ );

    if (node_->prev)
   8:	82 81       	ldd	r24, Z+2	; 0x02
   a:	93 81       	ldd	r25, Z+3	; 0x03
   c:	00 97       	sbiw	r24, 0x00	; 0
   e:	01 f0       	breq	.+0      	; 0x10 <DoubleLinkList_Remove+0x10>
        if (node_->prev->next != node_)
        {
            Kernel_Panic(PANIC_LIST_UNLINK_FAILED);
        }
#endif
        node_->prev->next = node_->next;
  10:	20 81       	ld	r18, Z
  12:	31 81       	ldd	r19, Z+1	; 0x01
  14:	ec 01       	movw	r28, r24
  16:	39 83       	std	Y+1, r19	; 0x01
  18:	28 83       	st	Y, r18
    }
    if (node_->next)
  1a:	c0 81       	ld	r28, Z
  1c:	d1 81       	ldd	r29, Z+1	; 0x01
  1e:	20 97       	sbiw	r28, 0x00	; 0
  20:	01 f0       	breq	.+0      	; 0x22 <DoubleLinkList_Remove+0x22>
        if (node_->next->prev != node_)
        {
            Kernel_Panic(PANIC_LIST_UNLINK_FAILED);
        }
#endif
        node_->next->prev = node_->prev;
  22:	9b 83       	std	Y+3, r25	; 0x03
  24:	8a 83       	std	Y+2, r24	; 0x02
    }
    if (node_ == pstList_->m_pstHead)
  26:	8d 91       	ld	r24, X+
  28:	9c 91       	ld	r25, X
  2a:	11 97       	sbiw	r26, 0x01	; 1
  2c:	e8 17       	cp	r30, r24
  2e:	f9 07       	cpc	r31, r25
  30:	01 f4       	brne	.+0      	; 0x32 <DoubleLinkList_Remove+0x32>
    {        
        pstList_->m_pstHead = node_->next;
  32:	11 96       	adiw	r26, 0x01	; 1
  34:	dc 93       	st	X, r29
  36:	ce 93       	st	-X, r28
    }
    if (node_ == pstList_->m_pstTail)
  38:	12 96       	adiw	r26, 0x02	; 2
  3a:	8d 91       	ld	r24, X+
  3c:	9c 91       	ld	r25, X
  3e:	13 97       	sbiw	r26, 0x03	; 3
  40:	e8 17       	cp	r30, r24
  42:	f9 07       	cpc	r31, r25
  44:	01 f4       	brne	.+0      	; 0x46 <DoubleLinkList_Remove+0x46>
    {
        pstList_->m_pstTail = node_->prev;
  46:	82 81       	ldd	r24, Z+2	; 0x02
  48:	93 81       	ldd	r25, Z+3	; 0x03
  4a:	13 96       	adiw	r26, 0x03	; 3
  4c:	9c 93       	st	X, r25
  4e:	8e 93       	st	-X, r24
  50:	12 97       	sbiw	r26, 0x02	; 2
    }
    
    LinkListNode_Clear( node_ );
  52:	11 82       	std	Z+1, r1	; 0x01
  54:	10 82       	st	Z, r1
  56:	13 82       	std	Z+3, r1	; 0x03
  58:	12 82       	std	Z+2, r1	; 0x02
}
  5a:	df 91       	pop	r29
  5c:	cf 91       	pop	r28
  5e:	08 95       	ret

Disassembly of section .text.CircularLinkList_Add:

00000000 <CircularLinkList_Add>:



//---------------------------------------------------------------------------
void CircularLinkList_Add( CircularLinkList_t *pstList_, LinkListNode_t *node_)
{
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	dc 01       	movw	r26, r24
   6:	fb 01       	movw	r30, r22
	KERNEL_ASSERT( node_ );

    // Add a node to the end of the linked list.
    if (!pstList_->m_pstHead)
   8:	2d 91       	ld	r18, X+
   a:	3c 91       	ld	r19, X
   c:	11 97       	sbiw	r26, 0x01	; 1
   e:	21 15       	cp	r18, r1
  10:	31 05       	cpc	r19, r1
  12:	01 f4       	brne	.+0      	; 0x14 <CircularLinkList_Add+0x14>
    {
        // If the list is empty, initilize the nodes
        pstList_->m_pstHead = node_;
  14:	11 96       	adiw	r26, 0x01	; 1
  16:	7c 93       	st	X, r23
  18:	6e 93       	st	-X, r22
        pstList_->m_pstTail = node_;
  1a:	13 96       	adiw	r26, 0x03	; 3
  1c:	7c 93       	st	X, r23
  1e:	6e 93       	st	-X, r22
  20:	12 97       	sbiw	r26, 0x02	; 2

        pstList_->m_pstHead->prev = pstList_->m_pstHead;
  22:	73 83       	std	Z+3, r23	; 0x03
  24:	62 83       	std	Z+2, r22	; 0x02
        pstList_->m_pstHead->next = pstList_->m_pstHead;
  26:	71 83       	std	Z+1, r23	; 0x01
  28:	60 83       	st	Z, r22
        return;
  2a:	00 c0       	rjmp	.+0      	; 0x2c <CircularLinkList_Add+0x2c>
    }
    
    // Move the tail node, and assign it to the new node just passed in
    pstList_->m_pstTail->next = node_;
  2c:	12 96       	adiw	r26, 0x02	; 2
  2e:	8d 91       	ld	r24, X+
  30:	9c 91       	ld	r25, X
  32:	13 97       	sbiw	r26, 0x03	; 3
  34:	ec 01       	movw	r28, r24
  36:	79 83       	std	Y+1, r23	; 0x01
  38:	68 83       	st	Y, r22
    node_->prev = pstList_->m_pstTail;
  3a:	93 83       	std	Z+3, r25	; 0x03
  3c:	82 83       	std	Z+2, r24	; 0x02
    node_->next = pstList_->m_pstHead;
  3e:	31 83       	std	Z+1, r19	; 0x01
  40:	20 83       	st	Z, r18
    pstList_->m_pstTail = node_;
  42:	13 96       	adiw	r26, 0x03	; 3
  44:	7c 93       	st	X, r23
  46:	6e 93       	st	-X, r22
  48:	12 97       	sbiw	r26, 0x02	; 2
    pstList_->m_pstHead->prev = node_;
  4a:	d9 01       	movw	r26, r18
  4c:	13 96       	adiw	r26, 0x03	; 3
  4e:	7c 93       	st	X, r23
  50:	6e 93       	st	-X, r22
  52:	12 97       	sbiw	r26, 0x02	; 2
}
  54:	df 91       	pop	r29
  56:	cf 91       	pop	r28
  58:	08 95       	ret

Disassembly of section .text.CircularLinkList_Remove:

00000000 <CircularLinkList_Remove>:

//---------------------------------------------------------------------------
void CircularLinkList_Remove( CircularLinkList_t *pstList_, LinkListNode_t *node_)
{
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	dc 01       	movw	r26, r24
   6:	fb 01       	movw	r30, r22
	KERNEL_ASSERT( node_ );
	
    // Check to see if this is the head of the list...
    if ((node_ == pstList_->m_pstHead) && (pstList_->m_pstHead == pstList_->m_pstTail))
   8:	2d 91       	ld	r18, X+
   a:	3c 91       	ld	r19, X
   c:	11 97       	sbiw	r26, 0x01	; 1
   e:	12 96       	adiw	r26, 0x02	; 2
  10:	8d 91       	ld	r24, X+
  12:	9c 91       	ld	r25, X
  14:	13 97       	sbiw	r26, 0x03	; 3
  16:	62 17       	cp	r22, r18
  18:	73 07       	cpc	r23, r19
  1a:	01 f4       	brne	.+0      	; 0x1c <CircularLinkList_Remove+0x1c>
  1c:	68 17       	cp	r22, r24
  1e:	79 07       	cpc	r23, r25
  20:	01 f4       	brne	.+0      	; 0x22 <CircularLinkList_Remove+0x22>
    {
        // Clear the head and tail pointers - nothing else left.
        pstList_->m_pstHead = NULL;
  22:	11 96       	adiw	r26, 0x01	; 1
  24:	1c 92       	st	X, r1
  26:	1e 92       	st	-X, r1
        pstList_->m_pstTail = NULL;
  28:	13 96       	adiw	r26, 0x03	; 3
  2a:	1c 92       	st	X, r1
  2c:	1e 92       	st	-X, r1
  2e:	12 97       	sbiw	r26, 0x02	; 2
        return;
  30:	00 c0       	rjmp	.+0      	; 0x32 <CircularLinkList_Remove+0x32>
    }
#endif

    // This is a circularly linked list - no need to check for connection,
    // just remove the node.
    node_->next->prev = node_->prev;
  32:	40 81       	ld	r20, Z
  34:	51 81       	ldd	r21, Z+1	; 0x01
  36:	62 81       	ldd	r22, Z+2	; 0x02
  38:	73 81       	ldd	r23, Z+3	; 0x03
  3a:	ea 01       	movw	r28, r20
  3c:	7b 83       	std	Y+3, r23	; 0x03
  3e:	6a 83       	std	Y+2, r22	; 0x02
    node_->prev->next = node_->next;
  40:	c2 81       	ldd	r28, Z+2	; 0x02
  42:	d3 81       	ldd	r29, Z+3	; 0x03
  44:	59 83       	std	Y+1, r21	; 0x01
  46:	48 83       	st	Y, r20
    
    if (node_ == pstList_->m_pstHead)
  48:	e2 17       	cp	r30, r18
  4a:	f3 07       	cpc	r31, r19
  4c:	01 f4       	brne	.+0      	; 0x4e <CircularLinkList_Remove+0x4e>
    {
        pstList_->m_pstHead = pstList_->m_pstHead->next;
  4e:	20 81       	ld	r18, Z
  50:	31 81       	ldd	r19, Z+1	; 0x01
  52:	11 96       	adiw	r26, 0x01	; 1
  54:	3c 93       	st	X, r19
  56:	2e 93       	st	-X, r18
    }
    if (node_ == pstList_->m_pstTail)
  58:	e8 17       	cp	r30, r24
  5a:	f9 07       	cpc	r31, r25
  5c:	01 f4       	brne	.+0      	; 0x5e <CircularLinkList_Remove+0x5e>
    {
        pstList_->m_pstTail = pstList_->m_pstTail->prev;
  5e:	13 96       	adiw	r26, 0x03	; 3
  60:	dc 93       	st	X, r29
  62:	ce 93       	st	-X, r28
  64:	12 97       	sbiw	r26, 0x02	; 2
    }
    LinkListNode_Clear( node_ );
  66:	11 82       	std	Z+1, r1	; 0x01
  68:	10 82       	st	Z, r1
  6a:	13 82       	std	Z+3, r1	; 0x03
  6c:	12 82       	std	Z+2, r1	; 0x02
}
  6e:	df 91       	pop	r29
  70:	cf 91       	pop	r28
  72:	08 95       	ret

Disassembly of section .text.CircularLinkList_PivotForward:

00000000 <CircularLinkList_PivotForward>:

//---------------------------------------------------------------------------
void CircularLinkList_PivotForward( CircularLinkList_t *pstList_ )
{
   0:	fc 01       	movw	r30, r24
    if (pstList_->m_pstHead)
   2:	a0 81       	ld	r26, Z
   4:	b1 81       	ldd	r27, Z+1	; 0x01
   6:	10 97       	sbiw	r26, 0x00	; 0
   8:	01 f0       	breq	.+0      	; 0xa <CircularLinkList_PivotForward+0xa>
    {
        pstList_->m_pstHead = pstList_->m_pstHead->next;
   a:	8d 91       	ld	r24, X+
   c:	9c 91       	ld	r25, X
   e:	91 83       	std	Z+1, r25	; 0x01
  10:	80 83       	st	Z, r24
        pstList_->m_pstTail = pstList_->m_pstTail->next;
  12:	a2 81       	ldd	r26, Z+2	; 0x02
  14:	b3 81       	ldd	r27, Z+3	; 0x03
  16:	8d 91       	ld	r24, X+
  18:	9c 91       	ld	r25, X
  1a:	93 83       	std	Z+3, r25	; 0x03
  1c:	82 83       	std	Z+2, r24	; 0x02
  1e:	08 95       	ret

Disassembly of section .text.CircularLinkList_PivotBackward:

00000000 <CircularLinkList_PivotBackward>:
    }
}

//---------------------------------------------------------------------------
void CircularLinkList_PivotBackward(  CircularLinkList_t *pstList_ )
{
   0:	fc 01       	movw	r30, r24
    if (pstList_->m_pstHead)
   2:	a0 81       	ld	r26, Z
   4:	b1 81       	ldd	r27, Z+1	; 0x01
   6:	10 97       	sbiw	r26, 0x00	; 0
   8:	01 f0       	breq	.+0      	; 0xa <CircularLinkList_PivotBackward+0xa>
    {
        pstList_->m_pstHead = pstList_->m_pstHead->prev;
   a:	12 96       	adiw	r26, 0x02	; 2
   c:	8d 91       	ld	r24, X+
   e:	9c 91       	ld	r25, X
  10:	13 97       	sbiw	r26, 0x03	; 3
  12:	91 83       	std	Z+1, r25	; 0x01
  14:	80 83       	st	Z, r24
        pstList_->m_pstTail = pstList_->m_pstTail->prev;
  16:	a2 81       	ldd	r26, Z+2	; 0x02
  18:	b3 81       	ldd	r27, Z+3	; 0x03
  1a:	12 96       	adiw	r26, 0x02	; 2
  1c:	8d 91       	ld	r24, X+
  1e:	9c 91       	ld	r25, X
  20:	13 97       	sbiw	r26, 0x03	; 3
  22:	93 83       	std	Z+3, r25	; 0x03
  24:	82 83       	std	Z+2, r24	; 0x02
  26:	08 95       	ret

message.c.o:     file format elf32-avr


Disassembly of section .text.MessageQueue_Receive_i:

00000000 <MessageQueue_Receive_i>:
#if KERNEL_USE_TIMEOUTS
Message_t *MessageQueue_Receive_i( MessageQueue_t *pstMsgQ_, K_ULONG ulTimeWaitMS_ )
#else
Message_t *MessageQueue_Receive_i(  MessageQueue_t *pstMsgQ_ )
#endif
{
   0:	ef 92       	push	r14
   2:	ff 92       	push	r15
   4:	0f 93       	push	r16
   6:	1f 93       	push	r17
   8:	cf 93       	push	r28
   a:	df 93       	push	r29
   c:	1f 92       	push	r1
   e:	cd b7       	in	r28, 0x3d	; 61
  10:	de b7       	in	r29, 0x3e	; 62
  12:	8c 01       	movw	r16, r24
	Message_t *pstRet;
	
	// Block the current thread on the counting Semaphore_t
#if KERNEL_USE_TIMEOUTS
	if ( 0 == Semaphore_TimedPend( &(pstMsgQ_->m_clSemaphore), ulTimeWaitMS_ ) )    
  14:	0e 94 00 00 	call	0	; 0x0 <MessageQueue_Receive_i>
  18:	88 23       	and	r24, r24
  1a:	01 f0       	breq	.+0      	; 0x1c <MessageQueue_Receive_i+0x1c>
    }
#else
	Semaphore_Pend( &(pstMsgQ_->m_clSemaphore) );    
#endif
	
	CS_ENTER();
  1c:	8f b7       	in	r24, 0x3f	; 63
  1e:	89 83       	std	Y+1, r24	; 0x01
  20:	f8 94       	cli
	
	// Pop the head of the message queue and return it
	pstRet = (Message_t*)LinkList_GetHead( (LinkList_t*)&(pstMsgQ_->m_clLinkList) );
  22:	f8 01       	movw	r30, r16
  24:	e3 84       	ldd	r14, Z+11	; 0x0b
  26:	f4 84       	ldd	r15, Z+12	; 0x0c
	DoubleLinkList_Remove( (DoubleLinkList_t*)&(pstMsgQ_->m_clLinkList), (LinkListNode_t*)pstRet );
  28:	b7 01       	movw	r22, r14
  2a:	c8 01       	movw	r24, r16
  2c:	0b 96       	adiw	r24, 0x0b	; 11
  2e:	0e 94 00 00 	call	0	; 0x0 <MessageQueue_Receive_i>
	
	CS_EXIT();
  32:	89 81       	ldd	r24, Y+1	; 0x01
  34:	8f bf       	out	0x3f, r24	; 63
	
	return pstRet;	
  36:	c7 01       	movw	r24, r14
  38:	00 c0       	rjmp	.+0      	; 0x3a <MessageQueue_Receive_i+0x3a>
	
	// Block the current thread on the counting Semaphore_t
#if KERNEL_USE_TIMEOUTS
	if ( 0 == Semaphore_TimedPend( &(pstMsgQ_->m_clSemaphore), ulTimeWaitMS_ ) )    
    {
        return NULL;
  3a:	80 e0       	ldi	r24, 0x00	; 0
  3c:	90 e0       	ldi	r25, 0x00	; 0
	DoubleLinkList_Remove( (DoubleLinkList_t*)&(pstMsgQ_->m_clLinkList), (LinkListNode_t*)pstRet );
	
	CS_EXIT();
	
	return pstRet;	
}
  3e:	0f 90       	pop	r0
  40:	df 91       	pop	r29
  42:	cf 91       	pop	r28
  44:	1f 91       	pop	r17
  46:	0f 91       	pop	r16
  48:	ff 90       	pop	r15
  4a:	ef 90       	pop	r14
  4c:	08 95       	ret

Disassembly of section .text.Message_Init:

00000000 <Message_Init>:
static Message_t *MessageQueue_Receive_i( MessageQueue_t *pstMsgQ_ );
#endif

//---------------------------------------------------------------------------
void Message_Init( Message_t* pstMsg_ ) 
{ 
   0:	fc 01       	movw	r30, r24
	LinkListNode_Clear( (LinkListNode_t*)pstMsg_ );
   2:	11 82       	std	Z+1, r1	; 0x01
   4:	10 82       	st	Z, r1
   6:	13 82       	std	Z+3, r1	; 0x03
   8:	12 82       	std	Z+2, r1	; 0x02
	pstMsg_->m_pvData = NULL; 
   a:	15 82       	std	Z+5, r1	; 0x05
   c:	14 82       	std	Z+4, r1	; 0x04
	pstMsg_->m_usCode = 0; 
   e:	17 82       	std	Z+7, r1	; 0x07
  10:	16 82       	std	Z+6, r1	; 0x06
  12:	08 95       	ret

Disassembly of section .text.Message_SetData:

00000000 <Message_SetData>:
}
    
//---------------------------------------------------------------------------
void Message_SetData( Message_t* pstMsg_, void *pvData_ ) 
{ 
	pstMsg_->m_pvData = pvData_; 
   0:	fc 01       	movw	r30, r24
   2:	75 83       	std	Z+5, r23	; 0x05
   4:	64 83       	std	Z+4, r22	; 0x04
   6:	08 95       	ret

Disassembly of section .text.Message_GetData:

00000000 <Message_GetData>:
    
//---------------------------------------------------------------------------
void *Message_GetData( Message_t* pstMsg_ ) 
{ 
	return pstMsg_->m_pvData; 
}
   0:	fc 01       	movw	r30, r24
   2:	84 81       	ldd	r24, Z+4	; 0x04
   4:	95 81       	ldd	r25, Z+5	; 0x05
   6:	08 95       	ret

Disassembly of section .text.Message_SetCode:

00000000 <Message_SetCode>:
	
//---------------------------------------------------------------------------
void Message_SetCode(  Message_t* pstMsg_, K_USHORT usCode_ ) 
{ 
	pstMsg_->m_usCode = usCode_; 
   0:	fc 01       	movw	r30, r24
   2:	77 83       	std	Z+7, r23	; 0x07
   4:	66 83       	std	Z+6, r22	; 0x06
   6:	08 95       	ret

Disassembly of section .text.Message_GetCode:

00000000 <Message_GetCode>:
	
//---------------------------------------------------------------------------
K_USHORT Message_GetCode( Message_t* pstMsg_ ) 
{ 
	return pstMsg_->m_usCode; 
}
   0:	fc 01       	movw	r30, r24
   2:	86 81       	ldd	r24, Z+6	; 0x06
   4:	97 81       	ldd	r25, Z+7	; 0x07
   6:	08 95       	ret

Disassembly of section .text.GlobalMessagePool_Init:

00000000 <GlobalMessagePool_Init>:

//---------------------------------------------------------------------------
void GlobalMessagePool_Init( void )
{
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
	K_UCHAR i;

	DoubleLinkList_Init( &m_clList );
   4:	10 92 00 00 	sts	0x0000, r1
   8:	10 92 00 00 	sts	0x0000, r1
   c:	10 92 00 00 	sts	0x0000, r1
  10:	10 92 00 00 	sts	0x0000, r1
  14:	c0 e0       	ldi	r28, 0x00	; 0
  16:	d0 e0       	ldi	r29, 0x00	; 0
#endif

//---------------------------------------------------------------------------
void Message_Init( Message_t* pstMsg_ ) 
{ 
	LinkListNode_Clear( (LinkListNode_t*)pstMsg_ );
  18:	19 82       	std	Y+1, r1	; 0x01
  1a:	18 82       	st	Y, r1
  1c:	1b 82       	std	Y+3, r1	; 0x03
  1e:	1a 82       	std	Y+2, r1	; 0x02
	pstMsg_->m_pvData = NULL; 
  20:	1d 82       	std	Y+5, r1	; 0x05
  22:	1c 82       	std	Y+4, r1	; 0x04
	pstMsg_->m_usCode = 0; 
  24:	1f 82       	std	Y+7, r1	; 0x07
  26:	1e 82       	std	Y+6, r1	; 0x06
	DoubleLinkList_Init( &m_clList );
	
    for (i = 0; i < GLOBAL_MESSAGE_POOL_SIZE; i++)
	{
		Message_Init( &m_aclMessagePool[i] );
		DoubleLinkList_Add( &m_clList, (LinkListNode_t*)&m_aclMessagePool[i]);	
  28:	be 01       	movw	r22, r28
  2a:	80 e0       	ldi	r24, 0x00	; 0
  2c:	90 e0       	ldi	r25, 0x00	; 0
  2e:	0e 94 00 00 	call	0	; 0x0 <GlobalMessagePool_Init>
  32:	28 96       	adiw	r28, 0x08	; 8
{
	K_UCHAR i;

	DoubleLinkList_Init( &m_clList );
	
    for (i = 0; i < GLOBAL_MESSAGE_POOL_SIZE; i++)
  34:	80 e0       	ldi	r24, 0x00	; 0
  36:	c0 30       	cpi	r28, 0x00	; 0
  38:	d8 07       	cpc	r29, r24
  3a:	01 f4       	brne	.+0      	; 0x3c <GlobalMessagePool_Init+0x3c>
	{
		Message_Init( &m_aclMessagePool[i] );
		DoubleLinkList_Add( &m_clList, (LinkListNode_t*)&m_aclMessagePool[i]);	
	}
}
  3c:	df 91       	pop	r29
  3e:	cf 91       	pop	r28
  40:	08 95       	ret

Disassembly of section .text.GlobalMessagePool_Push:

00000000 <GlobalMessagePool_Push>:

//---------------------------------------------------------------------------
void GlobalMessagePool_Push( Message_t *pstMessage_ )
{
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	1f 92       	push	r1
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
	KERNEL_ASSERT( pstMessage_ );
	
	CS_ENTER();
   a:	2f b7       	in	r18, 0x3f	; 63
   c:	29 83       	std	Y+1, r18	; 0x01
   e:	f8 94       	cli
	
	DoubleLinkList_Add( &m_clList, (LinkListNode_t*)pstMessage_ );
  10:	bc 01       	movw	r22, r24
  12:	80 e0       	ldi	r24, 0x00	; 0
  14:	90 e0       	ldi	r25, 0x00	; 0
  16:	0e 94 00 00 	call	0	; 0x0 <GlobalMessagePool_Push>

	CS_EXIT();
  1a:	89 81       	ldd	r24, Y+1	; 0x01
  1c:	8f bf       	out	0x3f, r24	; 63
}
  1e:	0f 90       	pop	r0
  20:	df 91       	pop	r29
  22:	cf 91       	pop	r28
  24:	08 95       	ret

Disassembly of section .text.GlobalMessagePool_Pop:

00000000 <GlobalMessagePool_Pop>:
	
//---------------------------------------------------------------------------
Message_t *GlobalMessagePool_Pop( void )
{
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17
   4:	cf 93       	push	r28
   6:	df 93       	push	r29
   8:	1f 92       	push	r1
   a:	cd b7       	in	r28, 0x3d	; 61
   c:	de b7       	in	r29, 0x3e	; 62
	Message_t *pstRet;
	CS_ENTER();
   e:	8f b7       	in	r24, 0x3f	; 63
  10:	89 83       	std	Y+1, r24	; 0x01
  12:	f8 94       	cli
	
	pstRet = (Message_t*)( LinkList_GetHead( (LinkList_t*)&m_clList ) );
  14:	00 91 00 00 	lds	r16, 0x0000
  18:	10 91 00 00 	lds	r17, 0x0000
    if (0 != pstRet)
  1c:	01 15       	cp	r16, r1
  1e:	11 05       	cpc	r17, r1
  20:	01 f0       	breq	.+0      	; 0x22 <GlobalMessagePool_Pop+0x22>
    {
		DoubleLinkList_Remove( &m_clList, (LinkListNode_t*)pstRet );
  22:	b8 01       	movw	r22, r16
  24:	80 e0       	ldi	r24, 0x00	; 0
  26:	90 e0       	ldi	r25, 0x00	; 0
  28:	0e 94 00 00 	call	0	; 0x0 <GlobalMessagePool_Pop>
    }
	
	CS_EXIT();
  2c:	89 81       	ldd	r24, Y+1	; 0x01
  2e:	8f bf       	out	0x3f, r24	; 63
	return pstRet;
}
  30:	c8 01       	movw	r24, r16
  32:	0f 90       	pop	r0
  34:	df 91       	pop	r29
  36:	cf 91       	pop	r28
  38:	1f 91       	pop	r17
  3a:	0f 91       	pop	r16
  3c:	08 95       	ret

Disassembly of section .text.MessageQueue_Init:

00000000 <MessageQueue_Init>:

//---------------------------------------------------------------------------
void MessageQueue_Init( MessageQueue_t *pstMsgQ_ ) 
{ 
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	ec 01       	movw	r28, r24
	Semaphore_Init( &(pstMsgQ_->m_clSemaphore), 0, GLOBAL_MESSAGE_POOL_SIZE);  
   6:	48 e0       	ldi	r20, 0x08	; 8
   8:	50 e0       	ldi	r21, 0x00	; 0
   a:	60 e0       	ldi	r22, 0x00	; 0
   c:	70 e0       	ldi	r23, 0x00	; 0
   e:	0e 94 00 00 	call	0	; 0x0 <MessageQueue_Init>
	DoubleLinkList_Init( &(pstMsgQ_->m_clLinkList) );  
  12:	1c 86       	std	Y+12, r1	; 0x0c
  14:	1b 86       	std	Y+11, r1	; 0x0b
  16:	1e 86       	std	Y+14, r1	; 0x0e
  18:	1d 86       	std	Y+13, r1	; 0x0d
}
  1a:	df 91       	pop	r29
  1c:	cf 91       	pop	r28
  1e:	08 95       	ret

Disassembly of section .text.MessageQueue_Receive:

00000000 <MessageQueue_Receive>:

//---------------------------------------------------------------------------
Message_t *MessageQueue_Receive( MessageQueue_t *pstMsgQ_ )
{
#if KERNEL_USE_TIMEOUTS
    return MessageQueue_Receive_i( pstMsgQ_, 0 );
   0:	40 e0       	ldi	r20, 0x00	; 0
   2:	50 e0       	ldi	r21, 0x00	; 0
   4:	ba 01       	movw	r22, r20
   6:	0c 94 00 00 	jmp	0	; 0x0 <MessageQueue_Receive>

Disassembly of section .text.MessageQueue_TimedReceive:

00000000 <MessageQueue_TimedReceive>:

//---------------------------------------------------------------------------
#if KERNEL_USE_TIMEOUTS
Message_t *MessageQueue_TimedReceive( MessageQueue_t *pstMsgQ_, K_ULONG ulTimeWaitMS_)
{
    return MessageQueue_Receive_i( pstMsgQ_, ulTimeWaitMS_ );
   0:	0c 94 00 00 	jmp	0	; 0x0 <MessageQueue_TimedReceive>

Disassembly of section .text.MessageQueue_Send:

00000000 <MessageQueue_Send>:
	return pstRet;	
}

//---------------------------------------------------------------------------
void MessageQueue_Send( MessageQueue_t *pstMsgQ_, Message_t *pstSrc_ )
{
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17
   4:	cf 93       	push	r28
   6:	df 93       	push	r29
   8:	1f 92       	push	r1
   a:	cd b7       	in	r28, 0x3d	; 61
   c:	de b7       	in	r29, 0x3e	; 62
   e:	8c 01       	movw	r16, r24
	KERNEL_ASSERT( pstSrc_ );
	
	CS_ENTER();
  10:	8f b7       	in	r24, 0x3f	; 63
  12:	89 83       	std	Y+1, r24	; 0x01
  14:	f8 94       	cli
	
	// Add the message to the head of the linked list
	DoubleLinkList_Add( (DoubleLinkList_t*)&(pstMsgQ_->m_clLinkList), (LinkListNode_t*)pstSrc_ );
  16:	c8 01       	movw	r24, r16
  18:	0b 96       	adiw	r24, 0x0b	; 11
  1a:	0e 94 00 00 	call	0	; 0x0 <MessageQueue_Send>
		
	// Post the Semaphore_t, waking the blocking thread for the queue.
	Semaphore_Post( &(pstMsgQ_->m_clSemaphore) );
  1e:	c8 01       	movw	r24, r16
  20:	0e 94 00 00 	call	0	; 0x0 <MessageQueue_Send>
	
	CS_EXIT();
  24:	89 81       	ldd	r24, Y+1	; 0x01
  26:	8f bf       	out	0x3f, r24	; 63
}
  28:	0f 90       	pop	r0
  2a:	df 91       	pop	r29
  2c:	cf 91       	pop	r28
  2e:	1f 91       	pop	r17
  30:	0f 91       	pop	r16
  32:	08 95       	ret

Disassembly of section .text.MessageQueue_GetCount:

00000000 <MessageQueue_GetCount>:

//---------------------------------------------------------------------------
K_USHORT MessageQueue_GetCount( MessageQueue_t *pstMsgQ_ )
{
	return Semaphore_GetCount( &(pstMsgQ_->m_clSemaphore) );
   0:	0c 94 00 00 	jmp	0	; 0x0 <MessageQueue_GetCount>

mutex.c.o:     file format elf32-avr


Disassembly of section .text.TimedMutex_Calback:

00000000 <TimedMutex_Calback>:
 *
 * \param pstOwner_ Pointer to the thread to wake
 * \param pvData_   Pointer to the Mutex_t object that the thread is blocked on
 */
void TimedMutex_Calback(Thread_t *pstOwner_, void *pvData_)
{
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	ec 01       	movw	r28, r24
	Mutex_t *pstMutex = (Mutex_t*)(pvData_);
		
	// Indicate that the Semaphore_t has expired on the thread
	Thread_SetExpired( pstOwner_, true );
   6:	81 e0       	ldi	r24, 0x01	; 1
   8:	8a ab       	std	Y+50, r24	; 0x32

//---------------------------------------------------------------------------
void Mutex_WakeMe( Mutex_t *pstMutex_, Thread_t *pstOwner_ )
{
	// Remove from the Semaphore_t waitlist and back to its ready list.
	BlockingObject_UnBlock(pstOwner_);
   a:	ce 01       	movw	r24, r28
   c:	0e 94 00 00 	call	0	; 0x0 <TimedMutex_Calback>
		
	// Wake up the thread that was blocked on this Semaphore_t.
	Mutex_WakeMe( pstMutex, pstOwner_ );
		
	if ( Thread_GetCurPriority( pstOwner_ ) >=
 		 Thread_GetCurPriority( Scheduler_GetCurrentThread() ) )
  10:	e0 91 00 00 	lds	r30, 0x0000
  14:	f0 91 00 00 	lds	r31, 0x0000
	Thread_SetExpired( pstOwner_, true );
		
	// Wake up the thread that was blocked on this Semaphore_t.
	Mutex_WakeMe( pstMutex, pstOwner_ );
		
	if ( Thread_GetCurPriority( pstOwner_ ) >=
  18:	9a 85       	ldd	r25, Y+10	; 0x0a
  1a:	82 85       	ldd	r24, Z+10	; 0x0a
  1c:	98 17       	cp	r25, r24
  1e:	00 f0       	brcs	.+0      	; 0x20 <TimedMutex_Calback+0x20>
 		 Thread_GetCurPriority( Scheduler_GetCurrentThread() ) )
	{
 		Thread_Yield();
	}
}
  20:	df 91       	pop	r29
  22:	cf 91       	pop	r28
	Mutex_WakeMe( pstMutex, pstOwner_ );
		
	if ( Thread_GetCurPriority( pstOwner_ ) >=
 		 Thread_GetCurPriority( Scheduler_GetCurrentThread() ) )
	{
 		Thread_Yield();
  24:	0c 94 00 00 	jmp	0	; 0x0 <TimedMutex_Calback>
	}
}
  28:	df 91       	pop	r29
  2a:	cf 91       	pop	r28
  2c:	08 95       	ret

Disassembly of section .text.Mutex_Claim_i:

00000000 <Mutex_Claim_i>:
#if KERNEL_USE_TIMEOUTS
K_BOOL Mutex_Claim_i( Mutex_t *pstMutex_, K_ULONG ulWaitTimeMS_)
#else
void Mutex_Claim_i( Mutex_t *pstMutex_ )
#endif
{
   0:	cf 92       	push	r12
   2:	df 92       	push	r13
   4:	ef 92       	push	r14
   6:	ff 92       	push	r15
   8:	0f 93       	push	r16
   a:	1f 93       	push	r17
   c:	cf 93       	push	r28
   e:	df 93       	push	r29
  10:	cd b7       	in	r28, 0x3d	; 61
  12:	de b7       	in	r29, 0x3e	; 62
  14:	6b 97       	sbiw	r28, 0x1b	; 27
  16:	0f b6       	in	r0, 0x3f	; 63
  18:	f8 94       	cli
  1a:	de bf       	out	0x3e, r29	; 62
  1c:	0f be       	out	0x3f, r0	; 63
  1e:	cd bf       	out	0x3d, r28	; 61
  20:	6c 01       	movw	r12, r24
#endif

    // Disable the scheduler while claiming the Mutex_t - we're dealing with all
    // sorts of private thread data, can't have a thread switch while messing
    // with internal data structures.
    Scheduler_SetScheduler( false );
  22:	80 e0       	ldi	r24, 0x00	; 0
  24:	48 8f       	std	Y+24, r20	; 0x18
  26:	59 8f       	std	Y+25, r21	; 0x19
  28:	6a 8f       	std	Y+26, r22	; 0x1a
  2a:	7b 8f       	std	Y+27, r23	; 0x1b
  2c:	0e 94 00 00 	call	0	; 0x0 <Mutex_Claim_i>

    // Check to see if the Mutex_t is claimed or not
    if (pstMutex_->m_bReady != 0)
  30:	d6 01       	movw	r26, r12
  32:	18 96       	adiw	r26, 0x08	; 8
  34:	8c 91       	ld	r24, X
  36:	18 97       	sbiw	r26, 0x08	; 8
  38:	e0 91 00 00 	lds	r30, 0x0000
  3c:	f0 91 00 00 	lds	r31, 0x0000
  40:	48 8d       	ldd	r20, Y+24	; 0x18
  42:	59 8d       	ldd	r21, Y+25	; 0x19
  44:	6a 8d       	ldd	r22, Y+26	; 0x1a
  46:	7b 8d       	ldd	r23, Y+27	; 0x1b
  48:	88 23       	and	r24, r24
  4a:	01 f0       	breq	.+0      	; 0x4c <Mutex_Claim_i+0x4c>
    {
        // Mutex_t isn't claimed, claim it.
        pstMutex_->m_bReady = 0;
  4c:	18 96       	adiw	r26, 0x08	; 8
  4e:	1c 92       	st	X, r1
  50:	18 97       	sbiw	r26, 0x08	; 8
        pstMutex_->m_ucRecurse = 0;
  52:	17 96       	adiw	r26, 0x07	; 7
  54:	1c 92       	st	X, r1
  56:	17 97       	sbiw	r26, 0x07	; 7
        pstMutex_->m_ucMaxPri = Thread_GetPriority( g_pstCurrent );
  58:	81 85       	ldd	r24, Z+9	; 0x09
  5a:	19 96       	adiw	r26, 0x09	; 9
  5c:	8c 93       	st	X, r24
  5e:	19 97       	sbiw	r26, 0x09	; 9
        pstMutex_->m_pstOwner = g_pstCurrent;
  60:	1b 96       	adiw	r26, 0x0b	; 11
  62:	fc 93       	st	X, r31
  64:	ee 93       	st	-X, r30
  66:	1a 97       	sbiw	r26, 0x0a	; 10
  68:	00 c0       	rjmp	.+0      	; 0x6a <Mutex_Claim_i+0x6a>
#endif
    }

    // If the Mutex_t is already claimed, check to see if this is the owner thread,
    // since we allow the Mutex_t to be claimed recursively.
    if (g_pstCurrent == pstMutex_->m_pstOwner)
  6a:	d6 01       	movw	r26, r12
  6c:	1a 96       	adiw	r26, 0x0a	; 10
  6e:	8d 91       	ld	r24, X+
  70:	9c 91       	ld	r25, X
  72:	1b 97       	sbiw	r26, 0x0b	; 11
  74:	e8 17       	cp	r30, r24
  76:	f9 07       	cpc	r31, r25
  78:	01 f4       	brne	.+0      	; 0x7a <Mutex_Claim_i+0x7a>
    {
        // Ensure that we haven't exceeded the maximum recursive-lock count
        KERNEL_ASSERT( (pstMutex_->m_ucRecurse < 255) );
        pstMutex_->m_ucRecurse++;
  7a:	17 96       	adiw	r26, 0x07	; 7
  7c:	8c 91       	ld	r24, X
  7e:	17 97       	sbiw	r26, 0x07	; 7
  80:	8f 5f       	subi	r24, 0xFF	; 255
  82:	17 96       	adiw	r26, 0x07	; 7
  84:	8c 93       	st	X, r24

        // Increment the lock count and bail
        Scheduler_SetScheduler( true );
  86:	81 e0       	ldi	r24, 0x01	; 1
  88:	0e 94 00 00 	call	0	; 0x0 <Mutex_Claim_i>
  8c:	00 c0       	rjmp	.+0      	; 0x8e <Mutex_Claim_i+0x8e>
    }

    // The Mutex_t is claimed already - we have to block now.  Move the
    // current thread to the list of threads waiting on the Mutex_t.
#if KERNEL_USE_TIMEOUTS
    if (ulWaitTimeMS_)
  8e:	41 15       	cp	r20, r1
  90:	51 05       	cpc	r21, r1
  92:	61 05       	cpc	r22, r1
  94:	71 05       	cpc	r23, r1
  96:	01 f0       	breq	.+0      	; 0x98 <Mutex_Claim_i+0x98>
    {
		Thread_SetExpired( g_pstCurrent, false );
  98:	12 aa       	std	Z+50, r1	; 0x32
        
		Timer_Init( &clTimer );
  9a:	ce 01       	movw	r24, r28
  9c:	01 96       	adiw	r24, 0x01	; 1
  9e:	48 8f       	std	Y+24, r20	; 0x18
  a0:	59 8f       	std	Y+25, r21	; 0x19
  a2:	6a 8f       	std	Y+26, r22	; 0x1a
  a4:	7b 8f       	std	Y+27, r23	; 0x1b
  a6:	0e 94 00 00 	call	0	; 0x0 <Mutex_Claim_i>
		Timer_Start( &clTimer, false, ulWaitTimeMS_, (TimerCallback_t)TimedMutex_Calback, (void*)pstMutex_);
  aa:	76 01       	movw	r14, r12
  ac:	00 e0       	ldi	r16, 0x00	; 0
  ae:	10 e0       	ldi	r17, 0x00	; 0
  b0:	48 8d       	ldd	r20, Y+24	; 0x18
  b2:	59 8d       	ldd	r21, Y+25	; 0x19
  b4:	6a 8d       	ldd	r22, Y+26	; 0x1a
  b6:	7b 8d       	ldd	r23, Y+27	; 0x1b
  b8:	9a 01       	movw	r18, r20
  ba:	ab 01       	movw	r20, r22
  bc:	60 e0       	ldi	r22, 0x00	; 0
  be:	ce 01       	movw	r24, r28
  c0:	01 96       	adiw	r24, 0x01	; 1
  c2:	0e 94 00 00 	call	0	; 0x0 <Mutex_Claim_i>
        bUseTimer = true;
  c6:	ff 24       	eor	r15, r15
  c8:	f3 94       	inc	r15
  ca:	00 c0       	rjmp	.+0      	; 0xcc <Mutex_Claim_i+0xcc>
{
    KERNEL_TRACE_1( STR_MUTEX_CLAIM_1, (K_USHORT)Thread_GetID( g_pstCurrent ) );

#if KERNEL_USE_TIMEOUTS
    Timer_t clTimer;
    K_BOOL bUseTimer = false;
  cc:	f1 2c       	mov	r15, r1
		Timer_Init( &clTimer );
		Timer_Start( &clTimer, false, ulWaitTimeMS_, (TimerCallback_t)TimedMutex_Calback, (void*)pstMutex_);
        bUseTimer = true;
    }
#endif
    BlockingObject_Block( (ThreadList_t*)pstMutex_, g_pstCurrent );
  ce:	60 91 00 00 	lds	r22, 0x0000
  d2:	70 91 00 00 	lds	r23, 0x0000
  d6:	c6 01       	movw	r24, r12
  d8:	0e 94 00 00 	call	0	; 0x0 <Mutex_Claim_i>

    // Check if priority inheritence is necessary.  We do this in order
    // to ensure that we don't end up with priority inversions in case
    // multiple threads are waiting on the same resource.
    if(pstMutex_->m_ucMaxPri <= Thread_GetPriority( g_pstCurrent ) )
  dc:	e0 91 00 00 	lds	r30, 0x0000
  e0:	f0 91 00 00 	lds	r31, 0x0000
  e4:	81 85       	ldd	r24, Z+9	; 0x09
  e6:	f6 01       	movw	r30, r12
  e8:	91 85       	ldd	r25, Z+9	; 0x09
  ea:	89 17       	cp	r24, r25
  ec:	00 f0       	brcs	.+0      	; 0xee <Mutex_Claim_i+0xee>
    {
        pstMutex_->m_ucMaxPri = Thread_GetPriority( g_pstCurrent );
  ee:	81 87       	std	Z+9, r24	; 0x09
			Thread_InheritPriority( pstTemp, pstMutex_->m_ucMaxPri );            
			if(pstTemp == (Thread_t*)(LinkList_GetTail( (LinkList_t*)pstMutex_ )) )
            {
                break;
            }
            pstTemp = (Thread_t*)LinkListNode_GetNext( (LinkListNode_t*)pstTemp );
  f0:	00 81       	ld	r16, Z
  f2:	11 81       	ldd	r17, Z+1	; 0x01
    if(pstMutex_->m_ucMaxPri <= Thread_GetPriority( g_pstCurrent ) )
    {
        pstMutex_->m_ucMaxPri = Thread_GetPriority( g_pstCurrent );

        Thread_t *pstTemp = (Thread_t*)(LinkList_GetHead( (LinkList_t*)pstMutex_ ));
        while(pstTemp)
  f4:	01 15       	cp	r16, r1
  f6:	11 05       	cpc	r17, r1
  f8:	01 f0       	breq	.+0      	; 0xfa <Mutex_Claim_i+0xfa>
        {
			Thread_InheritPriority( pstTemp, pstMutex_->m_ucMaxPri );            
  fa:	d6 01       	movw	r26, r12
  fc:	19 96       	adiw	r26, 0x09	; 9
  fe:	6c 91       	ld	r22, X
 100:	c8 01       	movw	r24, r16
 102:	0e 94 00 00 	call	0	; 0x0 <Mutex_Claim_i>
			if(pstTemp == (Thread_t*)(LinkList_GetTail( (LinkList_t*)pstMutex_ )) )
 106:	f6 01       	movw	r30, r12
 108:	82 81       	ldd	r24, Z+2	; 0x02
 10a:	93 81       	ldd	r25, Z+3	; 0x03
 10c:	08 17       	cp	r16, r24
 10e:	19 07       	cpc	r17, r25
 110:	01 f4       	brne	.+0      	; 0x112 <Mutex_Claim_i+0x112>
            {
                break;
            }
            pstTemp = (Thread_t*)LinkListNode_GetNext( (LinkListNode_t*)pstTemp );
        }
		Thread_InheritPriority( pstMutex_->m_pstOwner, pstMutex_->m_ucMaxPri );        
 112:	d6 01       	movw	r26, r12
 114:	19 96       	adiw	r26, 0x09	; 9
 116:	6c 91       	ld	r22, X
 118:	19 97       	sbiw	r26, 0x09	; 9
 11a:	1a 96       	adiw	r26, 0x0a	; 10
 11c:	8d 91       	ld	r24, X+
 11e:	9c 91       	ld	r25, X
 120:	1b 97       	sbiw	r26, 0x0b	; 11
 122:	0e 94 00 00 	call	0	; 0x0 <Mutex_Claim_i>
 126:	00 c0       	rjmp	.+0      	; 0x128 <Mutex_Claim_i+0x128>
			Thread_InheritPriority( pstTemp, pstMutex_->m_ucMaxPri );            
			if(pstTemp == (Thread_t*)(LinkList_GetTail( (LinkList_t*)pstMutex_ )) )
            {
                break;
            }
            pstTemp = (Thread_t*)LinkListNode_GetNext( (LinkListNode_t*)pstTemp );
 128:	f8 01       	movw	r30, r16
 12a:	00 c0       	rjmp	.+0      	; 0x12c <Mutex_Claim_i+0x12c>
        }
		Thread_InheritPriority( pstMutex_->m_pstOwner, pstMutex_->m_ucMaxPri );        
    }

    // Done with thread data -reenable the scheduler
    Scheduler_SetScheduler( true );
 12c:	81 e0       	ldi	r24, 0x01	; 1
 12e:	0e 94 00 00 	call	0	; 0x0 <Mutex_Claim_i>

    // Switch threads if this thread acquired the Mutex_t
    Thread_Yield();
 132:	0e 94 00 00 	call	0	; 0x0 <Mutex_Claim_i>

#if KERNEL_USE_TIMEOUTS
    if (bUseTimer)
 136:	ff 20       	and	r15, r15
 138:	01 f0       	breq	.+0      	; 0x13a <Mutex_Claim_i+0x13a>
    {
		Timer_Stop( &clTimer );        
 13a:	ce 01       	movw	r24, r28
 13c:	01 96       	adiw	r24, 0x01	; 1
 13e:	0e 94 00 00 	call	0	; 0x0 <Mutex_Claim_i>
        return ( Thread_GetExpired( g_pstCurrent ) == 0);
 142:	e0 91 00 00 	lds	r30, 0x0000
 146:	f0 91 00 00 	lds	r31, 0x0000
 14a:	82 a9       	ldd	r24, Z+50	; 0x32
 14c:	91 e0       	ldi	r25, 0x01	; 1
 14e:	89 27       	eor	r24, r25
 150:	00 c0       	rjmp	.+0      	; 0x152 <Mutex_Claim_i+0x152>
    }
    return true;
 152:	81 e0       	ldi	r24, 0x01	; 1
#endif
}
 154:	6b 96       	adiw	r28, 0x1b	; 27
 156:	0f b6       	in	r0, 0x3f	; 63
 158:	f8 94       	cli
 15a:	de bf       	out	0x3e, r29	; 62
 15c:	0f be       	out	0x3f, r0	; 63
 15e:	cd bf       	out	0x3d, r28	; 61
 160:	df 91       	pop	r29
 162:	cf 91       	pop	r28
 164:	1f 91       	pop	r17
 166:	0f 91       	pop	r16
 168:	ff 90       	pop	r15
 16a:	ef 90       	pop	r14
 16c:	df 90       	pop	r13
 16e:	cf 90       	pop	r12
 170:	08 95       	ret

Disassembly of section .text.Mutex_Init:

00000000 <Mutex_Init>:
    return 0;
}

//---------------------------------------------------------------------------
void Mutex_Init( Mutex_t *pstMutex_ )
{
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	ec 01       	movw	r28, r24
	ThreadList_Init( (ThreadList_t*)pstMutex_ );
   6:	0e 94 00 00 	call	0	; 0x0 <Mutex_Init>
	
    // Reset the data in the Mutex_t
    pstMutex_->m_bReady = 1;             // The Mutex_t is free.
   a:	81 e0       	ldi	r24, 0x01	; 1
   c:	88 87       	std	Y+8, r24	; 0x08
    pstMutex_->m_ucMaxPri = 0;           // Set the maximum priority inheritence state
   e:	19 86       	std	Y+9, r1	; 0x09
    pstMutex_->m_pstOwner = NULL;        // Clear the Mutex_t owner
  10:	1b 86       	std	Y+11, r1	; 0x0b
  12:	1a 86       	std	Y+10, r1	; 0x0a
    pstMutex_->m_ucRecurse = 0;          // Reset recurse count
  14:	1f 82       	std	Y+7, r1	; 0x07
}
  16:	df 91       	pop	r29
  18:	cf 91       	pop	r28
  1a:	08 95       	ret

Disassembly of section .text.Mutex_Claim:

00000000 <Mutex_Claim>:

//---------------------------------------------------------------------------
void Mutex_Claim( Mutex_t *pstMutex_ )
{
#if KERNEL_USE_TIMEOUTS
    Mutex_Claim_i( pstMutex_ , 0 );
   0:	40 e0       	ldi	r20, 0x00	; 0
   2:	50 e0       	ldi	r21, 0x00	; 0
   4:	ba 01       	movw	r22, r20
   6:	0c 94 00 00 	jmp	0	; 0x0 <Mutex_Claim>

Disassembly of section .text.Mutex_TimedClaim:

00000000 <Mutex_TimedClaim>:

//---------------------------------------------------------------------------
#if KERNEL_USE_TIMEOUTS
K_BOOL Mutex_TimedClaim( Mutex_t *pstMutex_, K_ULONG ulWaitTimeMS_ )
{
    return Mutex_Claim_i( pstMutex_ , ulWaitTimeMS_ );        
   0:	0c 94 00 00 	jmp	0	; 0x0 <Mutex_TimedClaim>

Disassembly of section .text.Mutex_Release:

00000000 <Mutex_Release>:
}
#endif

//---------------------------------------------------------------------------
void Mutex_Release( Mutex_t *pstMutex_ )
{
   0:	ff 92       	push	r15
   2:	0f 93       	push	r16
   4:	1f 93       	push	r17
   6:	cf 93       	push	r28
   8:	df 93       	push	r29
   a:	ec 01       	movw	r28, r24
	KERNEL_TRACE_1( STR_MUTEX_RELEASE_1, (K_USHORT)Thread_GetID( g_pstCurrent ) );

    K_BOOL bSchedule = 0;

    // Disable the scheduler while we deal with internal data structures.
    Scheduler_SetScheduler( false );
   c:	80 e0       	ldi	r24, 0x00	; 0
   e:	0e 94 00 00 	call	0	; 0x0 <Mutex_Release>
    // This thread had better be the one that owns the Mutex_t currently...
    KERNEL_ASSERT( (g_pstCurrent == pstMutex_->m_pstOwner) );

    // If the owner had claimed the lock multiple times, decrease the lock
    // count and return immediately.
    if (pstMutex_->m_ucRecurse)
  12:	8f 81       	ldd	r24, Y+7	; 0x07
  14:	88 23       	and	r24, r24
  16:	01 f0       	breq	.+0      	; 0x18 <Mutex_Release+0x18>
    {
        pstMutex_->m_ucRecurse--;
  18:	81 50       	subi	r24, 0x01	; 1
  1a:	8f 83       	std	Y+7, r24	; 0x07
        Scheduler_SetScheduler( true );
  1c:	81 e0       	ldi	r24, 0x01	; 1
    if(bSchedule)
    {
        // Switch threads if a higher-priority thread was woken
        Thread_Yield();
    }
}
  1e:	df 91       	pop	r29
  20:	cf 91       	pop	r28
  22:	1f 91       	pop	r17
  24:	0f 91       	pop	r16
  26:	ff 90       	pop	r15
    // If the owner had claimed the lock multiple times, decrease the lock
    // count and return immediately.
    if (pstMutex_->m_ucRecurse)
    {
        pstMutex_->m_ucRecurse--;
        Scheduler_SetScheduler( true );
  28:	0c 94 00 00 	jmp	0	; 0x0 <Mutex_Release>
        return;
    }

    // Restore the thread's original priority
    if (Thread_GetCurPriority( g_pstCurrent ) != Thread_GetPriority( g_pstCurrent ))
  2c:	80 91 00 00 	lds	r24, 0x0000
  30:	90 91 00 00 	lds	r25, 0x0000
  34:	dc 01       	movw	r26, r24
  36:	19 96       	adiw	r26, 0x09	; 9
  38:	6c 91       	ld	r22, X
  3a:	19 97       	sbiw	r26, 0x09	; 9
  3c:	1a 96       	adiw	r26, 0x0a	; 10
  3e:	2c 91       	ld	r18, X
  40:	26 17       	cp	r18, r22
  42:	01 f0       	breq	.+0      	; 0x44 <Mutex_Release+0x44>
    {
        Thread_SetPriority( g_pstCurrent, Thread_GetPriority(g_pstCurrent) );
  44:	0e 94 00 00 	call	0	; 0x0 <Mutex_Release>
        // In this case, we want to reschedule
        bSchedule = 1;
  48:	ff 24       	eor	r15, r15
  4a:	f3 94       	inc	r15
  4c:	00 c0       	rjmp	.+0      	; 0x4e <Mutex_Release+0x4e>
//---------------------------------------------------------------------------
void Mutex_Release( Mutex_t *pstMutex_ )
{
	KERNEL_TRACE_1( STR_MUTEX_RELEASE_1, (K_USHORT)Thread_GetID( g_pstCurrent ) );

    K_BOOL bSchedule = 0;
  4e:	f1 2c       	mov	r15, r1
        // In this case, we want to reschedule
        bSchedule = 1;
    }

    // No threads are waiting on this Mutex_t?
    if ( LinkList_GetHead( (LinkList_t*)pstMutex_ ) == NULL)
  50:	88 81       	ld	r24, Y
  52:	99 81       	ldd	r25, Y+1	; 0x01
  54:	89 2b       	or	r24, r25
  56:	01 f4       	brne	.+0      	; 0x58 <Mutex_Release+0x58>
    {
        // Re-initialize the Mutex_t to its default values
        pstMutex_->m_bReady = 1;
  58:	81 e0       	ldi	r24, 0x01	; 1
  5a:	88 87       	std	Y+8, r24	; 0x08
        pstMutex_->m_ucMaxPri = 0;
  5c:	19 86       	std	Y+9, r1	; 0x09
        pstMutex_->m_pstOwner = NULL;
  5e:	1b 86       	std	Y+11, r1	; 0x0b
  60:	1a 86       	std	Y+10, r1	; 0x0a
  62:	00 c0       	rjmp	.+0      	; 0x64 <Mutex_Release+0x64>
K_UCHAR Mutex_WakeNext( Mutex_t *pstMutex_ )
{
    Thread_t *pstChosenOne = NULL;

    // Get the highest priority waiter thread
    pstChosenOne = ThreadList_HighestWaiter( (ThreadList_t*)pstMutex_ );
  64:	ce 01       	movw	r24, r28
  66:	0e 94 00 00 	call	0	; 0x0 <Mutex_Release>
  6a:	8c 01       	movw	r16, r24
    
    // Unblock the thread
    BlockingObject_UnBlock(pstChosenOne);
  6c:	0e 94 00 00 	call	0	; 0x0 <Mutex_Release>
    
    // The chosen one now owns the Mutex_t
    pstMutex_->m_pstOwner = pstChosenOne;
  70:	1b 87       	std	Y+11, r17	; 0x0b
  72:	0a 87       	std	Y+10, r16	; 0x0a

    // Signal a context switch if it's a greater than or equal to the current priority
    if ( Thread_GetCurPriority(pstChosenOne) >= 
		 Thread_GetCurPriority( Scheduler_GetCurrentThread() ) )		
  74:	e0 91 00 00 	lds	r30, 0x0000
  78:	f0 91 00 00 	lds	r31, 0x0000
    
    // The chosen one now owns the Mutex_t
    pstMutex_->m_pstOwner = pstChosenOne;

    // Signal a context switch if it's a greater than or equal to the current priority
    if ( Thread_GetCurPriority(pstChosenOne) >= 
  7c:	d8 01       	movw	r26, r16
  7e:	1a 96       	adiw	r26, 0x0a	; 10
  80:	9c 91       	ld	r25, X
  82:	82 85       	ldd	r24, Z+10	; 0x0a
  84:	98 17       	cp	r25, r24
  86:	00 f0       	brcs	.+0      	; 0x88 <Mutex_Release+0x88>
    {
        // Wake the highest priority Thread_t pending on the Mutex_t
        if( Mutex_WakeNext( pstMutex_ ) )
        {
            // Switch threads if it's higher or equal priority than the current thread
            bSchedule = 1;
  88:	ff 24       	eor	r15, r15
  8a:	f3 94       	inc	r15
        }
    }

    // Must enable the scheduler again in order to switch threads.
    Scheduler_SetScheduler( true );
  8c:	81 e0       	ldi	r24, 0x01	; 1
  8e:	0e 94 00 00 	call	0	; 0x0 <Mutex_Release>
    if(bSchedule)
  92:	ff 20       	and	r15, r15
  94:	01 f0       	breq	.+0      	; 0x96 <Mutex_Release+0x96>
    {
        // Switch threads if a higher-priority thread was woken
        Thread_Yield();
    }
}
  96:	df 91       	pop	r29
  98:	cf 91       	pop	r28
  9a:	1f 91       	pop	r17
  9c:	0f 91       	pop	r16
  9e:	ff 90       	pop	r15
    // Must enable the scheduler again in order to switch threads.
    Scheduler_SetScheduler( true );
    if(bSchedule)
    {
        // Switch threads if a higher-priority thread was woken
        Thread_Yield();
  a0:	0c 94 00 00 	jmp	0	; 0x0 <Mutex_Release>
    }
}
  a4:	df 91       	pop	r29
  a6:	cf 91       	pop	r28
  a8:	1f 91       	pop	r17
  aa:	0f 91       	pop	r16
  ac:	ff 90       	pop	r15
  ae:	08 95       	ret

profile.c.o:     file format elf32-avr


Disassembly of section .text.ProfileTimer_Init:

00000000 <ProfileTimer_Init>:

#if KERNEL_USE_PROFILER

//---------------------------------------------------------------------------
void ProfileTimer_Init( ProfileTimer_t *pstTimer_ )
{
   0:	fc 01       	movw	r30, r24
    pstTimer_->m_ulCumulative = 0;
   2:	10 82       	st	Z, r1
   4:	11 82       	std	Z+1, r1	; 0x01
   6:	12 82       	std	Z+2, r1	; 0x02
   8:	13 82       	std	Z+3, r1	; 0x03
    pstTimer_->m_ulCurrentIteration = 0;
   a:	14 82       	std	Z+4, r1	; 0x04
   c:	15 82       	std	Z+5, r1	; 0x05
   e:	16 82       	std	Z+6, r1	; 0x06
  10:	17 82       	std	Z+7, r1	; 0x07
    pstTimer_->m_usIterations = 0;
  12:	17 86       	std	Z+15, r1	; 0x0f
  14:	16 86       	std	Z+14, r1	; 0x0e
    pstTimer_->m_bActive = 0;
  16:	10 8a       	std	Z+16, r1	; 0x10
  18:	08 95       	ret

Disassembly of section .text.ProfileTimer_Start:

00000000 <ProfileTimer_Start>:
}

//---------------------------------------------------------------------------    
void ProfileTimer_Start( ProfileTimer_t *pstTimer_ )
{
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17
   4:	cf 93       	push	r28
   6:	df 93       	push	r29
   8:	1f 92       	push	r1
   a:	cd b7       	in	r28, 0x3d	; 61
   c:	de b7       	in	r29, 0x3e	; 62
   e:	8c 01       	movw	r16, r24
    if (!pstTimer_->m_bActive)
  10:	fc 01       	movw	r30, r24
  12:	80 89       	ldd	r24, Z+16	; 0x10
  14:	81 11       	cpse	r24, r1
  16:	00 c0       	rjmp	.+0      	; 0x18 <ProfileTimer_Start+0x18>
    {
        CS_ENTER();
  18:	8f b7       	in	r24, 0x3f	; 63
  1a:	89 83       	std	Y+1, r24	; 0x01
  1c:	f8 94       	cli
        pstTimer_->m_ulCurrentIteration = 0;
  1e:	f8 01       	movw	r30, r16
  20:	14 82       	std	Z+4, r1	; 0x04
  22:	15 82       	std	Z+5, r1	; 0x05
  24:	16 82       	std	Z+6, r1	; 0x06
  26:	17 82       	std	Z+7, r1	; 0x07
        pstTimer_->m_ulInitialEpoch = Profiler_GetEpoch();
  28:	0e 94 00 00 	call	0	; 0x0 <ProfileTimer_Start>
  2c:	f8 01       	movw	r30, r16
  2e:	62 87       	std	Z+10, r22	; 0x0a
  30:	73 87       	std	Z+11, r23	; 0x0b
  32:	84 87       	std	Z+12, r24	; 0x0c
  34:	95 87       	std	Z+13, r25	; 0x0d
        pstTimer_->m_usInitial = Profiler_Read();
  36:	0e 94 00 00 	call	0	; 0x0 <ProfileTimer_Start>
  3a:	f8 01       	movw	r30, r16
  3c:	91 87       	std	Z+9, r25	; 0x09
  3e:	80 87       	std	Z+8, r24	; 0x08
        CS_EXIT();
  40:	89 81       	ldd	r24, Y+1	; 0x01
  42:	8f bf       	out	0x3f, r24	; 63
        pstTimer_->m_bActive = 1;
  44:	81 e0       	ldi	r24, 0x01	; 1
  46:	80 8b       	std	Z+16, r24	; 0x10
    }
}
  48:	0f 90       	pop	r0
  4a:	df 91       	pop	r29
  4c:	cf 91       	pop	r28
  4e:	1f 91       	pop	r17
  50:	0f 91       	pop	r16
  52:	08 95       	ret

Disassembly of section .text.ProfileTimer_GetAverage:

00000000 <ProfileTimer_GetAverage>:
}

//---------------------------------------------------------------------------    
K_ULONG ProfileTimer_GetAverage( ProfileTimer_t *pstTimer_ )
{
    if (pstTimer_->m_usIterations)
   0:	fc 01       	movw	r30, r24
   2:	26 85       	ldd	r18, Z+14	; 0x0e
   4:	37 85       	ldd	r19, Z+15	; 0x0f
   6:	21 15       	cp	r18, r1
   8:	31 05       	cpc	r19, r1
   a:	01 f0       	breq	.+0      	; 0xc <ProfileTimer_GetAverage+0xc>
    {
        return pstTimer_->m_ulCumulative / (K_ULONG)pstTimer_->m_usIterations;
   c:	40 e0       	ldi	r20, 0x00	; 0
   e:	50 e0       	ldi	r21, 0x00	; 0
  10:	60 81       	ld	r22, Z
  12:	71 81       	ldd	r23, Z+1	; 0x01
  14:	82 81       	ldd	r24, Z+2	; 0x02
  16:	93 81       	ldd	r25, Z+3	; 0x03
  18:	0e 94 00 00 	call	0	; 0x0 <ProfileTimer_GetAverage>
  1c:	00 c0       	rjmp	.+0      	; 0x1e <ProfileTimer_GetAverage+0x1e>
    }
    return 0;
  1e:	20 e0       	ldi	r18, 0x00	; 0
  20:	30 e0       	ldi	r19, 0x00	; 0
  22:	a9 01       	movw	r20, r18
}
  24:	ca 01       	movw	r24, r20
  26:	b9 01       	movw	r22, r18
  28:	08 95       	ret

Disassembly of section .text.ProfileTimer_ComputeCurrentTicks:

00000000 <ProfileTimer_ComputeCurrentTicks>:
    return pstTimer_->m_ulCurrentIteration;
}

//---------------------------------------------------------------------------
K_ULONG ProfileTimer_ComputeCurrentTicks( ProfileTimer_t *pstTimer_, K_USHORT usCurrent_, K_ULONG ulEpoch_)
{    
   0:	cf 92       	push	r12
   2:	df 92       	push	r13
   4:	ef 92       	push	r14
   6:	ff 92       	push	r15
   8:	0f 93       	push	r16
   a:	1f 93       	push	r17
   c:	dc 01       	movw	r26, r24
   e:	fb 01       	movw	r30, r22
    K_ULONG ulTotal;
	K_ULONG ulOverflows;
	
    ulOverflows = ulEpoch_ - pstTimer_->m_ulInitialEpoch;
  10:	1a 96       	adiw	r26, 0x0a	; 10
  12:	cd 90       	ld	r12, X+
  14:	dd 90       	ld	r13, X+
  16:	ed 90       	ld	r14, X+
  18:	fc 90       	ld	r15, X
  1a:	1d 97       	sbiw	r26, 0x0d	; 13
  1c:	2c 19       	sub	r18, r12
  1e:	3d 09       	sbc	r19, r13
  20:	4e 09       	sbc	r20, r14
  22:	5f 09       	sbc	r21, r15
  24:	18 96       	adiw	r26, 0x08	; 8
  26:	8d 91       	ld	r24, X+
  28:	9c 91       	ld	r25, X
  2a:	19 97       	sbiw	r26, 0x09	; 9
	
	// More than one overflow...
	if (ulOverflows > 1)
  2c:	22 30       	cpi	r18, 0x02	; 2
  2e:	31 05       	cpc	r19, r1
  30:	41 05       	cpc	r20, r1
  32:	51 05       	cpc	r21, r1
  34:	00 f0       	brcs	.+0      	; 0x36 <ProfileTimer_ComputeCurrentTicks+0x36>
	{
        ulTotal = ((K_ULONG)(ulOverflows-1) * TICKS_PER_OVERFLOW)
                + (K_ULONG)(TICKS_PER_OVERFLOW - pstTimer_->m_usInitial) +
  36:	60 e0       	ldi	r22, 0x00	; 0
  38:	71 e0       	ldi	r23, 0x01	; 1
  3a:	68 1b       	sub	r22, r24
  3c:	79 0b       	sbc	r23, r25
  3e:	80 e0       	ldi	r24, 0x00	; 0
  40:	90 e0       	ldi	r25, 0x00	; 0
  42:	71 50       	subi	r23, 0x01	; 1
  44:	81 09       	sbc	r24, r1
  46:	91 09       	sbc	r25, r1
  48:	6e 0f       	add	r22, r30
  4a:	7f 1f       	adc	r23, r31
  4c:	81 1d       	adc	r24, r1
  4e:	91 1d       	adc	r25, r1
  50:	00 27       	eor	r16, r16
  52:	12 2f       	mov	r17, r18
  54:	23 2f       	mov	r18, r19
  56:	34 2f       	mov	r19, r20
    ulOverflows = ulEpoch_ - pstTimer_->m_ulInitialEpoch;
	
	// More than one overflow...
	if (ulOverflows > 1)
	{
        ulTotal = ((K_ULONG)(ulOverflows-1) * TICKS_PER_OVERFLOW)
  58:	60 0f       	add	r22, r16
  5a:	71 1f       	adc	r23, r17
  5c:	82 1f       	adc	r24, r18
  5e:	93 1f       	adc	r25, r19
  60:	00 c0       	rjmp	.+0      	; 0x62 <ProfileTimer_ComputeCurrentTicks+0x62>
                + (K_ULONG)(TICKS_PER_OVERFLOW - pstTimer_->m_usInitial) +
				(K_ULONG)usCurrent_;		
	}
	// Only one overflow, or one overflow that has yet to be processed
    else if (ulOverflows || (usCurrent_ < pstTimer_->m_usInitial))
  62:	23 2b       	or	r18, r19
  64:	24 2b       	or	r18, r20
  66:	25 2b       	or	r18, r21
  68:	01 f4       	brne	.+0      	; 0x6a <ProfileTimer_ComputeCurrentTicks+0x6a>
  6a:	68 17       	cp	r22, r24
  6c:	79 07       	cpc	r23, r25
  6e:	00 f4       	brcc	.+0      	; 0x70 <ProfileTimer_ComputeCurrentTicks+0x70>
	{
        ulTotal = (K_ULONG)(TICKS_PER_OVERFLOW - pstTimer_->m_usInitial) +
  70:	60 e0       	ldi	r22, 0x00	; 0
  72:	71 e0       	ldi	r23, 0x01	; 1
  74:	68 1b       	sub	r22, r24
  76:	79 0b       	sbc	r23, r25
  78:	80 e0       	ldi	r24, 0x00	; 0
  7a:	90 e0       	ldi	r25, 0x00	; 0
  7c:	6e 0f       	add	r22, r30
  7e:	7f 1f       	adc	r23, r31
  80:	81 1d       	adc	r24, r1
  82:	91 1d       	adc	r25, r1
  84:	00 c0       	rjmp	.+0      	; 0x86 <ProfileTimer_ComputeCurrentTicks+0x86>
				(K_ULONG)usCurrent_;		
	}
	// No overflows, none pending.
	else
	{
        ulTotal = (K_ULONG)(usCurrent_ - pstTimer_->m_usInitial);
  86:	68 1b       	sub	r22, r24
  88:	79 0b       	sbc	r23, r25
  8a:	80 e0       	ldi	r24, 0x00	; 0
  8c:	90 e0       	ldi	r25, 0x00	; 0
	}

    return ulTotal;
}
  8e:	1f 91       	pop	r17
  90:	0f 91       	pop	r16
  92:	ff 90       	pop	r15
  94:	ef 90       	pop	r14
  96:	df 90       	pop	r13
  98:	cf 90       	pop	r12
  9a:	08 95       	ret

Disassembly of section .text.ProfileTimer_Stop:

00000000 <ProfileTimer_Stop>:
    }
}

//---------------------------------------------------------------------------    
void ProfileTimer_Stop( ProfileTimer_t *pstTimer_ )
{
   0:	cf 92       	push	r12
   2:	df 92       	push	r13
   4:	ef 92       	push	r14
   6:	ff 92       	push	r15
   8:	0f 93       	push	r16
   a:	1f 93       	push	r17
   c:	cf 93       	push	r28
   e:	df 93       	push	r29
  10:	1f 92       	push	r1
  12:	cd b7       	in	r28, 0x3d	; 61
  14:	de b7       	in	r29, 0x3e	; 62
  16:	8c 01       	movw	r16, r24
    if (pstTimer_->m_bActive)
  18:	fc 01       	movw	r30, r24
  1a:	80 89       	ldd	r24, Z+16	; 0x10
  1c:	88 23       	and	r24, r24
  1e:	01 f0       	breq	.+0      	; 0x20 <ProfileTimer_Stop+0x20>
    {
        K_USHORT usFinal;
        K_ULONG ulEpoch;
        CS_ENTER();
  20:	8f b7       	in	r24, 0x3f	; 63
  22:	89 83       	std	Y+1, r24	; 0x01
  24:	f8 94       	cli
        usFinal = Profiler_Read();
  26:	0e 94 00 00 	call	0	; 0x0 <ProfileTimer_Stop>
  2a:	7c 01       	movw	r14, r24
        ulEpoch = Profiler_GetEpoch();
  2c:	0e 94 00 00 	call	0	; 0x0 <ProfileTimer_Stop>
  30:	9b 01       	movw	r18, r22
  32:	ac 01       	movw	r20, r24
        // Compute total for current iteration...
        pstTimer_->m_ulCurrentIteration = ProfileTimer_ComputeCurrentTicks( pstTimer_, usFinal, ulEpoch);
  34:	b7 01       	movw	r22, r14
  36:	c8 01       	movw	r24, r16
  38:	0e 94 00 00 	call	0	; 0x0 <ProfileTimer_Stop>
  3c:	f8 01       	movw	r30, r16
  3e:	64 83       	std	Z+4, r22	; 0x04
  40:	75 83       	std	Z+5, r23	; 0x05
  42:	86 83       	std	Z+6, r24	; 0x06
  44:	97 83       	std	Z+7, r25	; 0x07
        pstTimer_->m_ulCumulative += pstTimer_->m_ulCurrentIteration;
  46:	c0 80       	ld	r12, Z
  48:	d1 80       	ldd	r13, Z+1	; 0x01
  4a:	e2 80       	ldd	r14, Z+2	; 0x02
  4c:	f3 80       	ldd	r15, Z+3	; 0x03
  4e:	c6 0e       	add	r12, r22
  50:	d7 1e       	adc	r13, r23
  52:	e8 1e       	adc	r14, r24
  54:	f9 1e       	adc	r15, r25
  56:	c0 82       	st	Z, r12
  58:	d1 82       	std	Z+1, r13	; 0x01
  5a:	e2 82       	std	Z+2, r14	; 0x02
  5c:	f3 82       	std	Z+3, r15	; 0x03
        pstTimer_->m_usIterations++;
  5e:	86 85       	ldd	r24, Z+14	; 0x0e
  60:	97 85       	ldd	r25, Z+15	; 0x0f
  62:	01 96       	adiw	r24, 0x01	; 1
  64:	97 87       	std	Z+15, r25	; 0x0f
  66:	86 87       	std	Z+14, r24	; 0x0e
        CS_EXIT();
  68:	89 81       	ldd	r24, Y+1	; 0x01
  6a:	8f bf       	out	0x3f, r24	; 63
        pstTimer_->m_bActive = 0;
  6c:	10 8a       	std	Z+16, r1	; 0x10
    }
}
  6e:	0f 90       	pop	r0
  70:	df 91       	pop	r29
  72:	cf 91       	pop	r28
  74:	1f 91       	pop	r17
  76:	0f 91       	pop	r16
  78:	ff 90       	pop	r15
  7a:	ef 90       	pop	r14
  7c:	df 90       	pop	r13
  7e:	cf 90       	pop	r12
  80:	08 95       	ret

Disassembly of section .text.ProfileTimer_GetCurrent:

00000000 <ProfileTimer_GetCurrent>:
    return 0;
}
 
//---------------------------------------------------------------------------     
K_ULONG ProfileTimer_GetCurrent( ProfileTimer_t *pstTimer_ )
{
   0:	ef 92       	push	r14
   2:	ff 92       	push	r15
   4:	0f 93       	push	r16
   6:	1f 93       	push	r17
   8:	cf 93       	push	r28
   a:	df 93       	push	r29
   c:	1f 92       	push	r1
   e:	cd b7       	in	r28, 0x3d	; 61
  10:	de b7       	in	r29, 0x3e	; 62
  12:	8c 01       	movw	r16, r24
    if (pstTimer_->m_bActive)
  14:	fc 01       	movw	r30, r24
  16:	80 89       	ldd	r24, Z+16	; 0x10
  18:	88 23       	and	r24, r24
  1a:	01 f0       	breq	.+0      	; 0x1c <ProfileTimer_GetCurrent+0x1c>
    {
		K_USHORT usCurrent;
		K_ULONG ulEpoch;
		CS_ENTER();
  1c:	8f b7       	in	r24, 0x3f	; 63
  1e:	89 83       	std	Y+1, r24	; 0x01
  20:	f8 94       	cli
        usCurrent = Profiler_Read();
  22:	0e 94 00 00 	call	0	; 0x0 <ProfileTimer_GetCurrent>
  26:	7c 01       	movw	r14, r24
        ulEpoch = Profiler_GetEpoch();
  28:	0e 94 00 00 	call	0	; 0x0 <ProfileTimer_GetCurrent>
  2c:	9b 01       	movw	r18, r22
  2e:	ac 01       	movw	r20, r24
		CS_EXIT();
  30:	89 81       	ldd	r24, Y+1	; 0x01
  32:	8f bf       	out	0x3f, r24	; 63
        return ProfileTimer_ComputeCurrentTicks( pstTimer_, usCurrent, ulEpoch);
  34:	b7 01       	movw	r22, r14
  36:	c8 01       	movw	r24, r16
  38:	0e 94 00 00 	call	0	; 0x0 <ProfileTimer_GetCurrent>
  3c:	00 c0       	rjmp	.+0      	; 0x3e <ProfileTimer_GetCurrent+0x3e>
    }
    return pstTimer_->m_ulCurrentIteration;
  3e:	f8 01       	movw	r30, r16
  40:	64 81       	ldd	r22, Z+4	; 0x04
  42:	75 81       	ldd	r23, Z+5	; 0x05
  44:	86 81       	ldd	r24, Z+6	; 0x06
  46:	97 81       	ldd	r25, Z+7	; 0x07
}
  48:	0f 90       	pop	r0
  4a:	df 91       	pop	r29
  4c:	cf 91       	pop	r28
  4e:	1f 91       	pop	r17
  50:	0f 91       	pop	r16
  52:	ff 90       	pop	r15
  54:	ef 90       	pop	r14
  56:	08 95       	ret

quantum.c.o:     file format elf32-avr


Disassembly of section .text.QuantumCallback:

00000000 <QuantumCallback>:
{
    // Validate thread pointer, check that source/destination match (it's
    // in its real priority list).  Also check that this thread was part of
    // the highest-running priority level.
    if ( Thread_GetPriority( pstThread_ ) >=
         Thread_GetPriority( Scheduler_GetCurrentThread() ) )
   0:	e0 91 00 00 	lds	r30, 0x0000
   4:	f0 91 00 00 	lds	r31, 0x0000
static void QuantumCallback(Thread_t *pstThread_, void *pvData_)
{
    // Validate thread pointer, check that source/destination match (it's
    // in its real priority list).  Also check that this thread was part of
    // the highest-running priority level.
    if ( Thread_GetPriority( pstThread_ ) >=
   8:	dc 01       	movw	r26, r24
   a:	19 96       	adiw	r26, 0x09	; 9
   c:	3c 91       	ld	r19, X
   e:	19 97       	sbiw	r26, 0x09	; 9
  10:	21 85       	ldd	r18, Z+9	; 0x09
  12:	32 17       	cp	r19, r18
  14:	00 f0       	brcs	.+0      	; 0x16 <QuantumCallback+0x16>
         Thread_GetPriority( Scheduler_GetCurrentThread() ) )
    {
        ThreadList_t *pstList = Thread_GetCurrent( pstThread_ );
  16:	1e 96       	adiw	r26, 0x0e	; 14
  18:	8d 91       	ld	r24, X+
  1a:	9c 91       	ld	r25, X
  1c:	1f 97       	sbiw	r26, 0x0f	; 15
        if ( LinkList_GetHead( (LinkList_t*)pstList )
  1e:	fc 01       	movw	r30, r24
  20:	40 81       	ld	r20, Z
  22:	51 81       	ldd	r21, Z+1	; 0x01
  24:	22 81       	ldd	r18, Z+2	; 0x02
  26:	33 81       	ldd	r19, Z+3	; 0x03
  28:	42 17       	cp	r20, r18
  2a:	53 07       	cpc	r21, r19
  2c:	01 f0       	breq	.+0      	; 0x2e <QuantumCallback+0x2e>
             != LinkList_GetTail( (LinkList_t*)pstList ) )
        {
            bAddQuantumTimer = true;
  2e:	21 e0       	ldi	r18, 0x01	; 1
  30:	20 93 00 00 	sts	0x0000, r18
            CircularLinkList_PivotForward( (CircularLinkList_t*)pstList );
  34:	0c 94 00 00 	jmp	0	; 0x0 <QuantumCallback>
  38:	08 95       	ret

Disassembly of section .text.Quantum_SetTimer:

00000000 <Quantum_SetTimer>:
    }
}

//---------------------------------------------------------------------------
void Quantum_SetTimer(Thread_t *pstThread_)
{
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	ec 01       	movw	r28, r24
    Timer_SetIntervalMSeconds( &m_clQuantumTimer, Thread_GetQuantum( pstThread_ ) );
   6:	4e 89       	ldd	r20, Y+22	; 0x16
   8:	5f 89       	ldd	r21, Y+23	; 0x17
   a:	60 e0       	ldi	r22, 0x00	; 0
   c:	70 e0       	ldi	r23, 0x00	; 0
   e:	80 e0       	ldi	r24, 0x00	; 0
  10:	90 e0       	ldi	r25, 0x00	; 0
  12:	0e 94 00 00 	call	0	; 0x0 <Quantum_SetTimer>
    Timer_SetFlags( &m_clQuantumTimer, TIMERLIST_FLAG_ONE_SHOT );
  16:	61 e0       	ldi	r22, 0x01	; 1
  18:	80 e0       	ldi	r24, 0x00	; 0
  1a:	90 e0       	ldi	r25, 0x00	; 0
  1c:	0e 94 00 00 	call	0	; 0x0 <Quantum_SetTimer>
    Timer_SetData( &m_clQuantumTimer, NULL );
  20:	60 e0       	ldi	r22, 0x00	; 0
  22:	70 e0       	ldi	r23, 0x00	; 0
  24:	80 e0       	ldi	r24, 0x00	; 0
  26:	90 e0       	ldi	r25, 0x00	; 0
  28:	0e 94 00 00 	call	0	; 0x0 <Quantum_SetTimer>
    Timer_SetCallback( &m_clQuantumTimer, (TimerCallback_t)QuantumCallback );
  2c:	60 e0       	ldi	r22, 0x00	; 0
  2e:	70 e0       	ldi	r23, 0x00	; 0
  30:	80 e0       	ldi	r24, 0x00	; 0
  32:	90 e0       	ldi	r25, 0x00	; 0
  34:	0e 94 00 00 	call	0	; 0x0 <Quantum_SetTimer>
    Timer_SetOwner( &m_clQuantumTimer, pstThread_ );
  38:	be 01       	movw	r22, r28
  3a:	80 e0       	ldi	r24, 0x00	; 0
  3c:	90 e0       	ldi	r25, 0x00	; 0
}
  3e:	df 91       	pop	r29
  40:	cf 91       	pop	r28
{
    Timer_SetIntervalMSeconds( &m_clQuantumTimer, Thread_GetQuantum( pstThread_ ) );
    Timer_SetFlags( &m_clQuantumTimer, TIMERLIST_FLAG_ONE_SHOT );
    Timer_SetData( &m_clQuantumTimer, NULL );
    Timer_SetCallback( &m_clQuantumTimer, (TimerCallback_t)QuantumCallback );
    Timer_SetOwner( &m_clQuantumTimer, pstThread_ );
  42:	0c 94 00 00 	jmp	0	; 0x0 <Quantum_SetTimer>

Disassembly of section .text.Quantum_AddThread:

00000000 <Quantum_AddThread>:
}

//---------------------------------------------------------------------------
void Quantum_AddThread( Thread_t *pstThread_ )
{
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	ec 01       	movw	r28, r24
    if (m_bActive
   6:	80 91 00 00 	lds	r24, 0x0000
   a:	81 11       	cpse	r24, r1
   c:	00 c0       	rjmp	.+0      	; 0xe <Quantum_AddThread+0xe>
#if KERNEL_USE_IDLE_FUNC
            || (pstThread_ == Kernel_GetIdleThread())
   e:	0e 94 00 00 	call	0	; 0x0 <Quantum_AddThread>
  12:	c8 17       	cp	r28, r24
  14:	d9 07       	cpc	r29, r25
  16:	01 f0       	breq	.+0      	; 0x18 <Quantum_AddThread+0x18>
	{
		return;	
	}		
	
	// If this is called from the timer callback, queue a timer add...
	if (m_bInTimer)
  18:	80 91 00 00 	lds	r24, 0x0000
  1c:	88 23       	and	r24, r24
  1e:	01 f0       	breq	.+0      	; 0x20 <Quantum_AddThread+0x20>
	{
		bAddQuantumTimer = true;
  20:	81 e0       	ldi	r24, 0x01	; 1
  22:	80 93 00 00 	sts	0x0000, r24
		return;
  26:	00 c0       	rjmp	.+0      	; 0x28 <Quantum_AddThread+0x28>
	}
	
    // If this isn't the only thread in the list.
    ThreadList_t *pstOwner = Thread_GetCurrent( pstThread_ );
  28:	ee 85       	ldd	r30, Y+14	; 0x0e
  2a:	ff 85       	ldd	r31, Y+15	; 0x0f
    if ( LinkList_GetHead( (LinkList_t*)pstOwner ) !=
  2c:	20 81       	ld	r18, Z
  2e:	31 81       	ldd	r19, Z+1	; 0x01
  30:	82 81       	ldd	r24, Z+2	; 0x02
  32:	93 81       	ldd	r25, Z+3	; 0x03
  34:	28 17       	cp	r18, r24
  36:	39 07       	cpc	r19, r25
  38:	01 f0       	breq	.+0      	; 0x3a <Quantum_AddThread+0x3a>
           LinkList_GetTail( (LinkList_t*)pstOwner ) )
    {
        Quantum_SetTimer( pstThread_ );
  3a:	ce 01       	movw	r24, r28
  3c:	0e 94 00 00 	call	0	; 0x0 <Quantum_AddThread>
        TimerScheduler_Add( &m_clQuantumTimer );
  40:	80 e0       	ldi	r24, 0x00	; 0
  42:	90 e0       	ldi	r25, 0x00	; 0
  44:	0e 94 00 00 	call	0	; 0x0 <Quantum_AddThread>
		m_bActive = 1;
  48:	81 e0       	ldi	r24, 0x01	; 1
  4a:	80 93 00 00 	sts	0x0000, r24
    }    
}
  4e:	df 91       	pop	r29
  50:	cf 91       	pop	r28
  52:	08 95       	ret

Disassembly of section .text.Quantum_RemoveThread:

00000000 <Quantum_RemoveThread>:

//---------------------------------------------------------------------------
void Quantum_RemoveThread( void )
{
	if (!m_bActive)
   0:	80 91 00 00 	lds	r24, 0x0000
   4:	88 23       	and	r24, r24
   6:	01 f0       	breq	.+0      	; 0x8 <Quantum_RemoveThread+0x8>
	{
		return;
	}		

    // Cancel the current timer
    TimerScheduler_Remove( &m_clQuantumTimer );
   8:	80 e0       	ldi	r24, 0x00	; 0
   a:	90 e0       	ldi	r25, 0x00	; 0
   c:	0e 94 00 00 	call	0	; 0x0 <Quantum_RemoveThread>
	m_bActive = 0;
  10:	10 92 00 00 	sts	0x0000, r1
  14:	08 95       	ret

Disassembly of section .text.Quantum_UpdateTimer:

00000000 <Quantum_UpdateTimer>:
//---------------------------------------------------------------------------
void Quantum_UpdateTimer( void )
{
    // If we have to re-add the quantum timer (more than 2 threads at the 
    // high-priority level...)
    if (bAddQuantumTimer)
   0:	80 91 00 00 	lds	r24, 0x0000
   4:	88 23       	and	r24, r24
   6:	01 f0       	breq	.+0      	; 0x8 <Quantum_UpdateTimer+0x8>
    {
        // Trigger a thread yield - this will also re-schedule the 
		// thread *and* reset the round-robin scheduler. 
        Thread_Yield();
   8:	0e 94 00 00 	call	0	; 0x0 <Quantum_UpdateTimer>
		bAddQuantumTimer = false;		
   c:	10 92 00 00 	sts	0x0000, r1
  10:	08 95       	ret

Disassembly of section .text.Quantum_SetInTimer:

00000000 <Quantum_SetInTimer>:
    }    
}
//---------------------------------------------------------------------------
void Quantum_SetInTimer( void )
{
    m_bInTimer = true;
   0:	81 e0       	ldi	r24, 0x01	; 1
   2:	80 93 00 00 	sts	0x0000, r24
   6:	08 95       	ret

Disassembly of section .text.Quantum_ClearInTimer:

00000000 <Quantum_ClearInTimer>:
}

//---------------------------------------------------------------------------
void Quantum_ClearInTimer(void)
{
    m_bInTimer = false;
   0:	10 92 00 00 	sts	0x0000, r1
   4:	08 95       	ret

scheduler.c.o:     file format elf32-avr


Disassembly of section .text.Scheduler_Init:

00000000 <Scheduler_Init>:
 */
static const K_UCHAR aucCLZ[16] ={255,0,1,1,2,2,2,2,3,3,3,3,3,3,3,3};

//---------------------------------------------------------------------------
void Scheduler_Init()
{
   0:	1f 93       	push	r17
   2:	cf 93       	push	r28
   4:	df 93       	push	r29
    m_ucPriFlag = 0;
   6:	10 92 00 00 	sts	0x0000, r1
   a:	c0 e0       	ldi	r28, 0x00	; 0
   c:	d0 e0       	ldi	r29, 0x00	; 0
    uint8_t i;
    for (i = 0; i < NUM_PRIORITIES; i++)
   e:	10 e0       	ldi	r17, 0x00	; 0
    {
        ThreadList_Init( &m_aclPriorities[i] );
  10:	ce 01       	movw	r24, r28
  12:	0e 94 00 00 	call	0	; 0x0 <Scheduler_Init>
        ThreadList_SetPriority( &m_aclPriorities[i], i );
  16:	61 2f       	mov	r22, r17
  18:	ce 01       	movw	r24, r28
  1a:	0e 94 00 00 	call	0	; 0x0 <Scheduler_Init>
        ThreadList_SetFlagPointer( &m_aclPriorities[i], &m_ucPriFlag );
  1e:	60 e0       	ldi	r22, 0x00	; 0
  20:	70 e0       	ldi	r23, 0x00	; 0
  22:	ce 01       	movw	r24, r28
  24:	0e 94 00 00 	call	0	; 0x0 <Scheduler_Init>
//---------------------------------------------------------------------------
void Scheduler_Init()
{
    m_ucPriFlag = 0;
    uint8_t i;
    for (i = 0; i < NUM_PRIORITIES; i++)
  28:	1f 5f       	subi	r17, 0xFF	; 255
  2a:	27 96       	adiw	r28, 0x07	; 7
  2c:	18 30       	cpi	r17, 0x08	; 8
  2e:	01 f4       	brne	.+0      	; 0x30 <Scheduler_Init+0x30>
    {
        ThreadList_Init( &m_aclPriorities[i] );
        ThreadList_SetPriority( &m_aclPriorities[i], i );
        ThreadList_SetFlagPointer( &m_aclPriorities[i], &m_ucPriFlag );
    }
    m_bQueuedSchedule = false;
  30:	10 92 00 00 	sts	0x0000, r1
}
  34:	df 91       	pop	r29
  36:	cf 91       	pop	r28
  38:	1f 91       	pop	r17
  3a:	08 95       	ret

Disassembly of section .text.Scheduler_Schedule:

00000000 <Scheduler_Schedule>:
    // To do this, we apply our current active-thread bitmap (m_ucPriFlag)
    // and perform a CLZ on the upper four bits.  If no tasks are found
    // in the higher priority bits, search the lower priority bits.  This
    // also assumes that we always have the idle thread ready-to-run in
    // priority level zero.
    ucPri = aucCLZ[m_ucPriFlag >> 4 ];
   0:	80 91 00 00 	lds	r24, 0x0000
   4:	a8 2f       	mov	r26, r24
   6:	a2 95       	swap	r26
   8:	af 70       	andi	r26, 0x0F	; 15
   a:	b0 e0       	ldi	r27, 0x00	; 0
   c:	a0 50       	subi	r26, 0x00	; 0
   e:	b0 40       	sbci	r27, 0x00	; 0
  10:	ec 91       	ld	r30, X
    if (ucPri == 0xFF)
  12:	ef 3f       	cpi	r30, 0xFF	; 255
  14:	01 f4       	brne	.+0      	; 0x16 <Scheduler_Schedule+0x16>
    {
        ucPri = aucCLZ[m_ucPriFlag & 0x0F];
  16:	8f 70       	andi	r24, 0x0F	; 15
  18:	e8 2f       	mov	r30, r24
  1a:	f0 e0       	ldi	r31, 0x00	; 0
  1c:	e0 50       	subi	r30, 0x00	; 0
  1e:	f0 40       	sbci	r31, 0x00	; 0
  20:	e0 81       	ld	r30, Z
  22:	00 c0       	rjmp	.+0      	; 0x24 <Scheduler_Schedule+0x24>
    }
    else
    {
        ucPri += 4;
  24:	ec 5f       	subi	r30, 0xFC	; 252
    }

#if KERNEL_USE_IDLE_FUNC
    if (ucPri == 0xFF)
  26:	ef 3f       	cpi	r30, 0xFF	; 255
  28:	01 f4       	brne	.+0      	; 0x2a <Scheduler_Schedule+0x2a>
    {
        // There aren't any active threads at all - set g_pstNext to IDLE
        g_pstNext = Kernel_GetIdleThread();
  2a:	0e 94 00 00 	call	0	; 0x0 <Scheduler_Schedule>
  2e:	00 c0       	rjmp	.+0      	; 0x30 <Scheduler_Schedule+0x30>
    }
    else
#endif
    {
        // Get the thread node at this priority.
        g_pstNext = (Thread_t*)( LinkList_GetHead( (LinkList_t*)&m_aclPriorities[ucPri] ) );
  30:	87 e0       	ldi	r24, 0x07	; 7
  32:	e8 9f       	mul	r30, r24
  34:	f0 01       	movw	r30, r0
  36:	11 24       	eor	r1, r1
  38:	e0 50       	subi	r30, 0x00	; 0
  3a:	f0 40       	sbci	r31, 0x00	; 0
  3c:	80 81       	ld	r24, Z
  3e:	91 81       	ldd	r25, Z+1	; 0x01
  40:	90 93 00 00 	sts	0x0000, r25
  44:	80 93 00 00 	sts	0x0000, r24
  48:	08 95       	ret

Disassembly of section .text.Scheduler_Add:

00000000 <Scheduler_Add>:
    KERNEL_TRACE_1( STR_SCHEDULE_1, (K_USHORT)Thread_GetID( (Thread_t*)g_pstNext) );
}

//---------------------------------------------------------------------------
void Scheduler_Add(Thread_t *pstThread_)
{
   0:	bc 01       	movw	r22, r24
    ThreadList_Add( &m_aclPriorities[ Thread_GetPriority(pstThread_) ],
   2:	fc 01       	movw	r30, r24
   4:	81 85       	ldd	r24, Z+9	; 0x09
   6:	f7 e0       	ldi	r31, 0x07	; 7
   8:	8f 9f       	mul	r24, r31
   a:	c0 01       	movw	r24, r0
   c:	11 24       	eor	r1, r1
   e:	80 50       	subi	r24, 0x00	; 0
  10:	90 40       	sbci	r25, 0x00	; 0
  12:	0c 94 00 00 	jmp	0	; 0x0 <Scheduler_Add>

Disassembly of section .text.Scheduler_Remove:

00000000 <Scheduler_Remove>:
                    pstThread_ );
}

//---------------------------------------------------------------------------
void Scheduler_Remove(Thread_t *pstThread_)
{
   0:	bc 01       	movw	r22, r24
    ThreadList_Remove( &m_aclPriorities[ Thread_GetPriority(pstThread_) ],
   2:	fc 01       	movw	r30, r24
   4:	81 85       	ldd	r24, Z+9	; 0x09
   6:	f7 e0       	ldi	r31, 0x07	; 7
   8:	8f 9f       	mul	r24, r31
   a:	c0 01       	movw	r24, r0
   c:	11 24       	eor	r1, r1
   e:	80 50       	subi	r24, 0x00	; 0
  10:	90 40       	sbci	r25, 0x00	; 0
  12:	0c 94 00 00 	jmp	0	; 0x0 <Scheduler_Remove>

Disassembly of section .text.Scheduler_SetScheduler:

00000000 <Scheduler_SetScheduler>:
                       pstThread_ );
}

//---------------------------------------------------------------------------
K_BOOL Scheduler_SetScheduler(K_BOOL bEnable_)
{
   0:	1f 93       	push	r17
   2:	cf 93       	push	r28
   4:	df 93       	push	r29
   6:	1f 92       	push	r1
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
    K_BOOL bRet ;
    CS_ENTER();
   c:	9f b7       	in	r25, 0x3f	; 63
   e:	99 83       	std	Y+1, r25	; 0x01
  10:	f8 94       	cli
    bRet = m_bEnabled;
  12:	10 91 00 00 	lds	r17, 0x0000
    m_bEnabled = bEnable_;
  16:	80 93 00 00 	sts	0x0000, r24
    // If there was a queued scheduler evevent, dequeue and trigger an
    // immediate Yield
    if (m_bEnabled && m_bQueuedSchedule)
  1a:	88 23       	and	r24, r24
  1c:	01 f0       	breq	.+0      	; 0x1e <Scheduler_SetScheduler+0x1e>
  1e:	80 91 00 00 	lds	r24, 0x0000
  22:	88 23       	and	r24, r24
  24:	01 f0       	breq	.+0      	; 0x26 <Scheduler_SetScheduler+0x26>
    {
        m_bQueuedSchedule = false;
  26:	10 92 00 00 	sts	0x0000, r1
        Thread_Yield();
  2a:	0e 94 00 00 	call	0	; 0x0 <Scheduler_SetScheduler>
    }
    CS_EXIT();
  2e:	89 81       	ldd	r24, Y+1	; 0x01
  30:	8f bf       	out	0x3f, r24	; 63
    return bRet;
}
  32:	81 2f       	mov	r24, r17
  34:	0f 90       	pop	r0
  36:	df 91       	pop	r29
  38:	cf 91       	pop	r28
  3a:	1f 91       	pop	r17
  3c:	08 95       	ret

Disassembly of section .text.Scheduler_QueueScheduler:

00000000 <Scheduler_QueueScheduler>:
 * Tell the kernel to perform a scheduling operation as soon as the
 * scheduler is re-enabled.
 */
void Scheduler_QueueScheduler()
{
    m_bQueuedSchedule = true;
   0:	81 e0       	ldi	r24, 0x01	; 1
   2:	80 93 00 00 	sts	0x0000, r24
   6:	08 95       	ret

Disassembly of section .text.Scheduler_GetThreadList:

00000000 <Scheduler_GetThreadList>:
}

//---------------------------------------------------------------------------
ThreadList_t *Scheduler_GetThreadList( K_UCHAR ucPriority_ )
{
    return &m_aclPriorities[ucPriority_];
   0:	27 e0       	ldi	r18, 0x07	; 7
   2:	82 9f       	mul	r24, r18
   4:	c0 01       	movw	r24, r0
   6:	11 24       	eor	r1, r1
}
   8:	80 50       	subi	r24, 0x00	; 0
   a:	90 40       	sbci	r25, 0x00	; 0
   c:	08 95       	ret

Disassembly of section .text.Scheduler_GetStopList:

00000000 <Scheduler_GetStopList>:
    \return Pointer to the ThreadList_t containing the stopped threads
*/
ThreadList_t *Scheduler_GetStopList()
{
    return &m_clStopList;
}
   0:	80 e0       	ldi	r24, 0x00	; 0
   2:	90 e0       	ldi	r25, 0x00	; 0
   4:	08 95       	ret

ksemaphore.c.o:     file format elf32-avr


Disassembly of section .text.TimedSemaphore_Callback:

00000000 <TimedSemaphore_Callback>:
 *
 * \param pstOwner_ Pointer to the thread to wake
 * \param pvData_   Pointer to the Semaphore_t object that the thread is blocked on
 */
void TimedSemaphore_Callback( Thread_t *pstOwner_, void *pvData_)
{
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	ec 01       	movw	r28, r24
	Semaphore_t *pstSemaphore = (Semaphore_t*)(pvData_);
	
	// Indicate that the Semaphore_t has expired on the thread	
	Thread_SetExpired( pstOwner_, true );
   6:	81 e0       	ldi	r24, 0x01	; 1
   8:	8a ab       	std	Y+50, r24	; 0x32

//---------------------------------------------------------------------------
void Semaphore_WakeMe( Semaphore_t *pstSem_, Thread_t *pstChosenOne_ )
{ 
    // Remove from the Semaphore_t waitlist and back to its ready list.
    BlockingObject_UnBlock( pstChosenOne_ );
   a:	ce 01       	movw	r24, r28
   c:	0e 94 00 00 	call	0	; 0x0 <TimedSemaphore_Callback>
	Thread_SetExpired( pstOwner_, true );
	// Wake up the thread that was blocked on this Semaphore_t.
	Semaphore_WakeMe( pstSemaphore, pstOwner_ );
	
    if ( Thread_GetCurPriority( pstOwner_ ) >= 
		 Thread_GetCurPriority( Scheduler_GetCurrentThread() ) )
  10:	e0 91 00 00 	lds	r30, 0x0000
  14:	f0 91 00 00 	lds	r31, 0x0000
	// Indicate that the Semaphore_t has expired on the thread	
	Thread_SetExpired( pstOwner_, true );
	// Wake up the thread that was blocked on this Semaphore_t.
	Semaphore_WakeMe( pstSemaphore, pstOwner_ );
	
    if ( Thread_GetCurPriority( pstOwner_ ) >= 
  18:	9a 85       	ldd	r25, Y+10	; 0x0a
  1a:	82 85       	ldd	r24, Z+10	; 0x0a
  1c:	98 17       	cp	r25, r24
  1e:	00 f0       	brcs	.+0      	; 0x20 <TimedSemaphore_Callback+0x20>
		 Thread_GetCurPriority( Scheduler_GetCurrentThread() ) )
	{
        Thread_Yield();
	}	
}
  20:	df 91       	pop	r29
  22:	cf 91       	pop	r28
	Semaphore_WakeMe( pstSemaphore, pstOwner_ );
	
    if ( Thread_GetCurPriority( pstOwner_ ) >= 
		 Thread_GetCurPriority( Scheduler_GetCurrentThread() ) )
	{
        Thread_Yield();
  24:	0c 94 00 00 	jmp	0	; 0x0 <TimedSemaphore_Callback>
	}	
}
  28:	df 91       	pop	r29
  2a:	cf 91       	pop	r28
  2c:	08 95       	ret

Disassembly of section .text.Semaphore_Pend_i:

00000000 <Semaphore_Pend_i>:
#if KERNEL_USE_TIMEOUTS
K_BOOL Semaphore_Pend_i( Semaphore_t *pstSem_, K_ULONG ulWaitTimeMS_ )
#else
void Semaphore_Pend_i( void )
#endif
{
   0:	cf 92       	push	r12
   2:	df 92       	push	r13
   4:	ef 92       	push	r14
   6:	ff 92       	push	r15
   8:	0f 93       	push	r16
   a:	1f 93       	push	r17
   c:	cf 93       	push	r28
   e:	df 93       	push	r29
  10:	cd b7       	in	r28, 0x3d	; 61
  12:	de b7       	in	r29, 0x3e	; 62
  14:	6c 97       	sbiw	r28, 0x1c	; 28
  16:	0f b6       	in	r0, 0x3f	; 63
  18:	f8 94       	cli
  1a:	de bf       	out	0x3e, r29	; 62
  1c:	0f be       	out	0x3f, r0	; 63
  1e:	cd bf       	out	0x3d, r28	; 61
  20:	6c 01       	movw	r12, r24
    K_BOOL bUseTimer = false;
#endif

    // Once again, messing with thread data - ensure
    // we're doing all of these operations from within a thread-safe context.
    CS_ENTER();
  22:	8f b7       	in	r24, 0x3f	; 63
  24:	88 8f       	std	Y+24, r24	; 0x18
  26:	f8 94       	cli

    // Check to see if we need to take any action based on the Semaphore_t count
    if (pstSem_->m_usValue != 0)
  28:	f6 01       	movw	r30, r12
  2a:	87 81       	ldd	r24, Z+7	; 0x07
  2c:	90 85       	ldd	r25, Z+8	; 0x08
  2e:	00 97       	sbiw	r24, 0x00	; 0
  30:	01 f0       	breq	.+0      	; 0x32 <Semaphore_Pend_i+0x32>
    {
        // The Semaphore_t count is non-zero, we can just decrement the count
        // and go along our merry way.
        pstSem_->m_usValue--;
  32:	01 97       	sbiw	r24, 0x01	; 1
  34:	90 87       	std	Z+8, r25	; 0x08
  36:	87 83       	std	Z+7, r24	; 0x07
{
    KERNEL_TRACE_1( STR_SEMAPHORE_PEND_1, (K_USHORT)Thread_GetID( g_pstCurrent ) );

#if KERNEL_USE_TIMEOUTS
    Timer_t stSemTimer;
    K_BOOL bUseTimer = false;
  38:	10 e0       	ldi	r17, 0x00	; 0
  3a:	00 c0       	rjmp	.+0      	; 0x3c <Semaphore_Pend_i+0x3c>
    else
    {
        // The Semaphore_t count is zero - we need to block the current thread
        // and wait until the Semaphore_t is posted from elsewhere.
#if KERNEL_USE_TIMEOUTS        
        if (ulWaitTimeMS_)
  3c:	41 15       	cp	r20, r1
  3e:	51 05       	cpc	r21, r1
  40:	61 05       	cpc	r22, r1
  42:	71 05       	cpc	r23, r1
  44:	01 f0       	breq	.+0      	; 0x46 <Semaphore_Pend_i+0x46>
        {
            Thread_SetExpired( g_pstCurrent, false );
  46:	e0 91 00 00 	lds	r30, 0x0000
  4a:	f0 91 00 00 	lds	r31, 0x0000
  4e:	12 aa       	std	Z+50, r1	; 0x32
			Timer_Init( &stSemTimer );
  50:	ce 01       	movw	r24, r28
  52:	01 96       	adiw	r24, 0x01	; 1
  54:	49 8f       	std	Y+25, r20	; 0x19
  56:	5a 8f       	std	Y+26, r21	; 0x1a
  58:	6b 8f       	std	Y+27, r22	; 0x1b
  5a:	7c 8f       	std	Y+28, r23	; 0x1c
  5c:	0e 94 00 00 	call	0	; 0x0 <Semaphore_Pend_i>
            Timer_Start( &stSemTimer, false, ulWaitTimeMS_, TimedSemaphore_Callback, (void*)pstSem_ );
  60:	76 01       	movw	r14, r12
  62:	00 e0       	ldi	r16, 0x00	; 0
  64:	10 e0       	ldi	r17, 0x00	; 0
  66:	49 8d       	ldd	r20, Y+25	; 0x19
  68:	5a 8d       	ldd	r21, Y+26	; 0x1a
  6a:	6b 8d       	ldd	r22, Y+27	; 0x1b
  6c:	7c 8d       	ldd	r23, Y+28	; 0x1c
  6e:	9a 01       	movw	r18, r20
  70:	ab 01       	movw	r20, r22
  72:	60 e0       	ldi	r22, 0x00	; 0
  74:	ce 01       	movw	r24, r28
  76:	01 96       	adiw	r24, 0x01	; 1
  78:	0e 94 00 00 	call	0	; 0x0 <Semaphore_Pend_i>
            bUseTimer = true;
  7c:	11 e0       	ldi	r17, 0x01	; 1
  7e:	00 c0       	rjmp	.+0      	; 0x80 <Semaphore_Pend_i+0x80>
{
    KERNEL_TRACE_1( STR_SEMAPHORE_PEND_1, (K_USHORT)Thread_GetID( g_pstCurrent ) );

#if KERNEL_USE_TIMEOUTS
    Timer_t stSemTimer;
    K_BOOL bUseTimer = false;
  80:	10 e0       	ldi	r17, 0x00	; 0
			Timer_Init( &stSemTimer );
            Timer_Start( &stSemTimer, false, ulWaitTimeMS_, TimedSemaphore_Callback, (void*)pstSem_ );
            bUseTimer = true;
        }
#endif
        BlockingObject_Block( (ThreadList_t*)pstSem_, g_pstCurrent );
  82:	60 91 00 00 	lds	r22, 0x0000
  86:	70 91 00 00 	lds	r23, 0x0000
  8a:	c6 01       	movw	r24, r12
  8c:	0e 94 00 00 	call	0	; 0x0 <Semaphore_Pend_i>

        // Switch Threads immediately
        Thread_Yield();
  90:	0e 94 00 00 	call	0	; 0x0 <Semaphore_Pend_i>
    }

    CS_EXIT();
  94:	88 8d       	ldd	r24, Y+24	; 0x18
  96:	8f bf       	out	0x3f, r24	; 63

#if KERNEL_USE_TIMEOUTS
    if (bUseTimer)
  98:	11 23       	and	r17, r17
  9a:	01 f0       	breq	.+0      	; 0x9c <Semaphore_Pend_i+0x9c>
    {
		Timer_Stop( &stSemTimer );
  9c:	ce 01       	movw	r24, r28
  9e:	01 96       	adiw	r24, 0x01	; 1
  a0:	0e 94 00 00 	call	0	; 0x0 <Semaphore_Pend_i>
        return ( Thread_GetExpired( g_pstCurrent ) == 0);
  a4:	e0 91 00 00 	lds	r30, 0x0000
  a8:	f0 91 00 00 	lds	r31, 0x0000
  ac:	82 a9       	ldd	r24, Z+50	; 0x32
  ae:	91 e0       	ldi	r25, 0x01	; 1
  b0:	89 27       	eor	r24, r25
  b2:	00 c0       	rjmp	.+0      	; 0xb4 <Semaphore_Pend_i+0xb4>
    }
    return true;
  b4:	81 e0       	ldi	r24, 0x01	; 1
#endif
}
  b6:	6c 96       	adiw	r28, 0x1c	; 28
  b8:	0f b6       	in	r0, 0x3f	; 63
  ba:	f8 94       	cli
  bc:	de bf       	out	0x3e, r29	; 62
  be:	0f be       	out	0x3f, r0	; 63
  c0:	cd bf       	out	0x3d, r28	; 61
  c2:	df 91       	pop	r29
  c4:	cf 91       	pop	r28
  c6:	1f 91       	pop	r17
  c8:	0f 91       	pop	r16
  ca:	ff 90       	pop	r15
  cc:	ef 90       	pop	r14
  ce:	df 90       	pop	r13
  d0:	cf 90       	pop	r12
  d2:	08 95       	ret

Disassembly of section .text.Semaphore_Init:

00000000 <Semaphore_Init>:
void Semaphore_Init( Semaphore_t *pstSem_, K_USHORT usInitVal_, K_USHORT usMaxVal_)
{
    // Copy the paramters into the object - set the maximum value for this
    // Semaphore_t to implement either binary or counting semaphores, and set
    // the initial count.  Clear the wait list for this object.
    pstSem_->m_usValue = usInitVal_;
   0:	fc 01       	movw	r30, r24
   2:	70 87       	std	Z+8, r23	; 0x08
   4:	67 83       	std	Z+7, r22	; 0x07
    pstSem_->m_usMaxValue = usMaxVal_;    
   6:	52 87       	std	Z+10, r21	; 0x0a
   8:	41 87       	std	Z+9, r20	; 0x09

	ThreadList_Init( (ThreadList_t*)pstSem_ );
   a:	0c 94 00 00 	jmp	0	; 0x0 <Semaphore_Init>

Disassembly of section .text.Semaphore_Post:

00000000 <Semaphore_Post>:
}

//---------------------------------------------------------------------------
K_BOOL Semaphore_Post( Semaphore_t *pstSem_ )
{
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17
   4:	cf 93       	push	r28
   6:	df 93       	push	r29
   8:	1f 92       	push	r1
   a:	cd b7       	in	r28, 0x3d	; 61
   c:	de b7       	in	r29, 0x3e	; 62
    K_BOOL bThreadWake = 0;
    K_BOOL bBail = false;
    // Increment the Semaphore_t count - we can mess with threads so ensure this
    // is in a critical section.  We don't just disable the scheudler since
    // we want to be able to do this from within an interrupt context as well.
    CS_ENTER();
   e:	2f b7       	in	r18, 0x3f	; 63
  10:	29 83       	std	Y+1, r18	; 0x01
  12:	f8 94       	cli

    // If nothing is waiting for the Semaphore_t
	
    if ( LinkList_GetHead( (LinkList_t*)pstSem_ ) == NULL)
  14:	dc 01       	movw	r26, r24
  16:	2d 91       	ld	r18, X+
  18:	3c 91       	ld	r19, X
  1a:	11 97       	sbiw	r26, 0x01	; 1
  1c:	23 2b       	or	r18, r19
  1e:	01 f4       	brne	.+0      	; 0x20 <Semaphore_Post+0x20>
    {
        // Check so see if we've reached the maximum value in the Semaphore_t
        if (pstSem_->m_usValue < pstSem_->m_usMaxValue)
  20:	17 96       	adiw	r26, 0x07	; 7
  22:	2d 91       	ld	r18, X+
  24:	3c 91       	ld	r19, X
  26:	18 97       	sbiw	r26, 0x08	; 8
  28:	19 96       	adiw	r26, 0x09	; 9
  2a:	4d 91       	ld	r20, X+
  2c:	5c 91       	ld	r21, X
  2e:	1a 97       	sbiw	r26, 0x0a	; 10
  30:	24 17       	cp	r18, r20
  32:	35 07       	cpc	r19, r21
  34:	00 f4       	brcc	.+0      	; 0x36 <Semaphore_Post+0x36>
        {
            // Increment the count value
            pstSem_->m_usValue++;
  36:	2f 5f       	subi	r18, 0xFF	; 255
  38:	3f 4f       	sbci	r19, 0xFF	; 255
  3a:	18 96       	adiw	r26, 0x08	; 8
  3c:	3c 93       	st	X, r19
  3e:	2e 93       	st	-X, r18
  40:	17 97       	sbiw	r26, 0x07	; 7
K_BOOL Semaphore_Post( Semaphore_t *pstSem_ )
{
	KERNEL_TRACE_1( STR_SEMAPHORE_POST_1, (K_USHORT)Thread_GetID( g_pstCurrent ));
	
    K_BOOL bThreadWake = 0;
    K_BOOL bBail = false;
  42:	90 e0       	ldi	r25, 0x00	; 0
  44:	00 c0       	rjmp	.+0      	; 0x46 <Semaphore_Post+0x46>
//---------------------------------------------------------------------------
K_UCHAR Semaphore_WakeNext( Semaphore_t *pstSem_ )
{
    Thread_t *pstChosenOne;
    
    pstChosenOne = ThreadList_HighestWaiter( (ThreadList_t*)pstSem_ );
  46:	0e 94 00 00 	call	0	; 0x0 <Semaphore_Post>
  4a:	8c 01       	movw	r16, r24
    
    // Remove from the Semaphore_t waitlist and back to its ready list.
    BlockingObject_UnBlock( pstChosenOne );
  4c:	0e 94 00 00 	call	0	; 0x0 <Semaphore_Post>

    // Call a task switch if higher or equal priority thread
    if ( Thread_GetCurPriority( pstChosenOne ) >= 
		 Thread_GetCurPriority( Scheduler_GetCurrentThread() ) )
  50:	e0 91 00 00 	lds	r30, 0x0000
  54:	f0 91 00 00 	lds	r31, 0x0000
    
    // Remove from the Semaphore_t waitlist and back to its ready list.
    BlockingObject_UnBlock( pstChosenOne );

    // Call a task switch if higher or equal priority thread
    if ( Thread_GetCurPriority( pstChosenOne ) >= 
  58:	81 e0       	ldi	r24, 0x01	; 1
  5a:	d8 01       	movw	r26, r16
  5c:	1a 96       	adiw	r26, 0x0a	; 10
  5e:	2c 91       	ld	r18, X
  60:	92 85       	ldd	r25, Z+10	; 0x0a
  62:	29 17       	cp	r18, r25
  64:	00 f4       	brcc	.+0      	; 0x66 <Semaphore_Post+0x66>
  66:	80 e0       	ldi	r24, 0x00	; 0
K_BOOL Semaphore_Post( Semaphore_t *pstSem_ )
{
	KERNEL_TRACE_1( STR_SEMAPHORE_POST_1, (K_USHORT)Thread_GetID( g_pstCurrent ));
	
    K_BOOL bThreadWake = 0;
    K_BOOL bBail = false;
  68:	90 e0       	ldi	r25, 0x00	; 0
  6a:	00 c0       	rjmp	.+0      	; 0x6c <Semaphore_Post+0x6c>
            pstSem_->m_usValue++;
        }
        else
        {
            // Maximum value has been reached, bail out.
            bBail = true;
  6c:	91 e0       	ldi	r25, 0x01	; 1
//---------------------------------------------------------------------------
K_BOOL Semaphore_Post( Semaphore_t *pstSem_ )
{
	KERNEL_TRACE_1( STR_SEMAPHORE_POST_1, (K_USHORT)Thread_GetID( g_pstCurrent ));
	
    K_BOOL bThreadWake = 0;
  6e:	80 e0       	ldi	r24, 0x00	; 0
        // Otherwise, there are threads waiting for the Semaphore_t to be
        // posted, so wake the next one (highest priority goes first).
        bThreadWake = Semaphore_WakeNext( pstSem_ );
    }

    CS_EXIT();
  70:	29 81       	ldd	r18, Y+1	; 0x01
  72:	2f bf       	out	0x3f, r18	; 63

    // If we weren't able to increment the Semaphore_t count, fail out.
    if (bBail)
  74:	91 11       	cpse	r25, r1
  76:	00 c0       	rjmp	.+0      	; 0x78 <Semaphore_Post+0x78>
    }

    // if bThreadWake was set, it means that a higher-priority thread was
    // woken.  Trigger a context switch to ensure that this thread gets
    // to execute next.
    if (bThreadWake)
  78:	88 23       	and	r24, r24
  7a:	01 f0       	breq	.+0      	; 0x7c <Semaphore_Post+0x7c>
    {
        Thread_Yield();
  7c:	0e 94 00 00 	call	0	; 0x0 <Semaphore_Post>
  80:	00 c0       	rjmp	.+0      	; 0x82 <Semaphore_Post+0x82>
    CS_EXIT();

    // If we weren't able to increment the Semaphore_t count, fail out.
    if (bBail)
    {
        return false;
  82:	80 e0       	ldi	r24, 0x00	; 0
  84:	00 c0       	rjmp	.+0      	; 0x86 <Semaphore_Post+0x86>
    // to execute next.
    if (bThreadWake)
    {
        Thread_Yield();
    }
    return true;
  86:	81 e0       	ldi	r24, 0x01	; 1
}
  88:	0f 90       	pop	r0
  8a:	df 91       	pop	r29
  8c:	cf 91       	pop	r28
  8e:	1f 91       	pop	r17
  90:	0f 91       	pop	r16
  92:	08 95       	ret

Disassembly of section .text.Semaphore_Pend:

00000000 <Semaphore_Pend>:
//---------------------------------------------------------------------------
// Redirect the untimed pend API to the timed pend, with a null timeout.
void Semaphore_Pend( Semaphore_t *pstSem_ )
{
#if KERNEL_USE_TIMEOUTS
    Semaphore_Pend_i( pstSem_, 0);
   0:	40 e0       	ldi	r20, 0x00	; 0
   2:	50 e0       	ldi	r21, 0x00	; 0
   4:	ba 01       	movw	r22, r20
   6:	0c 94 00 00 	jmp	0	; 0x0 <Semaphore_Pend>

Disassembly of section .text.Semaphore_TimedPend:

00000000 <Semaphore_TimedPend>:

#if KERNEL_USE_TIMEOUTS
//---------------------------------------------------------------------------	
K_BOOL Semaphore_TimedPend( Semaphore_t *pstSem_, K_ULONG ulWaitTimeMS_ )
{
    return Semaphore_Pend_i( pstSem_, ulWaitTimeMS_ );
   0:	0c 94 00 00 	jmp	0	; 0x0 <Semaphore_TimedPend>

Disassembly of section .text.Semaphore_GetCount:

00000000 <Semaphore_GetCount>:
}
#endif

//---------------------------------------------------------------------------
K_USHORT Semaphore_GetCount( Semaphore_t *pstSem_ )
{
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	1f 92       	push	r1
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
	K_USHORT usRet;
	CS_ENTER();
   a:	2f b7       	in	r18, 0x3f	; 63
   c:	29 83       	std	Y+1, r18	; 0x01
   e:	f8 94       	cli
	usRet = pstSem_->m_usValue;
  10:	fc 01       	movw	r30, r24
  12:	87 81       	ldd	r24, Z+7	; 0x07
  14:	90 85       	ldd	r25, Z+8	; 0x08
	CS_EXIT();
  16:	29 81       	ldd	r18, Y+1	; 0x01
  18:	2f bf       	out	0x3f, r18	; 63
	return usRet;
}
  1a:	0f 90       	pop	r0
  1c:	df 91       	pop	r29
  1e:	cf 91       	pop	r28
  20:	08 95       	ret

thread.c.o:     file format elf32-avr


Disassembly of section .text.ThreadSleepCallback:

00000000 <ThreadSleepCallback>:

#if KERNEL_USE_SLEEP
//---------------------------------------------------------------------------
//! This callback is used to wake up a thread once the interval has expired
static void ThreadSleepCallback( Thread_t *pstOwner_, void *pvData_ )
{
   0:	cb 01       	movw	r24, r22
    Semaphore_t *pstSemaphore = (Semaphore_t*)(pvData_);
    // Post the Semaphore_t, which will wake the sleeping thread.
    Semaphore_Post( pstSemaphore );
   2:	0c 94 00 00 	jmp	0	; 0x0 <ThreadSleepCallback>

Disassembly of section .text.Thread_Init:

00000000 <Thread_Init>:
                    K_WORD *pwStack_,
                    K_USHORT usStackSize_,
                    K_UCHAR ucPriority_,
                    ThreadEntry_t pfEntryPoint_,
                    void *pvArg_ )
{
   0:	cf 92       	push	r12
   2:	df 92       	push	r13
   4:	ef 92       	push	r14
   6:	ff 92       	push	r15
   8:	0f 93       	push	r16
   a:	1f 93       	push	r17
   c:	cf 93       	push	r28
   e:	df 93       	push	r29
  10:	1f 92       	push	r1
  12:	cd b7       	in	r28, 0x3d	; 61
  14:	de b7       	in	r29, 0x3e	; 62
  16:	6c 01       	movw	r12, r24
    static K_UCHAR ucThreadID = 0;

    KERNEL_ASSERT( pwStack_ );
    KERNEL_ASSERT( pfEntryPoint_ );
    
    LinkListNode_Clear( (LinkListNode_t*)pstThread_ );
  18:	fc 01       	movw	r30, r24
  1a:	11 82       	std	Z+1, r1	; 0x01
  1c:	10 82       	st	Z, r1
  1e:	13 82       	std	Z+3, r1	; 0x03
  20:	12 82       	std	Z+2, r1	; 0x02

    pstThread_->m_ucThreadID = ucThreadID++;
  22:	80 91 00 00 	lds	r24, 0x0000
  26:	91 e0       	ldi	r25, 0x01	; 1
  28:	98 0f       	add	r25, r24
  2a:	90 93 00 00 	sts	0x0000, r25
  2e:	80 87       	std	Z+8, r24	; 0x08
    KERNEL_TRACE_1( STR_PRIORITY_1, (K_UCHAR)ucPriority_ );
    KERNEL_TRACE_1( STR_THREAD_ID_1, (K_USHORT)pstThread_->m_ucThreadID );
    KERNEL_TRACE_1( STR_ENTRYPOINT_1, (K_USHORT)pfEntryPoint_ );
    
    // Initialize the thread parameters to their initial values.
    pstThread_->m_pwStack = pwStack_;
  30:	77 83       	std	Z+7, r23	; 0x07
  32:	66 83       	std	Z+6, r22	; 0x06
    pstThread_->m_pwStackTop = TOP_OF_STACK(pwStack_, usStackSize_);
  34:	ca 01       	movw	r24, r20
  36:	01 97       	sbiw	r24, 0x01	; 1
  38:	86 0f       	add	r24, r22
  3a:	97 1f       	adc	r25, r23
  3c:	95 83       	std	Z+5, r25	; 0x05
  3e:	84 83       	std	Z+4, r24	; 0x04
    
    pstThread_->m_usStackSize = usStackSize_;
  40:	55 87       	std	Z+13, r21	; 0x0d
  42:	44 87       	std	Z+12, r20	; 0x0c
    
#if KERNEL_USE_QUANTUM    
    pstThread_->m_usQuantum = THREAD_QUANTUM_DEFAULT;
  44:	84 e0       	ldi	r24, 0x04	; 4
  46:	90 e0       	ldi	r25, 0x00	; 0
  48:	97 8b       	std	Z+23, r25	; 0x17
  4a:	86 8b       	std	Z+22, r24	; 0x16
#endif

    pstThread_->m_ucPriority = ucPriority_ ;
  4c:	21 87       	std	Z+9, r18	; 0x09
    pstThread_->m_ucCurPriority = pstThread_->m_ucPriority;
  4e:	22 87       	std	Z+10, r18	; 0x0a
    pstThread_->m_pfEntryPoint = pfEntryPoint_;
  50:	13 8b       	std	Z+19, r17	; 0x13
  52:	02 8b       	std	Z+18, r16	; 0x12
    pstThread_->m_pvArg = pvArg_;
  54:	f5 8a       	std	Z+21, r15	; 0x15
  56:	e4 8a       	std	Z+20, r14	; 0x14
    pstThread_->m_eState = THREAD_STATE_STOP;
  58:	83 e0       	ldi	r24, 0x03	; 3
  5a:	83 87       	std	Z+11, r24	; 0x0b
    
#if KERNEL_USE_THREADNAME    
    pstThread_->m_szName = NULL;
#endif
#if KERNEL_USE_TIMERS
	Timer_Init( &(pstThread_->m_clTimer) );
  5c:	c6 01       	movw	r24, r12
  5e:	4b 96       	adiw	r24, 0x1b	; 27
  60:	0e 94 00 00 	call	0	; 0x0 <Thread_Init>
#endif

    // Call CPU-specific stack initialization
    ThreadPort_InitStack( pstThread_ );
  64:	c6 01       	movw	r24, r12
  66:	0e 94 00 00 	call	0	; 0x0 <Thread_Init>
    
    // Add to the global "stop" list.
    CS_ENTER();
  6a:	8f b7       	in	r24, 0x3f	; 63
  6c:	89 83       	std	Y+1, r24	; 0x01
  6e:	f8 94       	cli
    pstThread_->m_pstOwner = Scheduler_GetThreadList(pstThread_->m_ucPriority);
  70:	f6 01       	movw	r30, r12
  72:	81 85       	ldd	r24, Z+9	; 0x09
  74:	0e 94 00 00 	call	0	; 0x0 <Thread_Init>
  78:	f6 01       	movw	r30, r12
  7a:	91 8b       	std	Z+17, r25	; 0x11
  7c:	80 8b       	std	Z+16, r24	; 0x10
    pstThread_->m_pstCurrent = Scheduler_GetStopList();
  7e:	0e 94 00 00 	call	0	; 0x0 <Thread_Init>
  82:	f6 01       	movw	r30, r12
  84:	97 87       	std	Z+15, r25	; 0x0f
  86:	86 87       	std	Z+14, r24	; 0x0e
    ThreadList_Add( pstThread_->m_pstCurrent, pstThread_ );
  88:	b6 01       	movw	r22, r12
  8a:	0e 94 00 00 	call	0	; 0x0 <Thread_Init>
	CS_EXIT();
  8e:	89 81       	ldd	r24, Y+1	; 0x01
  90:	8f bf       	out	0x3f, r24	; 63
}
  92:	0f 90       	pop	r0
  94:	df 91       	pop	r29
  96:	cf 91       	pop	r28
  98:	1f 91       	pop	r17
  9a:	0f 91       	pop	r16
  9c:	ff 90       	pop	r15
  9e:	ef 90       	pop	r14
  a0:	df 90       	pop	r13
  a2:	cf 90       	pop	r12
  a4:	08 95       	ret

Disassembly of section .text.Thread_Sleep:

00000000 <Thread_Sleep>:
    Semaphore_Post( pstSemaphore );
}

//---------------------------------------------------------------------------
void Thread_Sleep( K_ULONG ulTimeMs_)
{    
   0:	cf 92       	push	r12
   2:	df 92       	push	r13
   4:	ef 92       	push	r14
   6:	ff 92       	push	r15
   8:	0f 93       	push	r16
   a:	1f 93       	push	r17
   c:	cf 93       	push	r28
   e:	df 93       	push	r29
  10:	cd b7       	in	r28, 0x3d	; 61
  12:	de b7       	in	r29, 0x3e	; 62
  14:	2b 97       	sbiw	r28, 0x0b	; 11
  16:	0f b6       	in	r0, 0x3f	; 63
  18:	f8 94       	cli
  1a:	de bf       	out	0x3e, r29	; 62
  1c:	0f be       	out	0x3f, r0	; 63
  1e:	cd bf       	out	0x3d, r28	; 61
  20:	6b 01       	movw	r12, r22
  22:	7c 01       	movw	r14, r24
    Semaphore_t clSemaphore;
    Timer_t *pstTimer = Thread_GetTimer( g_pstCurrent );
  24:	00 91 00 00 	lds	r16, 0x0000
  28:	10 91 00 00 	lds	r17, 0x0000
  2c:	05 5e       	subi	r16, 0xE5	; 229
  2e:	1f 4f       	sbci	r17, 0xFF	; 255

    // Create a Semaphore_t that this thread will block on
	Semaphore_Init( &clSemaphore, 0, 1 );
  30:	41 e0       	ldi	r20, 0x01	; 1
  32:	50 e0       	ldi	r21, 0x00	; 0
  34:	60 e0       	ldi	r22, 0x00	; 0
  36:	70 e0       	ldi	r23, 0x00	; 0
  38:	ce 01       	movw	r24, r28
  3a:	01 96       	adiw	r24, 0x01	; 1
  3c:	0e 94 00 00 	call	0	; 0x0 <Thread_Sleep>
    
    // Create a one-shot timer that will call a callback that posts the 
    // Semaphore_t, waking our thread.
	Timer_Init( pstTimer );
  40:	c8 01       	movw	r24, r16
  42:	0e 94 00 00 	call	0	; 0x0 <Thread_Sleep>
	Timer_SetIntervalMSeconds( pstTimer, ulTimeMs_ );
  46:	b7 01       	movw	r22, r14
  48:	a6 01       	movw	r20, r12
  4a:	c8 01       	movw	r24, r16
  4c:	0e 94 00 00 	call	0	; 0x0 <Thread_Sleep>
	Timer_SetCallback( pstTimer, ThreadSleepCallback );
  50:	60 e0       	ldi	r22, 0x00	; 0
  52:	70 e0       	ldi	r23, 0x00	; 0
  54:	c8 01       	movw	r24, r16
  56:	0e 94 00 00 	call	0	; 0x0 <Thread_Sleep>
	Timer_SetData( pstTimer, (void*)&clSemaphore );
  5a:	be 01       	movw	r22, r28
  5c:	6f 5f       	subi	r22, 0xFF	; 255
  5e:	7f 4f       	sbci	r23, 0xFF	; 255
  60:	c8 01       	movw	r24, r16
  62:	0e 94 00 00 	call	0	; 0x0 <Thread_Sleep>
	Timer_SetFlags( pstTimer, TIMERLIST_FLAG_ONE_SHOT );
  66:	61 e0       	ldi	r22, 0x01	; 1
  68:	c8 01       	movw	r24, r16
  6a:	0e 94 00 00 	call	0	; 0x0 <Thread_Sleep>
	
    // Add the new timer to the timer scheduler, and block the thread
    TimerScheduler_Add(pstTimer);
  6e:	c8 01       	movw	r24, r16
  70:	0e 94 00 00 	call	0	; 0x0 <Thread_Sleep>
	Semaphore_Pend( &clSemaphore );    
  74:	ce 01       	movw	r24, r28
  76:	01 96       	adiw	r24, 0x01	; 1
  78:	0e 94 00 00 	call	0	; 0x0 <Thread_Sleep>
}
  7c:	2b 96       	adiw	r28, 0x0b	; 11
  7e:	0f b6       	in	r0, 0x3f	; 63
  80:	f8 94       	cli
  82:	de bf       	out	0x3e, r29	; 62
  84:	0f be       	out	0x3f, r0	; 63
  86:	cd bf       	out	0x3d, r28	; 61
  88:	df 91       	pop	r29
  8a:	cf 91       	pop	r28
  8c:	1f 91       	pop	r17
  8e:	0f 91       	pop	r16
  90:	ff 90       	pop	r15
  92:	ef 90       	pop	r14
  94:	df 90       	pop	r13
  96:	cf 90       	pop	r12
  98:	08 95       	ret

Disassembly of section .text.Thread_USleep:

00000000 <Thread_USleep>:

//---------------------------------------------------------------------------
void Thread_USleep( K_ULONG ulTimeUs_)
{    
   0:	cf 92       	push	r12
   2:	df 92       	push	r13
   4:	ef 92       	push	r14
   6:	ff 92       	push	r15
   8:	0f 93       	push	r16
   a:	1f 93       	push	r17
   c:	cf 93       	push	r28
   e:	df 93       	push	r29
  10:	cd b7       	in	r28, 0x3d	; 61
  12:	de b7       	in	r29, 0x3e	; 62
  14:	2b 97       	sbiw	r28, 0x0b	; 11
  16:	0f b6       	in	r0, 0x3f	; 63
  18:	f8 94       	cli
  1a:	de bf       	out	0x3e, r29	; 62
  1c:	0f be       	out	0x3f, r0	; 63
  1e:	cd bf       	out	0x3d, r28	; 61
  20:	6b 01       	movw	r12, r22
  22:	7c 01       	movw	r14, r24
    Semaphore_t clSemaphore;
    Timer_t *pstTimer = Thread_GetTimer( g_pstCurrent );
  24:	00 91 00 00 	lds	r16, 0x0000
  28:	10 91 00 00 	lds	r17, 0x0000
  2c:	05 5e       	subi	r16, 0xE5	; 229
  2e:	1f 4f       	sbci	r17, 0xFF	; 255

    // Create a Semaphore_t that this thread will block on
    Semaphore_Init( &clSemaphore, 0, 1 );
  30:	41 e0       	ldi	r20, 0x01	; 1
  32:	50 e0       	ldi	r21, 0x00	; 0
  34:	60 e0       	ldi	r22, 0x00	; 0
  36:	70 e0       	ldi	r23, 0x00	; 0
  38:	ce 01       	movw	r24, r28
  3a:	01 96       	adiw	r24, 0x01	; 1
  3c:	0e 94 00 00 	call	0	; 0x0 <Thread_USleep>
        
    // Create a one-shot timer that will call a callback that posts the
    // Semaphore_t, waking our thread.
    Timer_Init( pstTimer );
  40:	c8 01       	movw	r24, r16
  42:	0e 94 00 00 	call	0	; 0x0 <Thread_USleep>
    Timer_SetIntervalUSeconds( pstTimer, ulTimeUs_ );
  46:	b7 01       	movw	r22, r14
  48:	a6 01       	movw	r20, r12
  4a:	c8 01       	movw	r24, r16
  4c:	0e 94 00 00 	call	0	; 0x0 <Thread_USleep>
    Timer_SetCallback( pstTimer, ThreadSleepCallback );
  50:	60 e0       	ldi	r22, 0x00	; 0
  52:	70 e0       	ldi	r23, 0x00	; 0
  54:	c8 01       	movw	r24, r16
  56:	0e 94 00 00 	call	0	; 0x0 <Thread_USleep>
    Timer_SetData( pstTimer, (void*)&clSemaphore );
  5a:	be 01       	movw	r22, r28
  5c:	6f 5f       	subi	r22, 0xFF	; 255
  5e:	7f 4f       	sbci	r23, 0xFF	; 255
  60:	c8 01       	movw	r24, r16
  62:	0e 94 00 00 	call	0	; 0x0 <Thread_USleep>
    Timer_SetFlags( pstTimer, TIMERLIST_FLAG_ONE_SHOT );
  66:	61 e0       	ldi	r22, 0x01	; 1
  68:	c8 01       	movw	r24, r16
  6a:	0e 94 00 00 	call	0	; 0x0 <Thread_USleep>
        
    // Add the new timer to the timer scheduler, and block the thread
    TimerScheduler_Add(pstTimer);
  6e:	c8 01       	movw	r24, r16
  70:	0e 94 00 00 	call	0	; 0x0 <Thread_USleep>
    Semaphore_Pend( &clSemaphore );
  74:	ce 01       	movw	r24, r28
  76:	01 96       	adiw	r24, 0x01	; 1
  78:	0e 94 00 00 	call	0	; 0x0 <Thread_USleep>
}
  7c:	2b 96       	adiw	r28, 0x0b	; 11
  7e:	0f b6       	in	r0, 0x3f	; 63
  80:	f8 94       	cli
  82:	de bf       	out	0x3e, r29	; 62
  84:	0f be       	out	0x3f, r0	; 63
  86:	cd bf       	out	0x3d, r28	; 61
  88:	df 91       	pop	r29
  8a:	cf 91       	pop	r28
  8c:	1f 91       	pop	r17
  8e:	0f 91       	pop	r16
  90:	ff 90       	pop	r15
  92:	ef 90       	pop	r14
  94:	df 90       	pop	r13
  96:	cf 90       	pop	r12
  98:	08 95       	ret

Disassembly of section .text.Thread_GetStackSlack:

00000000 <Thread_GetStackSlack>:
#endif // KERNEL_USE_SLEEP

//---------------------------------------------------------------------------
K_USHORT Thread_GetStackSlack( Thread_t *pstThread_ )
{
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	1f 92       	push	r1
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
   a:	dc 01       	movw	r26, r24
    K_USHORT usCount = 0;
    
    CS_ENTER();
   c:	8f b7       	in	r24, 0x3f	; 63
   e:	89 83       	std	Y+1, r24	; 0x01
  10:	f8 94       	cli
    
    //!! ToDo: Take into account stacks that grow up
    for (usCount = 0; usCount < pstThread_->m_usStackSize; usCount++)
  12:	1c 96       	adiw	r26, 0x0c	; 12
  14:	2d 91       	ld	r18, X+
  16:	3c 91       	ld	r19, X
  18:	1d 97       	sbiw	r26, 0x0d	; 13
  1a:	80 e0       	ldi	r24, 0x00	; 0
  1c:	90 e0       	ldi	r25, 0x00	; 0
  1e:	82 17       	cp	r24, r18
  20:	93 07       	cpc	r25, r19
  22:	01 f0       	breq	.+0      	; 0x24 <Thread_GetStackSlack+0x24>
    {
        if (pstThread_->m_pwStack[usCount] != 0xFF)
  24:	16 96       	adiw	r26, 0x06	; 6
  26:	ed 91       	ld	r30, X+
  28:	fc 91       	ld	r31, X
  2a:	17 97       	sbiw	r26, 0x07	; 7
  2c:	e8 0f       	add	r30, r24
  2e:	f9 1f       	adc	r31, r25
  30:	40 81       	ld	r20, Z
  32:	4f 3f       	cpi	r20, 0xFF	; 255
  34:	01 f0       	breq	.+0      	; 0x36 <Thread_GetStackSlack+0x36>
        {
            break;
        }
    }
    
    CS_EXIT();
  36:	29 81       	ldd	r18, Y+1	; 0x01
  38:	2f bf       	out	0x3f, r18	; 63
    
    return usCount;
}
  3a:	0f 90       	pop	r0
  3c:	df 91       	pop	r29
  3e:	cf 91       	pop	r28
  40:	08 95       	ret
    K_USHORT usCount = 0;
    
    CS_ENTER();
    
    //!! ToDo: Take into account stacks that grow up
    for (usCount = 0; usCount < pstThread_->m_usStackSize; usCount++)
  42:	01 96       	adiw	r24, 0x01	; 1
  44:	00 c0       	rjmp	.+0      	; 0x46 <__SREG__+0x7>

Disassembly of section .text.Thread_SetPriorityBase:

00000000 <Thread_SetPriorityBase>:
    CS_EXIT();
}

//---------------------------------------------------------------------------
void Thread_SetPriorityBase( Thread_t *pstThread_, K_UCHAR ucPriority_ )
{
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	ec 01       	movw	r28, r24
	 ThreadList_Remove( Thread_GetCurrent( pstThread_ ), pstThread_ );
   6:	bc 01       	movw	r22, r24
   8:	8e 85       	ldd	r24, Y+14	; 0x0e
   a:	9f 85       	ldd	r25, Y+15	; 0x0f
   c:	0e 94 00 00 	call	0	; 0x0 <Thread_SetPriorityBase>
	    
	 Thread_SetCurrent( pstThread_, Scheduler_GetThreadList(pstThread_->m_ucPriority) );
  10:	89 85       	ldd	r24, Y+9	; 0x09
  12:	0e 94 00 00 	call	0	; 0x0 <Thread_SetPriorityBase>
  16:	9f 87       	std	Y+15, r25	; 0x0f
  18:	8e 87       	std	Y+14, r24	; 0x0e
    
     ThreadList_Add( Thread_GetCurrent( pstThread_ ), pstThread_ );
  1a:	be 01       	movw	r22, r28
}
  1c:	df 91       	pop	r29
  1e:	cf 91       	pop	r28
{
	 ThreadList_Remove( Thread_GetCurrent( pstThread_ ), pstThread_ );
	    
	 Thread_SetCurrent( pstThread_, Scheduler_GetThreadList(pstThread_->m_ucPriority) );
    
     ThreadList_Add( Thread_GetCurrent( pstThread_ ), pstThread_ );
  20:	0c 94 00 00 	jmp	0	; 0x0 <Thread_SetPriorityBase>

Disassembly of section .text.Thread_InheritPriority:

00000000 <Thread_InheritPriority>:
    }
}

//---------------------------------------------------------------------------
void Thread_InheritPriority( Thread_t *pstThread_, K_UCHAR ucPriority_ )
{    
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17
   4:	cf 93       	push	r28
   6:	df 93       	push	r29
   8:	1f 92       	push	r1
   a:	cd b7       	in	r28, 0x3d	; 61
   c:	de b7       	in	r29, 0x3e	; 62
   e:	8c 01       	movw	r16, r24
    Thread_SetOwner(pstThread_, Scheduler_GetThreadList(ucPriority_));
  10:	86 2f       	mov	r24, r22
  12:	69 83       	std	Y+1, r22	; 0x01
  14:	0e 94 00 00 	call	0	; 0x0 <Thread_InheritPriority>
  18:	f8 01       	movw	r30, r16
  1a:	91 8b       	std	Z+17, r25	; 0x11
  1c:	80 8b       	std	Z+16, r24	; 0x10
    pstThread_->m_ucCurPriority = ucPriority_;
  1e:	69 81       	ldd	r22, Y+1	; 0x01
  20:	62 87       	std	Z+10, r22	; 0x0a
}
  22:	0f 90       	pop	r0
  24:	df 91       	pop	r29
  26:	cf 91       	pop	r28
  28:	1f 91       	pop	r17
  2a:	0f 91       	pop	r16
  2c:	08 95       	ret

Disassembly of section .text.Thread_ContextSwitchSWI:

00000000 <Thread_ContextSwitchSWI>:

//---------------------------------------------------------------------------
void Thread_ContextSwitchSWI( void )
{
    // Call the context switch interrupt if the scheduler is enabled.
    if (Scheduler_IsEnabled() == 1)
   0:	80 91 00 00 	lds	r24, 0x0000
   4:	81 11       	cpse	r24, r1
    {        
        KERNEL_TRACE_1( STR_CONTEXT_SWITCH_1, (K_USHORT)Thread_GetID( (Thread_t*)g_pstNext ) );
        KernelSWI_Trigger();
   6:	0c 94 00 00 	jmp	0	; 0x0 <Thread_ContextSwitchSWI>
   a:	08 95       	ret

Disassembly of section .text.Thread_Yield:

00000000 <Thread_Yield>:
    return usCount;
}

//---------------------------------------------------------------------------
void Thread_Yield( void )
{
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	1f 92       	push	r1
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
    CS_ENTER();
   a:	8f b7       	in	r24, 0x3f	; 63
   c:	89 83       	std	Y+1, r24	; 0x01
   e:	f8 94       	cli
    // Run the scheduler
    if (Scheduler_IsEnabled())
  10:	80 91 00 00 	lds	r24, 0x0000
  14:	88 23       	and	r24, r24
  16:	01 f0       	breq	.+0      	; 0x18 <Thread_Yield+0x18>
    {
        Scheduler_Schedule();
  18:	0e 94 00 00 	call	0	; 0x0 <Thread_Yield>

        // Only switch contexts if the new task is different than the old task
        if (Scheduler_GetCurrentThread() != Scheduler_GetNextThread())
  1c:	20 91 00 00 	lds	r18, 0x0000
  20:	30 91 00 00 	lds	r19, 0x0000
  24:	80 91 00 00 	lds	r24, 0x0000
  28:	90 91 00 00 	lds	r25, 0x0000
  2c:	28 17       	cp	r18, r24
  2e:	39 07       	cpc	r19, r25
  30:	01 f0       	breq	.+0      	; 0x32 <Thread_Yield+0x32>
        {
#if KERNEL_USE_QUANTUM
            // new thread scheduled.  Stop current quantum timer (if it exists),
            // and restart it for the new thread (if required).
            Quantum_RemoveThread();
  32:	0e 94 00 00 	call	0	; 0x0 <Thread_Yield>
            Quantum_AddThread((Thread_t*)g_pstNext);
  36:	80 91 00 00 	lds	r24, 0x0000
  3a:	90 91 00 00 	lds	r25, 0x0000
  3e:	0e 94 00 00 	call	0	; 0x0 <Thread_Yield>
#endif
            Thread_ContextSwitchSWI();
  42:	0e 94 00 00 	call	0	; 0x0 <Thread_Yield>
  46:	00 c0       	rjmp	.+0      	; 0x48 <Thread_Yield+0x48>
        }
    }
    else
    {
        Scheduler_QueueScheduler();
  48:	0e 94 00 00 	call	0	; 0x0 <Thread_Yield>
    }

    CS_EXIT();
  4c:	89 81       	ldd	r24, Y+1	; 0x01
  4e:	8f bf       	out	0x3f, r24	; 63
}
  50:	0f 90       	pop	r0
  52:	df 91       	pop	r29
  54:	cf 91       	pop	r28
  56:	08 95       	ret

Disassembly of section .text.Thread_Start:

00000000 <Thread_Start>:
	CS_EXIT();
}

//---------------------------------------------------------------------------
void Thread_Start( Thread_t *pstThread_ )
{
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17
   4:	cf 93       	push	r28
   6:	df 93       	push	r29
   8:	1f 92       	push	r1
   a:	cd b7       	in	r28, 0x3d	; 61
   c:	de b7       	in	r29, 0x3e	; 62
   e:	8c 01       	movw	r16, r24
    // Remove the thread from the scheduler's "stopped" list, and add it 
    // to the scheduler's ready list at the proper priority.
    KERNEL_TRACE_1( STR_THREAD_START_1, (K_USHORT)pstThread_->m_ucThreadID );
    
    CS_ENTER();
  10:	8f b7       	in	r24, 0x3f	; 63
  12:	89 83       	std	Y+1, r24	; 0x01
  14:	f8 94       	cli
    ThreadList_Remove( Scheduler_GetStopList(), pstThread_ );
  16:	0e 94 00 00 	call	0	; 0x0 <Thread_Start>
  1a:	b8 01       	movw	r22, r16
  1c:	0e 94 00 00 	call	0	; 0x0 <Thread_Start>
    Scheduler_Add(pstThread_);
  20:	c8 01       	movw	r24, r16
  22:	0e 94 00 00 	call	0	; 0x0 <Thread_Start>
    pstThread_->m_pstOwner = Scheduler_GetThreadList(pstThread_->m_ucPriority);
  26:	d8 01       	movw	r26, r16
  28:	19 96       	adiw	r26, 0x09	; 9
  2a:	8c 91       	ld	r24, X
  2c:	0e 94 00 00 	call	0	; 0x0 <Thread_Start>
  30:	f8 01       	movw	r30, r16
  32:	91 8b       	std	Z+17, r25	; 0x11
  34:	80 8b       	std	Z+16, r24	; 0x10
    pstThread_->m_pstCurrent = pstThread_->m_pstOwner;
  36:	97 87       	std	Z+15, r25	; 0x0f
  38:	86 87       	std	Z+14, r24	; 0x0e
    pstThread_->m_eState = THREAD_STATE_READY;
  3a:	81 e0       	ldi	r24, 0x01	; 1
  3c:	83 87       	std	Z+11, r24	; 0x0b

#if KERNEL_USE_QUANTUM
    if ( Thread_GetCurPriority( pstThread_ ) >= 
		 Thread_GetCurPriority( Scheduler_GetCurrentThread() ) )
  3e:	e0 91 00 00 	lds	r30, 0x0000
  42:	f0 91 00 00 	lds	r31, 0x0000
    pstThread_->m_pstOwner = Scheduler_GetThreadList(pstThread_->m_ucPriority);
    pstThread_->m_pstCurrent = pstThread_->m_pstOwner;
    pstThread_->m_eState = THREAD_STATE_READY;

#if KERNEL_USE_QUANTUM
    if ( Thread_GetCurPriority( pstThread_ ) >= 
  46:	d8 01       	movw	r26, r16
  48:	1a 96       	adiw	r26, 0x0a	; 10
  4a:	9c 91       	ld	r25, X
  4c:	82 85       	ldd	r24, Z+10	; 0x0a
  4e:	98 17       	cp	r25, r24
  50:	00 f0       	brcs	.+0      	; 0x52 <Thread_Start+0x52>
		 Thread_GetCurPriority( Scheduler_GetCurrentThread() ) )
    {
        // Deal with the thread Quantum
        Quantum_RemoveThread();
  52:	0e 94 00 00 	call	0	; 0x0 <Thread_Start>
        Quantum_AddThread(pstThread_);
  56:	c8 01       	movw	r24, r16
  58:	0e 94 00 00 	call	0	; 0x0 <Thread_Start>
    }
#endif

    if (Kernel_IsStarted())
  5c:	0e 94 00 00 	call	0	; 0x0 <Thread_Start>
  60:	88 23       	and	r24, r24
  62:	01 f0       	breq	.+0      	; 0x64 <Thread_Start+0x64>
    {
        if ( Thread_GetCurPriority( pstThread_ ) >= 
			 Thread_GetCurPriority( Scheduler_GetCurrentThread() ) )
  64:	e0 91 00 00 	lds	r30, 0x0000
  68:	f0 91 00 00 	lds	r31, 0x0000
    }
#endif

    if (Kernel_IsStarted())
    {
        if ( Thread_GetCurPriority( pstThread_ ) >= 
  6c:	d8 01       	movw	r26, r16
  6e:	1a 96       	adiw	r26, 0x0a	; 10
  70:	9c 91       	ld	r25, X
  72:	82 85       	ldd	r24, Z+10	; 0x0a
  74:	98 17       	cp	r25, r24
  76:	00 f0       	brcs	.+0      	; 0x78 <Thread_Start+0x78>
			 Thread_GetCurPriority( Scheduler_GetCurrentThread() ) )
        {
            Thread_Yield();
  78:	0e 94 00 00 	call	0	; 0x0 <Thread_Start>
        }
    }
    CS_EXIT();
  7c:	89 81       	ldd	r24, Y+1	; 0x01
  7e:	8f bf       	out	0x3f, r24	; 63
}
  80:	0f 90       	pop	r0
  82:	df 91       	pop	r29
  84:	cf 91       	pop	r28
  86:	1f 91       	pop	r17
  88:	0f 91       	pop	r16
  8a:	08 95       	ret

Disassembly of section .text.Thread_Stop:

00000000 <Thread_Stop>:

//---------------------------------------------------------------------------
void Thread_Stop( Thread_t *pstThread_ )
{
   0:	ef 92       	push	r14
   2:	ff 92       	push	r15
   4:	0f 93       	push	r16
   6:	1f 93       	push	r17
   8:	cf 93       	push	r28
   a:	df 93       	push	r29
   c:	1f 92       	push	r1
   e:	cd b7       	in	r28, 0x3d	; 61
  10:	de b7       	in	r29, 0x3e	; 62
  12:	8c 01       	movw	r16, r24
    K_BOOL bReschedule = 0;

    CS_ENTER();
  14:	8f b7       	in	r24, 0x3f	; 63
  16:	89 83       	std	Y+1, r24	; 0x01
  18:	f8 94       	cli

    // If a thread is attempting to stop itself, ensure we call the scheduler
    if (pstThread_ == Scheduler_GetCurrentThread())
  1a:	e0 90 00 00 	lds	r14, 0x0000
  1e:	f0 90 00 00 	lds	r15, 0x0000
        bReschedule = true;
    }

    // Add this thread to the stop-list (removing it from active scheduling)
    // Remove the thread from scheduling
    if (pstThread_->m_eState == THREAD_STATE_READY)
  22:	f8 01       	movw	r30, r16
  24:	83 85       	ldd	r24, Z+11	; 0x0b
  26:	81 30       	cpi	r24, 0x01	; 1
  28:	01 f4       	brne	.+0      	; 0x2a <Thread_Stop+0x2a>
    {
        Scheduler_Remove(pstThread_);
  2a:	c8 01       	movw	r24, r16
  2c:	0e 94 00 00 	call	0	; 0x0 <Thread_Stop>
  30:	00 c0       	rjmp	.+0      	; 0x32 <Thread_Stop+0x32>
    }
    else if (pstThread_->m_eState == THREAD_STATE_BLOCKED)
  32:	82 30       	cpi	r24, 0x02	; 2
  34:	01 f4       	brne	.+0      	; 0x36 <Thread_Stop+0x36>
    {
		ThreadList_Remove( pstThread_->m_pstCurrent, pstThread_ );        
  36:	b8 01       	movw	r22, r16
  38:	f8 01       	movw	r30, r16
  3a:	86 85       	ldd	r24, Z+14	; 0x0e
  3c:	97 85       	ldd	r25, Z+15	; 0x0f
  3e:	0e 94 00 00 	call	0	; 0x0 <Thread_Stop>
    }

    pstThread_->m_pstOwner = Scheduler_GetStopList();
  42:	0e 94 00 00 	call	0	; 0x0 <Thread_Stop>
  46:	f8 01       	movw	r30, r16
  48:	91 8b       	std	Z+17, r25	; 0x11
  4a:	80 8b       	std	Z+16, r24	; 0x10
    pstThread_->m_pstCurrent = pstThread_->m_pstOwner;
  4c:	97 87       	std	Z+15, r25	; 0x0f
  4e:	86 87       	std	Z+14, r24	; 0x0e
	ThreadList_Add( pstThread_->m_pstOwner, pstThread_ );
  50:	b8 01       	movw	r22, r16
  52:	0e 94 00 00 	call	0	; 0x0 <Thread_Stop>
    
    pstThread_->m_eState = THREAD_STATE_STOP;
  56:	83 e0       	ldi	r24, 0x03	; 3
  58:	f8 01       	movw	r30, r16
  5a:	83 87       	std	Z+11, r24	; 0x0b

#if KERNEL_USE_TIMERS
    // Just to be safe - attempt to remove the thread's timer
    // from the timer-scheduler (does no harm if it isn't
    // in the timer-list)
    TimerScheduler_Remove(&pstThread_->m_clTimer);
  5c:	c8 01       	movw	r24, r16
  5e:	4b 96       	adiw	r24, 0x1b	; 27
  60:	0e 94 00 00 	call	0	; 0x0 <Thread_Stop>
#endif

    CS_EXIT();
  64:	89 81       	ldd	r24, Y+1	; 0x01
  66:	8f bf       	out	0x3f, r24	; 63

    if (bReschedule)
  68:	0e 15       	cp	r16, r14
  6a:	1f 05       	cpc	r17, r15
  6c:	01 f4       	brne	.+0      	; 0x6e <Thread_Stop+0x6e>
    {
        Thread_Yield();
  6e:	0e 94 00 00 	call	0	; 0x0 <Thread_Stop>
    }
}
  72:	0f 90       	pop	r0
  74:	df 91       	pop	r29
  76:	cf 91       	pop	r28
  78:	1f 91       	pop	r17
  7a:	0f 91       	pop	r16
  7c:	ff 90       	pop	r15
  7e:	ef 90       	pop	r14
  80:	08 95       	ret

Disassembly of section .text.Thread_Exit:

00000000 <Thread_Exit>:

#if KERNEL_USE_DYNAMIC_THREADS
//---------------------------------------------------------------------------
void Thread_Exit( Thread_t *pstThread_ )
{
   0:	ef 92       	push	r14
   2:	ff 92       	push	r15
   4:	0f 93       	push	r16
   6:	1f 93       	push	r17
   8:	cf 93       	push	r28
   a:	df 93       	push	r29
   c:	1f 92       	push	r1
   e:	cd b7       	in	r28, 0x3d	; 61
  10:	de b7       	in	r29, 0x3e	; 62
  12:	8c 01       	movw	r16, r24
    K_BOOL bReschedule = 0;
    
    KERNEL_TRACE_1( STR_THREAD_EXIT_1, pstThread_->m_ucThreadID );
    
    CS_ENTER();
  14:	8f b7       	in	r24, 0x3f	; 63
  16:	89 83       	std	Y+1, r24	; 0x01
  18:	f8 94       	cli
    
    // If this thread is the actively-running thread, make sure we run the
    // scheduler again.
    if (pstThread_ == Scheduler_GetCurrentThread())
  1a:	e0 90 00 00 	lds	r14, 0x0000
  1e:	f0 90 00 00 	lds	r15, 0x0000
    {
        bReschedule = 1;            
    }
    
    // Remove the thread from scheduling
    if (pstThread_->m_eState == THREAD_STATE_READY)
  22:	f8 01       	movw	r30, r16
  24:	83 85       	ldd	r24, Z+11	; 0x0b
  26:	81 30       	cpi	r24, 0x01	; 1
  28:	01 f4       	brne	.+0      	; 0x2a <Thread_Exit+0x2a>
    {
        Scheduler_Remove(pstThread_);
  2a:	c8 01       	movw	r24, r16
  2c:	0e 94 00 00 	call	0	; 0x0 <Thread_Exit>
  30:	00 c0       	rjmp	.+0      	; 0x32 <Thread_Exit+0x32>
    }
    else if (pstThread_->m_eState == THREAD_STATE_BLOCKED)
  32:	82 30       	cpi	r24, 0x02	; 2
  34:	01 f4       	brne	.+0      	; 0x36 <Thread_Exit+0x36>
    {
		ThreadList_Remove( pstThread_->m_pstCurrent, pstThread_ );
  36:	b8 01       	movw	r22, r16
  38:	f8 01       	movw	r30, r16
  3a:	86 85       	ldd	r24, Z+14	; 0x0e
  3c:	97 85       	ldd	r25, Z+15	; 0x0f
  3e:	0e 94 00 00 	call	0	; 0x0 <Thread_Exit>
    }

    pstThread_->m_pstCurrent = 0;
  42:	f8 01       	movw	r30, r16
  44:	17 86       	std	Z+15, r1	; 0x0f
  46:	16 86       	std	Z+14, r1	; 0x0e
    pstThread_->m_pstOwner = 0;
  48:	11 8a       	std	Z+17, r1	; 0x11
  4a:	10 8a       	std	Z+16, r1	; 0x10
    pstThread_->m_eState = THREAD_STATE_EXIT;
  4c:	13 86       	std	Z+11, r1	; 0x0b
    // We've removed the thread from scheduling, but interrupts might
    // trigger checks against this thread's currently priority before
    // we get around to scheduling new threads.  As a result, set the
    // priority to idle to ensure that we always wind up scheduling
    // new threads.
    pstThread_->m_ucCurPriority = 0;
  4e:	12 86       	std	Z+10, r1	; 0x0a
    pstThread_->m_ucPriority = 0;
  50:	11 86       	std	Z+9, r1	; 0x09

#if KERNEL_USE_TIMERS
    // Just to be safe - attempt to remove the thread's timer
    // from the timer-scheduler (does no harm if it isn't
    // in the timer-list)
    TimerScheduler_Remove(&pstThread_->m_clTimer);
  52:	c8 01       	movw	r24, r16
  54:	4b 96       	adiw	r24, 0x1b	; 27
  56:	0e 94 00 00 	call	0	; 0x0 <Thread_Exit>
#endif

    CS_EXIT();
  5a:	89 81       	ldd	r24, Y+1	; 0x01
  5c:	8f bf       	out	0x3f, r24	; 63
    
    if (bReschedule) 
  5e:	0e 15       	cp	r16, r14
  60:	1f 05       	cpc	r17, r15
  62:	01 f4       	brne	.+0      	; 0x64 <Thread_Exit+0x64>
    {
        // Choose a new "next" thread if we must
        Thread_Yield();
  64:	0e 94 00 00 	call	0	; 0x0 <Thread_Exit>
    }
}
  68:	0f 90       	pop	r0
  6a:	df 91       	pop	r29
  6c:	cf 91       	pop	r28
  6e:	1f 91       	pop	r17
  70:	0f 91       	pop	r16
  72:	ff 90       	pop	r15
  74:	ef 90       	pop	r14
  76:	08 95       	ret

Disassembly of section .text.Thread_SetPriority:

00000000 <Thread_SetPriority>:
     ThreadList_Add( Thread_GetCurrent( pstThread_ ), pstThread_ );
}

//---------------------------------------------------------------------------
void Thread_SetPriority( Thread_t *pstThread_, K_UCHAR ucPriority_ )
{
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17
   4:	cf 93       	push	r28
   6:	df 93       	push	r29
   8:	00 d0       	rcall	.+0      	; 0xa <Thread_SetPriority+0xa>
   a:	00 d0       	rcall	.+0      	; 0xc <Thread_SetPriority+0xc>
   c:	1f 92       	push	r1
   e:	cd b7       	in	r28, 0x3d	; 61
  10:	de b7       	in	r29, 0x3e	; 62
  12:	8c 01       	movw	r16, r24
    K_BOOL bSchedule = 0;

    CS_ENTER();
  14:	8f b7       	in	r24, 0x3f	; 63
  16:	8b 83       	std	Y+3, r24	; 0x03
  18:	f8 94       	cli
    // If this is the currently running thread, it's a good idea to reschedule
    // Or, if the new priority is a higher priority than the current thread's.
    if ((g_pstCurrent == pstThread_) || (ucPriority_ > Thread_GetPriority( g_pstCurrent )) )
  1a:	e0 91 00 00 	lds	r30, 0x0000
  1e:	f0 91 00 00 	lds	r31, 0x0000
    {
        bSchedule = 1;
  22:	21 e0       	ldi	r18, 0x01	; 1
    K_BOOL bSchedule = 0;

    CS_ENTER();
    // If this is the currently running thread, it's a good idea to reschedule
    // Or, if the new priority is a higher priority than the current thread's.
    if ((g_pstCurrent == pstThread_) || (ucPriority_ > Thread_GetPriority( g_pstCurrent )) )
  24:	e0 17       	cp	r30, r16
  26:	f1 07       	cpc	r31, r17
  28:	01 f0       	breq	.+0      	; 0x2a <Thread_SetPriority+0x2a>
  2a:	81 85       	ldd	r24, Z+9	; 0x09
  2c:	86 17       	cp	r24, r22
  2e:	00 f0       	brcs	.+0      	; 0x30 <Thread_SetPriority+0x30>
  30:	20 e0       	ldi	r18, 0x00	; 0
    {
        bSchedule = 1;
    }
    Scheduler_Remove(pstThread_);
  32:	c8 01       	movw	r24, r16
  34:	2d 83       	std	Y+5, r18	; 0x05
  36:	6c 83       	std	Y+4, r22	; 0x04
  38:	0e 94 00 00 	call	0	; 0x0 <Thread_SetPriority>
    CS_EXIT();
  3c:	8b 81       	ldd	r24, Y+3	; 0x03
  3e:	8f bf       	out	0x3f, r24	; 63

    pstThread_->m_ucCurPriority = ucPriority_;
  40:	6c 81       	ldd	r22, Y+4	; 0x04
  42:	f8 01       	movw	r30, r16
  44:	62 87       	std	Z+10, r22	; 0x0a
    pstThread_->m_ucPriority = ucPriority_;
  46:	61 87       	std	Z+9, r22	; 0x09
    
    CS_ENTER();    
  48:	8f b7       	in	r24, 0x3f	; 63
  4a:	8a 83       	std	Y+2, r24	; 0x02
  4c:	f8 94       	cli
    Scheduler_Add(pstThread_);
  4e:	c8 01       	movw	r24, r16
  50:	0e 94 00 00 	call	0	; 0x0 <Thread_SetPriority>
    CS_EXIT();
  54:	8a 81       	ldd	r24, Y+2	; 0x02
  56:	8f bf       	out	0x3f, r24	; 63
    
    if (bSchedule)
  58:	2d 81       	ldd	r18, Y+5	; 0x05
  5a:	22 23       	and	r18, r18
  5c:	01 f0       	breq	.+0      	; 0x5e <Thread_SetPriority+0x5e>
    {
        if (Scheduler_IsEnabled())
  5e:	80 91 00 00 	lds	r24, 0x0000
  62:	88 23       	and	r24, r24
  64:	01 f0       	breq	.+0      	; 0x66 <Thread_SetPriority+0x66>
        {
            CS_ENTER();
  66:	8f b7       	in	r24, 0x3f	; 63
  68:	89 83       	std	Y+1, r24	; 0x01
  6a:	f8 94       	cli
            Scheduler_Schedule();
  6c:	0e 94 00 00 	call	0	; 0x0 <Thread_SetPriority>
    #if KERNEL_USE_QUANTUM
            // new thread scheduled.  Stop current quantum timer (if it exists),
            // and restart it for the new thread (if required).
            Quantum_RemoveThread();
  70:	0e 94 00 00 	call	0	; 0x0 <Thread_SetPriority>
            Quantum_AddThread((Thread_t*)g_pstNext);
  74:	80 91 00 00 	lds	r24, 0x0000
  78:	90 91 00 00 	lds	r25, 0x0000
  7c:	0e 94 00 00 	call	0	; 0x0 <Thread_SetPriority>
    #endif
            CS_EXIT();
  80:	89 81       	ldd	r24, Y+1	; 0x01
  82:	8f bf       	out	0x3f, r24	; 63
            Thread_ContextSwitchSWI();
  84:	0e 94 00 00 	call	0	; 0x0 <Thread_SetPriority>
  88:	00 c0       	rjmp	.+0      	; 0x8a <Thread_SetPriority+0x8a>
        }
        else
        {
            Scheduler_QueueScheduler();
  8a:	0e 94 00 00 	call	0	; 0x0 <Thread_SetPriority>
        }
    }
}
  8e:	0f 90       	pop	r0
  90:	0f 90       	pop	r0
  92:	0f 90       	pop	r0
  94:	0f 90       	pop	r0
  96:	0f 90       	pop	r0
  98:	df 91       	pop	r29
  9a:	cf 91       	pop	r28
  9c:	1f 91       	pop	r17
  9e:	0f 91       	pop	r16
  a0:	08 95       	ret

Disassembly of section .text.Thread_InitIdle:

00000000 <Thread_InitIdle>:
}

#if KERNEL_USE_IDLE_FUNC
//---------------------------------------------------------------------------
void Thread_InitIdle( Thread_t *pstThread_ )
{
   0:	fc 01       	movw	r30, r24
    LinkListNode_Clear( (LinkListNode_t*)pstThread_ );
   2:	11 82       	std	Z+1, r1	; 0x01
   4:	10 82       	st	Z, r1
   6:	13 82       	std	Z+3, r1	; 0x03
   8:	12 82       	std	Z+2, r1	; 0x02

    pstThread_->m_ucPriority = 0;
   a:	11 86       	std	Z+9, r1	; 0x09
    pstThread_->m_ucCurPriority = 0;
   c:	12 86       	std	Z+10, r1	; 0x0a
    pstThread_->m_pfEntryPoint = 0;
   e:	13 8a       	std	Z+19, r1	; 0x13
  10:	12 8a       	std	Z+18, r1	; 0x12
    pstThread_->m_pvArg = 0;
  12:	15 8a       	std	Z+21, r1	; 0x15
  14:	14 8a       	std	Z+20, r1	; 0x14
    pstThread_->m_ucThreadID = 255;
  16:	8f ef       	ldi	r24, 0xFF	; 255
  18:	80 87       	std	Z+8, r24	; 0x08
    pstThread_->m_eState = THREAD_STATE_READY;
  1a:	81 e0       	ldi	r24, 0x01	; 1
  1c:	83 87       	std	Z+11, r24	; 0x0b
  1e:	08 95       	ret

threadlist.c.o:     file format elf32-avr


Disassembly of section .text.ThreadList_Init:

00000000 <ThreadList_Init>:
#endif
#define __FILE_ID__ 	THREADLIST_CPP       //!< File ID used in kernel trace calls

//---------------------------------------------------------------------------
void ThreadList_Init( ThreadList_t *pstList_ )
{ 
   0:	fc 01       	movw	r30, r24
	CircularLinkList_Init( (CircularLinkList_t*)pstList_ );
   2:	11 82       	std	Z+1, r1	; 0x01
   4:	10 82       	st	Z, r1
   6:	13 82       	std	Z+3, r1	; 0x03
   8:	12 82       	std	Z+2, r1	; 0x02
	pstList_->m_ucPriority = 0; 
   a:	14 82       	std	Z+4, r1	; 0x04
	pstList_->m_pucFlag = NULL; 
   c:	16 82       	std	Z+6, r1	; 0x06
   e:	15 82       	std	Z+5, r1	; 0x05
  10:	08 95       	ret

Disassembly of section .text.ThreadList_SetPriority:

00000000 <ThreadList_SetPriority>:
}

//---------------------------------------------------------------------------
void ThreadList_SetPriority( ThreadList_t *pstList_, K_UCHAR ucPriority_ )
{
    pstList_->m_ucPriority = ucPriority_;
   0:	fc 01       	movw	r30, r24
   2:	64 83       	std	Z+4, r22	; 0x04
   4:	08 95       	ret

Disassembly of section .text.ThreadList_SetFlagPointer:

00000000 <ThreadList_SetFlagPointer>:
}

//---------------------------------------------------------------------------
void ThreadList_SetFlagPointer( ThreadList_t *pstList_, K_UCHAR *pucFlag_)
{
    pstList_->m_pucFlag = pucFlag_;
   0:	fc 01       	movw	r30, r24
   2:	76 83       	std	Z+6, r23	; 0x06
   4:	65 83       	std	Z+5, r22	; 0x05
   6:	08 95       	ret

Disassembly of section .text.ThreadList_Add:

00000000 <ThreadList_Add>:
}

//---------------------------------------------------------------------------
void ThreadList_Add( ThreadList_t *pstList_, Thread_t *node_ ) 
{
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	ec 01       	movw	r28, r24
    CircularLinkList_t *pstCLL = (CircularLinkList_t*)pstList_;
	CircularLinkList_Add( pstCLL, (LinkListNode_t*)node_);
   6:	0e 94 00 00 	call	0	; 0x0 <ThreadList_Add>
    CircularLinkList_PivotForward( pstCLL );
   a:	ce 01       	movw	r24, r28
   c:	0e 94 00 00 	call	0	; 0x0 <ThreadList_Add>
    
    // We've specified a bitmap for this threadlist
    if (pstList_->m_pucFlag)
  10:	ed 81       	ldd	r30, Y+5	; 0x05
  12:	fe 81       	ldd	r31, Y+6	; 0x06
  14:	30 97       	sbiw	r30, 0x00	; 0
  16:	01 f0       	breq	.+0      	; 0x18 <ThreadList_Add+0x18>
    {
        // Set the flag for this priority level
        *pstList_->m_pucFlag |= (1 << pstList_->m_ucPriority);
  18:	81 e0       	ldi	r24, 0x01	; 1
  1a:	90 e0       	ldi	r25, 0x00	; 0
  1c:	0c 80       	ldd	r0, Y+4	; 0x04
  1e:	00 c0       	rjmp	.+0      	; 0x20 <ThreadList_Add+0x20>
  20:	88 0f       	add	r24, r24
  22:	99 1f       	adc	r25, r25
  24:	0a 94       	dec	r0
  26:	02 f4       	brpl	.+0      	; 0x28 <ThreadList_Add+0x28>
  28:	90 81       	ld	r25, Z
  2a:	98 2b       	or	r25, r24
  2c:	90 83       	st	Z, r25
    }
}
  2e:	df 91       	pop	r29
  30:	cf 91       	pop	r28
  32:	08 95       	ret

Disassembly of section .text.ThreadList_AddEx:

00000000 <ThreadList_AddEx>:
}

//---------------------------------------------------------------------------
void ThreadList_SetPriority( ThreadList_t *pstList_, K_UCHAR ucPriority_ )
{
    pstList_->m_ucPriority = ucPriority_;
   0:	fc 01       	movw	r30, r24
   2:	24 83       	std	Z+4, r18	; 0x04
}

//---------------------------------------------------------------------------
void ThreadList_SetFlagPointer( ThreadList_t *pstList_, K_UCHAR *pucFlag_)
{
    pstList_->m_pucFlag = pucFlag_;
   4:	56 83       	std	Z+6, r21	; 0x06
   6:	45 83       	std	Z+5, r20	; 0x05
void ThreadList_AddEx( ThreadList_t *pstList_, Thread_t *node_, K_UCHAR *pucFlag_, K_UCHAR ucPriority_) {
    // Set the threadlist's priority level, flag pointer, and then add the
    // thread to the threadlist
    ThreadList_SetPriority( pstList_, ucPriority_ );
    ThreadList_SetFlagPointer( pstList_, pucFlag_ );
    ThreadList_Add( pstList_, node_);
   8:	0c 94 00 00 	jmp	0	; 0x0 <ThreadList_AddEx>

Disassembly of section .text.ThreadList_Remove:

00000000 <ThreadList_Remove>:
}

//---------------------------------------------------------------------------
void ThreadList_Remove( ThreadList_t *pstList_, Thread_t *node_) {
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	ec 01       	movw	r28, r24
    // Remove the thread from the list
	CircularLinkList_t *pstCLL = (CircularLinkList_t*)pstList_;
    CircularLinkList_Remove( pstCLL, (LinkListNode_t*)node_);
   6:	0e 94 00 00 	call	0	; 0x0 <ThreadList_Remove>
    
    // If the list is empty...
    if (!pstCLL->m_pstHead)
   a:	88 81       	ld	r24, Y
   c:	99 81       	ldd	r25, Y+1	; 0x01
   e:	89 2b       	or	r24, r25
  10:	01 f4       	brne	.+0      	; 0x12 <ThreadList_Remove+0x12>
    {
        // Clear the bit in the bitmap at this priority level
        if (pstList_->m_pucFlag)
  12:	ed 81       	ldd	r30, Y+5	; 0x05
  14:	fe 81       	ldd	r31, Y+6	; 0x06
  16:	30 97       	sbiw	r30, 0x00	; 0
  18:	01 f0       	breq	.+0      	; 0x1a <ThreadList_Remove+0x1a>
        {
            *pstList_->m_pucFlag &= ~(1 << pstList_->m_ucPriority);
  1a:	81 e0       	ldi	r24, 0x01	; 1
  1c:	90 e0       	ldi	r25, 0x00	; 0
  1e:	0c 80       	ldd	r0, Y+4	; 0x04
  20:	00 c0       	rjmp	.+0      	; 0x22 <ThreadList_Remove+0x22>
  22:	88 0f       	add	r24, r24
  24:	99 1f       	adc	r25, r25
  26:	0a 94       	dec	r0
  28:	02 f4       	brpl	.+0      	; 0x2a <ThreadList_Remove+0x2a>
  2a:	80 95       	com	r24
  2c:	90 81       	ld	r25, Z
  2e:	98 23       	and	r25, r24
  30:	90 83       	st	Z, r25
        }
    }
}
  32:	df 91       	pop	r29
  34:	cf 91       	pop	r28
  36:	08 95       	ret

Disassembly of section .text.ThreadList_HighestWaiter:

00000000 <ThreadList_HighestWaiter>:

//---------------------------------------------------------------------------
Thread_t *ThreadList_HighestWaiter( ThreadList_t *pstList_ )
{
    Thread_t *pstTemp = (Thread_t*)LinkList_GetHead( (LinkList_t*)pstList_ );
   0:	dc 01       	movw	r26, r24
   2:	ed 91       	ld	r30, X+
   4:	fc 91       	ld	r31, X
   6:	11 97       	sbiw	r26, 0x01	; 1
            ucMaxPri = Thread_GetPriority( pstTemp );
            pstChosen = pstTemp;
		}
        
        // Break out if this is the last thread in the list
        if (pstTemp == (Thread_t*)LinkList_GetTail( (LinkList_t*)pstList_ ) )
   8:	12 96       	adiw	r26, 0x02	; 2
   a:	2d 91       	ld	r18, X+
   c:	3c 91       	ld	r19, X
   e:	13 97       	sbiw	r26, 0x03	; 3

//---------------------------------------------------------------------------
Thread_t *ThreadList_HighestWaiter( ThreadList_t *pstList_ )
{
    Thread_t *pstTemp = (Thread_t*)LinkList_GetHead( (LinkList_t*)pstList_ );
    Thread_t *pstChosen = pstTemp;
  10:	cf 01       	movw	r24, r30
	
	K_UCHAR ucMaxPri = 0;
  12:	40 e0       	ldi	r20, 0x00	; 0
    
    // Go through the list, return the highest-priority thread in this list.
	while(1)
	{
        // Compare against current max-priority thread
        if (Thread_GetPriority( pstTemp ) >= ucMaxPri)
  14:	51 85       	ldd	r21, Z+9	; 0x09
  16:	54 17       	cp	r21, r20
  18:	00 f4       	brcc	.+0      	; 0x1a <ThreadList_HighestWaiter+0x1a>
  1a:	54 2f       	mov	r21, r20
  1c:	00 c0       	rjmp	.+0      	; 0x1e <ThreadList_HighestWaiter+0x1e>
  1e:	cf 01       	movw	r24, r30
            ucMaxPri = Thread_GetPriority( pstTemp );
            pstChosen = pstTemp;
		}
        
        // Break out if this is the last thread in the list
        if (pstTemp == (Thread_t*)LinkList_GetTail( (LinkList_t*)pstList_ ) )
  20:	e2 17       	cp	r30, r18
  22:	f3 07       	cpc	r31, r19
  24:	01 f0       	breq	.+0      	; 0x26 <ThreadList_HighestWaiter+0x26>
		{
			break;
		}
        
        pstTemp = (Thread_t*)LinkListNode_GetNext( (LinkListNode_t*)pstTemp );
  26:	01 90       	ld	r0, Z+
  28:	f0 81       	ld	r31, Z
  2a:	e0 2d       	mov	r30, r0
	} 
  2c:	45 2f       	mov	r20, r21
  2e:	00 c0       	rjmp	.+0      	; 0x30 <ThreadList_HighestWaiter+0x30>
    return pstChosen;
}
  30:	08 95       	ret

kernel.c.o:     file format elf32-avr


Disassembly of section .text.Kernel_Init:

00000000 <Kernel_Init>:
#define __FILE_ID__ 	KERNEL_C       //!< File ID used in kernel trace calls

//---------------------------------------------------------------------------
void Kernel_Init(void)
{
    m_bIsStarted = false;
   0:	10 92 00 00 	sts	0x0000, r1
    m_bIsPanic = false;
   4:	10 92 00 00 	sts	0x0000, r1
    m_pfPanic = 0;
   8:	10 92 00 00 	sts	0x0000, r1
   c:	10 92 00 00 	sts	0x0000, r1

#if KERNEL_AWARE_SIMULATION
    g_ucKACommand = KA_COMMAND_IDLE;
  10:	10 92 00 00 	sts	0x0000, r1
    g_bIsKernelAware = g_bIsKernelAware;
  14:	80 91 00 00 	lds	r24, 0x0000
  18:	80 93 00 00 	sts	0x0000, r24
#if KERNEL_USE_DEBUG & !KERNEL_AWARE_SIMULATION
	TraceBuffer_Init();
#endif

#if KERNEL_USE_IDLE_FUNC
	Thread_InitIdle( (Thread_t*)&m_clIdle );
  1c:	80 e0       	ldi	r24, 0x00	; 0
  1e:	90 e0       	ldi	r25, 0x00	; 0
  20:	0e 94 00 00 	call	0	; 0x0 <Kernel_Init>
	m_pfIdle = 0;
  24:	10 92 00 00 	sts	0x0000, r1
  28:	10 92 00 00 	sts	0x0000, r1
	
	KERNEL_TRACE( STR_MARK3_INIT );

    // Initialize the global kernel data - scheduler, timer-scheduler, and
    // the global message pool.	
    Scheduler_Init();
  2c:	0e 94 00 00 	call	0	; 0x0 <Kernel_Init>
#if KERNEL_USE_DRIVER
	DriverList_Init();
  30:	0e 94 00 00 	call	0	; 0x0 <Kernel_Init>
#endif	
#if KERNEL_USE_TIMERS    
    TimerScheduler_Init();
  34:	0e 94 00 00 	call	0	; 0x0 <Kernel_Init>
#endif
#if KERNEL_USE_MESSAGE    
    GlobalMessagePool_Init();
  38:	0e 94 00 00 	call	0	; 0x0 <Kernel_Init>
#endif
#if KERNEL_USE_PROFILER
	Profiler_Init();
  3c:	0c 94 00 00 	jmp	0	; 0x0 <Kernel_Init>

Disassembly of section .text.Kernel_Start:

00000000 <Kernel_Start>:
    
//---------------------------------------------------------------------------
void Kernel_Start(void)
{
	KERNEL_TRACE( STR_THREAD_START );    
    m_bIsStarted = true;
   0:	81 e0       	ldi	r24, 0x01	; 1
   2:	80 93 00 00 	sts	0x0000, r24
    ThreadPort_StartThreads();
   6:	0c 94 00 00 	jmp	0	; 0x0 <Kernel_Start>

Disassembly of section .text.Kernel_Panic:

00000000 <Kernel_Panic>:
}

//---------------------------------------------------------------------------
void Kernel_Panic(K_USHORT usCause_)
{
    m_bIsPanic = true;
   0:	21 e0       	ldi	r18, 0x01	; 1
   2:	20 93 00 00 	sts	0x0000, r18
    if (m_pfPanic)
   6:	e0 91 00 00 	lds	r30, 0x0000
   a:	f0 91 00 00 	lds	r31, 0x0000
   e:	30 97       	sbiw	r30, 0x00	; 0
  10:	01 f0       	breq	.+0      	; 0x12 <Kernel_Panic+0x12>
    {
        m_pfPanic(usCause_);
  12:	09 94       	ijmp
    }
    else
    {
#if KERNEL_AWARE_SIMULATION
        KernelAware_ExitSimulator();
  14:	0e 94 00 00 	call	0	; 0x0 <Kernel_Panic>
  18:	00 c0       	rjmp	.+0      	; 0x1a <__zero_reg__+0x19>

Disassembly of section .text.Kernel_IsStarted:

00000000 <Kernel_IsStarted>:

//---------------------------------------------------------------------------
K_BOOL Kernel_IsStarted( void )    
{   
	return m_bIsStarted;    
}
   0:	80 91 00 00 	lds	r24, 0x0000
   4:	08 95       	ret

Disassembly of section .text.Kernel_SetPanic:

00000000 <Kernel_SetPanic>:

//---------------------------------------------------------------------------
void Kernel_SetPanic( panic_func_t pfPanic_ ) 
{ 
	m_pfPanic = pfPanic_; 
   0:	90 93 00 00 	sts	0x0000, r25
   4:	80 93 00 00 	sts	0x0000, r24
   8:	08 95       	ret

Disassembly of section .text.Kernel_IsPanic:

00000000 <Kernel_IsPanic>:
	
//---------------------------------------------------------------------------
K_BOOL Kernel_IsPanic( void )      
{   
	return m_bIsPanic;   
}
   0:	80 91 00 00 	lds	r24, 0x0000
   4:	08 95       	ret

Disassembly of section .text.Kernel_SetIdleFunc:

00000000 <Kernel_SetIdleFunc>:
	
//---------------------------------------------------------------------------
void Kernel_SetIdleFunc( idle_func_t pfIdle_ )  
{   
	m_pfIdle = pfIdle_; 
   0:	90 93 00 00 	sts	0x0000, r25
   4:	80 93 00 00 	sts	0x0000, r24
   8:	08 95       	ret

Disassembly of section .text.Kernel_IdleFunc:

00000000 <Kernel_IdleFunc>:
}
	
//---------------------------------------------------------------------------
void Kernel_IdleFunc( void ) 
{ 
	if (m_pfIdle != 0 ) 
   0:	e0 91 00 00 	lds	r30, 0x0000
   4:	f0 91 00 00 	lds	r31, 0x0000
   8:	30 97       	sbiw	r30, 0x00	; 0
   a:	01 f0       	breq	.+0      	; 0xc <Kernel_IdleFunc+0xc>
	{ 
		m_pfIdle(); 
   c:	09 94       	ijmp
   e:	08 95       	ret

Disassembly of section .text.Kernel_GetIdleThread:

00000000 <Kernel_GetIdleThread>:

//---------------------------------------------------------------------------
Thread_t *Kernel_GetIdleThread( void ) 
{ 
	return (Thread_t*)&m_clIdle; 
}
   0:	80 e0       	ldi	r24, 0x00	; 0
   2:	90 e0       	ldi	r25, 0x00	; 0
   4:	08 95       	ret

timer.c.o:     file format elf32-avr


Disassembly of section .text.Timer_Init:

00000000 <Timer_Init>:

#if KERNEL_USE_TIMERS

//---------------------------------------------------------------------------
void Timer_Init( Timer_t *pstTimer_ )
{
   0:	fc 01       	movw	r30, r24
    LinkListNode_Clear( (LinkListNode_t*)pstTimer_ );
   2:	11 82       	std	Z+1, r1	; 0x01
   4:	10 82       	st	Z, r1
   6:	13 82       	std	Z+3, r1	; 0x03
   8:	12 82       	std	Z+2, r1	; 0x02
    pstTimer_->m_ulInterval = 0;
   a:	17 82       	std	Z+7, r1	; 0x07
   c:	10 86       	std	Z+8, r1	; 0x08
   e:	11 86       	std	Z+9, r1	; 0x09
  10:	12 86       	std	Z+10, r1	; 0x0a
    pstTimer_->m_ulTimerTolerance = 0;
  12:	17 86       	std	Z+15, r1	; 0x0f
  14:	10 8a       	std	Z+16, r1	; 0x10
  16:	11 8a       	std	Z+17, r1	; 0x11
  18:	12 8a       	std	Z+18, r1	; 0x12
    pstTimer_->m_ulTimeLeft = 0;
  1a:	13 86       	std	Z+11, r1	; 0x0b
  1c:	14 86       	std	Z+12, r1	; 0x0c
  1e:	15 86       	std	Z+13, r1	; 0x0d
  20:	16 86       	std	Z+14, r1	; 0x0e
    pstTimer_->m_ucFlags = 0;
  22:	14 82       	std	Z+4, r1	; 0x04
  24:	08 95       	ret

Disassembly of section .text.Timer_Stop:

00000000 <Timer_Stop>:
}

//---------------------------------------------------------------------------
void Timer_Stop( Timer_t *pstTimer_ )
{
    TimerScheduler_Remove( pstTimer_ );
   0:	0c 94 00 00 	jmp	0	; 0x0 <Timer_Stop>

Disassembly of section .text.Timer_SetFlags:

00000000 <Timer_SetFlags>:
}

//---------------------------------------------------------------------------
void Timer_SetFlags ( Timer_t *pstTimer_, K_UCHAR ucFlags_)
{
    pstTimer_->m_ucFlags = ucFlags_;
   0:	fc 01       	movw	r30, r24
   2:	64 83       	std	Z+4, r22	; 0x04
   4:	08 95       	ret

Disassembly of section .text.Timer_SetCallback:

00000000 <Timer_SetCallback>:
}

//---------------------------------------------------------------------------
void Timer_SetCallback( Timer_t *pstTimer_, TimerCallback_t pfCallback_)
{
    pstTimer_->m_pfCallback = pfCallback_;
   0:	fc 01       	movw	r30, r24
   2:	76 83       	std	Z+6, r23	; 0x06
   4:	65 83       	std	Z+5, r22	; 0x05
   6:	08 95       	ret

Disassembly of section .text.Timer_SetData:

00000000 <Timer_SetData>:
}

//---------------------------------------------------------------------------
void Timer_SetData( Timer_t *pstTimer_, void *pvData_ )
{
    pstTimer_->m_pvData = pvData_;
   0:	fc 01       	movw	r30, r24
   2:	76 8b       	std	Z+22, r23	; 0x16
   4:	65 8b       	std	Z+21, r22	; 0x15
   6:	08 95       	ret

Disassembly of section .text.Timer_SetOwner:

00000000 <Timer_SetOwner>:
}

//---------------------------------------------------------------------------
void Timer_SetOwner( Timer_t *pstTimer_, Thread_t *pstOwner_)
{
    pstTimer_->m_pstOwner = pstOwner_;
   0:	fc 01       	movw	r30, r24
   2:	74 8b       	std	Z+20, r23	; 0x14
   4:	63 8b       	std	Z+19, r22	; 0x13
   6:	08 95       	ret

Disassembly of section .text.Timer_SetIntervalTicks:

00000000 <Timer_SetIntervalTicks>:
}

//---------------------------------------------------------------------------
void Timer_SetIntervalTicks( Timer_t *pstTimer_, K_ULONG ulTicks_ )
{
    pstTimer_->m_ulInterval = ulTicks_;
   0:	fc 01       	movw	r30, r24
   2:	47 83       	std	Z+7, r20	; 0x07
   4:	50 87       	std	Z+8, r21	; 0x08
   6:	61 87       	std	Z+9, r22	; 0x09
   8:	72 87       	std	Z+10, r23	; 0x0a
   a:	08 95       	ret

Disassembly of section .text.Timer_SetIntervalSeconds:

00000000 <Timer_SetIntervalSeconds>:

//---------------------------------------------------------------------------
//!! The next three cost us 330 bytes of flash on AVR...
//---------------------------------------------------------------------------
void Timer_SetIntervalSeconds( Timer_t *pstTimer_, K_ULONG ulSeconds_)
{
   0:	fc 01       	movw	r30, r24
    pstTimer_->m_ulInterval = SECONDS_TO_TICKS(ulSeconds_);
   2:	a4 e2       	ldi	r26, 0x24	; 36
   4:	b4 ef       	ldi	r27, 0xF4	; 244
   6:	9a 01       	movw	r18, r20
   8:	ab 01       	movw	r20, r22
   a:	0e 94 00 00 	call	0	; 0x0 <Timer_SetIntervalSeconds>
   e:	67 83       	std	Z+7, r22	; 0x07
  10:	70 87       	std	Z+8, r23	; 0x08
  12:	81 87       	std	Z+9, r24	; 0x09
  14:	92 87       	std	Z+10, r25	; 0x0a
  16:	08 95       	ret

Disassembly of section .text.Timer_SetIntervalMSeconds:

00000000 <Timer_SetIntervalMSeconds>:
}

//---------------------------------------------------------------------------
void Timer_SetIntervalMSeconds( Timer_t *pstTimer_, K_ULONG ulMSeconds_)
{
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	ec 01       	movw	r28, r24
    pstTimer_->m_ulInterval = MSECONDS_TO_TICKS(ulMSeconds_);
   6:	a1 e7       	ldi	r26, 0x71	; 113
   8:	b2 e0       	ldi	r27, 0x02	; 2
   a:	9a 01       	movw	r18, r20
   c:	ab 01       	movw	r20, r22
   e:	0e 94 00 00 	call	0	; 0x0 <Timer_SetIntervalMSeconds>
  12:	6b 5f       	subi	r22, 0xFB	; 251
  14:	7f 4f       	sbci	r23, 0xFF	; 255
  16:	8f 4f       	sbci	r24, 0xFF	; 255
  18:	9f 4f       	sbci	r25, 0xFF	; 255
  1a:	2a e0       	ldi	r18, 0x0A	; 10
  1c:	30 e0       	ldi	r19, 0x00	; 0
  1e:	40 e0       	ldi	r20, 0x00	; 0
  20:	50 e0       	ldi	r21, 0x00	; 0
  22:	0e 94 00 00 	call	0	; 0x0 <Timer_SetIntervalMSeconds>
  26:	2f 83       	std	Y+7, r18	; 0x07
  28:	38 87       	std	Y+8, r19	; 0x08
  2a:	49 87       	std	Y+9, r20	; 0x09
  2c:	5a 87       	std	Y+10, r21	; 0x0a
}
  2e:	df 91       	pop	r29
  30:	cf 91       	pop	r28
  32:	08 95       	ret

Disassembly of section .text.Timer_Start:

00000000 <Timer_Start>:
    pstTimer_->m_ucFlags = 0;
}

//---------------------------------------------------------------------------
void Timer_Start( Timer_t *pstTimer_, K_BOOL bRepeat_, K_ULONG ulIntervalMs_, TimerCallback_t pfCallback_, void *pvData_ )
{
   0:	df 92       	push	r13
   2:	ef 92       	push	r14
   4:	ff 92       	push	r15
   6:	0f 93       	push	r16
   8:	1f 93       	push	r17
   a:	cf 93       	push	r28
   c:	df 93       	push	r29
   e:	ec 01       	movw	r28, r24
  10:	d6 2e       	mov	r13, r22
  12:	ba 01       	movw	r22, r20
  14:	a9 01       	movw	r20, r18
    Timer_SetIntervalMSeconds( pstTimer_, ulIntervalMs_ );
  16:	0e 94 00 00 	call	0	; 0x0 <Timer_Start>
    pstTimer_->m_ulTimerTolerance = 0;
  1a:	1f 86       	std	Y+15, r1	; 0x0f
  1c:	18 8a       	std	Y+16, r1	; 0x10
  1e:	19 8a       	std	Y+17, r1	; 0x11
  20:	1a 8a       	std	Y+18, r1	; 0x12
    pstTimer_->m_pfCallback = pfCallback_;
  22:	1e 83       	std	Y+6, r17	; 0x06
  24:	0d 83       	std	Y+5, r16	; 0x05
    pstTimer_->m_pvData = pvData_;
  26:	fe 8a       	std	Y+22, r15	; 0x16
  28:	ed 8a       	std	Y+21, r14	; 0x15
    if (!bRepeat_)
  2a:	d1 10       	cpse	r13, r1
  2c:	00 c0       	rjmp	.+0      	; 0x2e <Timer_Start+0x2e>
    {
        pstTimer_->m_ucFlags = TIMERLIST_FLAG_ONE_SHOT;
  2e:	81 e0       	ldi	r24, 0x01	; 1
  30:	8c 83       	std	Y+4, r24	; 0x04
  32:	00 c0       	rjmp	.+0      	; 0x34 <Timer_Start+0x34>
    }
    else
    {
        pstTimer_->m_ucFlags = 0;
  34:	1c 82       	std	Y+4, r1	; 0x04
    }
    pstTimer_->m_pstOwner = Scheduler_GetCurrentThread();
  36:	80 91 00 00 	lds	r24, 0x0000
  3a:	90 91 00 00 	lds	r25, 0x0000
  3e:	9c 8b       	std	Y+20, r25	; 0x14
  40:	8b 8b       	std	Y+19, r24	; 0x13
    TimerScheduler_Add( pstTimer_ );
  42:	ce 01       	movw	r24, r28
}
  44:	df 91       	pop	r29
  46:	cf 91       	pop	r28
  48:	1f 91       	pop	r17
  4a:	0f 91       	pop	r16
  4c:	ff 90       	pop	r15
  4e:	ef 90       	pop	r14
  50:	df 90       	pop	r13
    else
    {
        pstTimer_->m_ucFlags = 0;
    }
    pstTimer_->m_pstOwner = Scheduler_GetCurrentThread();
    TimerScheduler_Add( pstTimer_ );
  52:	0c 94 00 00 	jmp	0	; 0x0 <Timer_Start>

Disassembly of section .text.Timer_StartEx:

00000000 <Timer_StartEx>:
}

//---------------------------------------------------------------------------
void Timer_StartEx( Timer_t *pstTimer_, K_BOOL bRepeat_, K_ULONG ulIntervalMs_, K_ULONG ulToleranceMs_, TimerCallback_t pfCallback_, void *pvData_ )
{
   0:	4f 92       	push	r4
   2:	5f 92       	push	r5
   4:	6f 92       	push	r6
   6:	7f 92       	push	r7
   8:	9f 92       	push	r9
   a:	af 92       	push	r10
   c:	bf 92       	push	r11
   e:	cf 92       	push	r12
  10:	df 92       	push	r13
  12:	ef 92       	push	r14
  14:	ff 92       	push	r15
  16:	0f 93       	push	r16
  18:	1f 93       	push	r17
  1a:	cf 93       	push	r28
  1c:	df 93       	push	r29
  1e:	ec 01       	movw	r28, r24
  20:	96 2e       	mov	r9, r22
  22:	29 01       	movw	r4, r18
  24:	3a 01       	movw	r6, r20
  26:	a8 01       	movw	r20, r16
  28:	97 01       	movw	r18, r14
  2a:	86 01       	movw	r16, r12
    pstTimer_->m_ulTimerTolerance = MSECONDS_TO_TICKS( ulToleranceMs_ );
  2c:	a1 e7       	ldi	r26, 0x71	; 113
  2e:	b2 e0       	ldi	r27, 0x02	; 2
  30:	0e 94 00 00 	call	0	; 0x0 <Timer_StartEx>
  34:	6b 5f       	subi	r22, 0xFB	; 251
  36:	7f 4f       	sbci	r23, 0xFF	; 255
  38:	8f 4f       	sbci	r24, 0xFF	; 255
  3a:	9f 4f       	sbci	r25, 0xFF	; 255
  3c:	2a e0       	ldi	r18, 0x0A	; 10
  3e:	30 e0       	ldi	r19, 0x00	; 0
  40:	40 e0       	ldi	r20, 0x00	; 0
  42:	50 e0       	ldi	r21, 0x00	; 0
  44:	0e 94 00 00 	call	0	; 0x0 <Timer_StartEx>
  48:	2f 87       	std	Y+15, r18	; 0x0f
  4a:	38 8b       	std	Y+16, r19	; 0x10
  4c:	49 8b       	std	Y+17, r20	; 0x11
  4e:	5a 8b       	std	Y+18, r21	; 0x12
    Timer_Start( pstTimer_, bRepeat_, ulIntervalMs_, pfCallback_, pvData_ );
  50:	75 01       	movw	r14, r10
  52:	a3 01       	movw	r20, r6
  54:	92 01       	movw	r18, r4
  56:	69 2d       	mov	r22, r9
  58:	ce 01       	movw	r24, r28
  5a:	0e 94 00 00 	call	0	; 0x0 <Timer_StartEx>
}
  5e:	df 91       	pop	r29
  60:	cf 91       	pop	r28
  62:	1f 91       	pop	r17
  64:	0f 91       	pop	r16
  66:	ff 90       	pop	r15
  68:	ef 90       	pop	r14
  6a:	df 90       	pop	r13
  6c:	cf 90       	pop	r12
  6e:	bf 90       	pop	r11
  70:	af 90       	pop	r10
  72:	9f 90       	pop	r9
  74:	7f 90       	pop	r7
  76:	6f 90       	pop	r6
  78:	5f 90       	pop	r5
  7a:	4f 90       	pop	r4
  7c:	08 95       	ret

Disassembly of section .text.Timer_SetIntervalUSeconds:

00000000 <Timer_SetIntervalUSeconds>:
    pstTimer_->m_ulInterval = MSECONDS_TO_TICKS(ulMSeconds_);
}

//---------------------------------------------------------------------------
void Timer_SetIntervalUSeconds( Timer_t *pstTimer_, K_ULONG ulUSeconds_)
{
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	ec 01       	movw	r28, r24
    pstTimer_->m_ulInterval = USECONDS_TO_TICKS(ulUSeconds_);
   6:	a4 e2       	ldi	r26, 0x24	; 36
   8:	b4 ef       	ldi	r27, 0xF4	; 244
   a:	9a 01       	movw	r18, r20
   c:	ab 01       	movw	r20, r22
   e:	0e 94 00 00 	call	0	; 0x0 <Timer_SetIntervalUSeconds>
  12:	60 5b       	subi	r22, 0xB0	; 176
  14:	7c 43       	sbci	r23, 0x3C	; 60
  16:	8f 4f       	sbci	r24, 0xFF	; 255
  18:	9f 4f       	sbci	r25, 0xFF	; 255
  1a:	20 e4       	ldi	r18, 0x40	; 64
  1c:	32 e4       	ldi	r19, 0x42	; 66
  1e:	4f e0       	ldi	r20, 0x0F	; 15
  20:	50 e0       	ldi	r21, 0x00	; 0
  22:	0e 94 00 00 	call	0	; 0x0 <Timer_SetIntervalUSeconds>
  26:	2f 83       	std	Y+7, r18	; 0x07
  28:	38 87       	std	Y+8, r19	; 0x08
  2a:	49 87       	std	Y+9, r20	; 0x09
  2c:	5a 87       	std	Y+10, r21	; 0x0a
}
  2e:	df 91       	pop	r29
  30:	cf 91       	pop	r28
  32:	08 95       	ret

Disassembly of section .text.Timer_SetTolerance:

00000000 <Timer_SetTolerance>:

//---------------------------------------------------------------------------
void Timer_SetTolerance( Timer_t *pstTimer_, K_ULONG ulTicks_)
{
    pstTimer_->m_ulTimerTolerance = ulTicks_;
   0:	fc 01       	movw	r30, r24
   2:	47 87       	std	Z+15, r20	; 0x0f
   4:	50 8b       	std	Z+16, r21	; 0x10
   6:	61 8b       	std	Z+17, r22	; 0x11
   8:	72 8b       	std	Z+18, r23	; 0x12
   a:	08 95       	ret

Disassembly of section .text.Timer_GetInterval:

00000000 <Timer_GetInterval>:
}
//---------------------------------------------------------------------------
K_ULONG Timer_GetInterval( Timer_t *pstTimer_ )
{
    return pstTimer_->m_ulInterval;
   0:	fc 01       	movw	r30, r24
   2:	67 81       	ldd	r22, Z+7	; 0x07
   4:	70 85       	ldd	r23, Z+8	; 0x08
   6:	81 85       	ldd	r24, Z+9	; 0x09
   8:	92 85       	ldd	r25, Z+10	; 0x0a
}
   a:	08 95       	ret

timerlist.c.o:     file format elf32-avr


Disassembly of section .text.TimerList_Init:

00000000 <TimerList_Init>:


//---------------------------------------------------------------------------
void TimerList_Init(void)
{
    m_bTimerActive = 0;    
   0:	10 92 00 00 	sts	0x0000, r1
    m_ulNextWakeup = 0;    
   4:	10 92 00 00 	sts	0x0000, r1
   8:	10 92 00 00 	sts	0x0000, r1
   c:	10 92 00 00 	sts	0x0000, r1
  10:	10 92 00 00 	sts	0x0000, r1
	LinkList_Init( (LinkList_t*)&m_clTimerList );
  14:	10 92 00 00 	sts	0x0000, r1
  18:	10 92 00 00 	sts	0x0000, r1
  1c:	10 92 00 00 	sts	0x0000, r1
  20:	10 92 00 00 	sts	0x0000, r1
  24:	08 95       	ret

Disassembly of section .text.TimerList_Add:

00000000 <TimerList_Add>:
}

//---------------------------------------------------------------------------
void TimerList_Add(Timer_t *pstListNode_)
{
   0:	cf 92       	push	r12
   2:	df 92       	push	r13
   4:	ef 92       	push	r14
   6:	ff 92       	push	r15
   8:	0f 93       	push	r16
   a:	1f 93       	push	r17
   c:	cf 93       	push	r28
   e:	df 93       	push	r29
  10:	1f 92       	push	r1
  12:	cd b7       	in	r28, 0x3d	; 61
  14:	de b7       	in	r29, 0x3e	; 62
  16:	8c 01       	movw	r16, r24
#if KERNEL_TIMERS_TICKLESS
    K_BOOL bStart = 0;
    K_LONG lDelta;
#endif

    CS_ENTER();
  18:	8f b7       	in	r24, 0x3f	; 63
  1a:	89 83       	std	Y+1, r24	; 0x01
  1c:	f8 94       	cli

#if KERNEL_TIMERS_TICKLESS
    if (LinkList_GetHead( (LinkList_t*)&m_clTimerList ) == NULL)
  1e:	e0 90 00 00 	lds	r14, 0x0000
  22:	f0 90 00 00 	lds	r15, 0x0000
    {
        bStart = 1;
    }
#endif

    LinkListNode_Clear( (LinkListNode_t*)pstListNode_ );
  26:	f8 01       	movw	r30, r16
  28:	11 82       	std	Z+1, r1	; 0x01
  2a:	10 82       	st	Z, r1
  2c:	13 82       	std	Z+3, r1	; 0x03
  2e:	12 82       	std	Z+2, r1	; 0x02
    DoubleLinkList_Add( (DoubleLinkList_t*)&m_clTimerList, (LinkListNode_t*)pstListNode_);
  30:	b8 01       	movw	r22, r16
  32:	80 e0       	ldi	r24, 0x00	; 0
  34:	90 e0       	ldi	r25, 0x00	; 0
  36:	0e 94 00 00 	call	0	; 0x0 <TimerList_Add>
    
    // Set the initial timer value
    pstListNode_->m_ulTimeLeft = pstListNode_->m_ulInterval;    
  3a:	f8 01       	movw	r30, r16
  3c:	67 81       	ldd	r22, Z+7	; 0x07
  3e:	70 85       	ldd	r23, Z+8	; 0x08
  40:	81 85       	ldd	r24, Z+9	; 0x09
  42:	92 85       	ldd	r25, Z+10	; 0x0a
  44:	63 87       	std	Z+11, r22	; 0x0b
  46:	74 87       	std	Z+12, r23	; 0x0c
  48:	85 87       	std	Z+13, r24	; 0x0d
  4a:	96 87       	std	Z+14, r25	; 0x0e

#if KERNEL_TIMERS_TICKLESS
    if (!bStart)
  4c:	ef 28       	or	r14, r15
  4e:	01 f0       	breq	.+0      	; 0x50 <TimerList_Add+0x50>
    {
        // If the new interval is less than the amount of time remaining...
        lDelta = KernelTimer_TimeToExpiry() - pstListNode_->m_ulInterval;
  50:	0e 94 00 00 	call	0	; 0x0 <TimerList_Add>
  54:	f8 01       	movw	r30, r16
  56:	c7 80       	ldd	r12, Z+7	; 0x07
  58:	d0 84       	ldd	r13, Z+8	; 0x08
  5a:	e1 84       	ldd	r14, Z+9	; 0x09
  5c:	f2 84       	ldd	r15, Z+10	; 0x0a
  5e:	6c 19       	sub	r22, r12
  60:	7d 09       	sbc	r23, r13
  62:	8e 09       	sbc	r24, r14
  64:	9f 09       	sbc	r25, r15
    
        if (lDelta > 0)
  66:	16 16       	cp	r1, r22
  68:	17 06       	cpc	r1, r23
  6a:	18 06       	cpc	r1, r24
  6c:	19 06       	cpc	r1, r25
  6e:	04 f4       	brge	.+0      	; 0x70 <TimerList_Add+0x70>
        {
            // Set the new expiry time on the timer.
            m_ulNextWakeup = KernelTimer_SubtractExpiry((K_ULONG)lDelta);
  70:	0e 94 00 00 	call	0	; 0x0 <TimerList_Add>
  74:	60 93 00 00 	sts	0x0000, r22
  78:	70 93 00 00 	sts	0x0000, r23
  7c:	80 93 00 00 	sts	0x0000, r24
  80:	90 93 00 00 	sts	0x0000, r25
  84:	00 c0       	rjmp	.+0      	; 0x86 <TimerList_Add+0x86>
        }
    }
    else    
    {
        m_ulNextWakeup = pstListNode_->m_ulInterval;
  86:	60 93 00 00 	sts	0x0000, r22
  8a:	70 93 00 00 	sts	0x0000, r23
  8e:	80 93 00 00 	sts	0x0000, r24
  92:	90 93 00 00 	sts	0x0000, r25
        KernelTimer_SetExpiry(m_ulNextWakeup);
  96:	0e 94 00 00 	call	0	; 0x0 <TimerList_Add>
        KernelTimer_Start();
  9a:	0e 94 00 00 	call	0	; 0x0 <TimerList_Add>
    }
#endif

    // Set the timer as active.
    pstListNode_->m_ucFlags |= TIMERLIST_FLAG_ACTIVE;    
  9e:	f8 01       	movw	r30, r16
  a0:	84 81       	ldd	r24, Z+4	; 0x04
  a2:	82 60       	ori	r24, 0x02	; 2
  a4:	84 83       	std	Z+4, r24	; 0x04
    CS_EXIT();
  a6:	89 81       	ldd	r24, Y+1	; 0x01
  a8:	8f bf       	out	0x3f, r24	; 63
}
  aa:	0f 90       	pop	r0
  ac:	df 91       	pop	r29
  ae:	cf 91       	pop	r28
  b0:	1f 91       	pop	r17
  b2:	0f 91       	pop	r16
  b4:	ff 90       	pop	r15
  b6:	ef 90       	pop	r14
  b8:	df 90       	pop	r13
  ba:	cf 90       	pop	r12
  bc:	08 95       	ret

Disassembly of section .text.TimerList_Remove:

00000000 <TimerList_Remove>:

//---------------------------------------------------------------------------
void TimerList_Remove(Timer_t *pstLinkListNode_)
{
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	1f 92       	push	r1
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
    CS_ENTER();
   a:	2f b7       	in	r18, 0x3f	; 63
   c:	29 83       	std	Y+1, r18	; 0x01
   e:	f8 94       	cli
    
    DoubleLinkList_Remove( (DoubleLinkList_t*)&m_clTimerList, (LinkListNode_t*)pstLinkListNode_ );
  10:	bc 01       	movw	r22, r24
  12:	80 e0       	ldi	r24, 0x00	; 0
  14:	90 e0       	ldi	r25, 0x00	; 0
  16:	0e 94 00 00 	call	0	; 0x0 <TimerList_Remove>

#if KERNEL_TIMERS_TICKLESS
    if ( LinkList_GetHead( (LinkList_t*)&m_clTimerList ) == NULL )
  1a:	80 91 00 00 	lds	r24, 0x0000
  1e:	90 91 00 00 	lds	r25, 0x0000
  22:	89 2b       	or	r24, r25
  24:	01 f4       	brne	.+0      	; 0x26 <TimerList_Remove+0x26>
    {
        KernelTimer_Stop();
  26:	0e 94 00 00 	call	0	; 0x0 <TimerList_Remove>
    }
#endif
    
    CS_EXIT();
  2a:	89 81       	ldd	r24, Y+1	; 0x01
  2c:	8f bf       	out	0x3f, r24	; 63
}
  2e:	0f 90       	pop	r0
  30:	df 91       	pop	r29
  32:	cf 91       	pop	r28
  34:	08 95       	ret

Disassembly of section .text.TimerList_Process:

00000000 <TimerList_Process>:

//---------------------------------------------------------------------------
void TimerList_Process(void)
{
   0:	cf 92       	push	r12
   2:	df 92       	push	r13
   4:	ef 92       	push	r14
   6:	ff 92       	push	r15
   8:	0f 93       	push	r16
   a:	1f 93       	push	r17
   c:	cf 93       	push	r28
   e:	df 93       	push	r29
    
    Timer_t *pstNode;
    Timer_t *pstPrev;

#if KERNEL_USE_QUANTUM
    Quantum_SetInTimer();
  10:	0e 94 00 00 	call	0	; 0x0 <TimerList_Process>
#endif
#if KERNEL_TIMERS_TICKLESS
    // Clear the timer and its expiry time - keep it running though
    KernelTimer_ClearExpiry();
  14:	0e 94 00 00 	call	0	; 0x0 <TimerList_Process>
    do 
    {        
#endif
        pstNode = (Timer_t*)LinkList_GetHead( (LinkList_t*)&m_clTimerList );
  18:	c0 91 00 00 	lds	r28, 0x0000
  1c:	d0 91 00 00 	lds	r29, 0x0000
            // Active timers only...
            if (pstNode->m_ucFlags & TIMERLIST_FLAG_ACTIVE)
            {
                // Did the timer expire?
#if KERNEL_TIMERS_TICKLESS
                if (pstNode->m_ulTimeLeft <= m_ulNextWakeup)
  20:	40 91 00 00 	lds	r20, 0x0000
  24:	50 91 00 00 	lds	r21, 0x0000
  28:	60 91 00 00 	lds	r22, 0x0000
  2c:	70 91 00 00 	lds	r23, 0x0000
    // Clear the timer and its expiry time - keep it running though
    KernelTimer_ClearExpiry();
    do 
    {        
#endif
        pstNode = (Timer_t*)LinkList_GetHead( (LinkList_t*)&m_clTimerList );
  30:	fe 01       	movw	r30, r28
        pstPrev = NULL;

#if KERNEL_TIMERS_TICKLESS
        bContinue = 0;
        ulNewExpiry = MAX_TIMER_TICKS;
  32:	cc 24       	eor	r12, r12
  34:	ca 94       	dec	r12
  36:	dc 2c       	mov	r13, r12
  38:	ec 2c       	mov	r14, r12
  3a:	8f e7       	ldi	r24, 0x7F	; 127
  3c:	f8 2e       	mov	r15, r24
#endif

        // Subtract the elapsed time interval from each active timer.
        while (pstNode)
  3e:	30 97       	sbiw	r30, 0x00	; 0
  40:	01 f4       	brne	.+0      	; 0x42 <TimerList_Process+0x42>
  42:	00 c0       	rjmp	.+0      	; 0x44 <TimerList_Process+0x44>
        {        
            // Active timers only...
            if (pstNode->m_ucFlags & TIMERLIST_FLAG_ACTIVE)
  44:	24 81       	ldd	r18, Z+4	; 0x04
  46:	21 ff       	sbrs	r18, 1
  48:	00 c0       	rjmp	.+0      	; 0x4a <TimerList_Process+0x4a>
            {
                // Did the timer expire?
#if KERNEL_TIMERS_TICKLESS
                if (pstNode->m_ulTimeLeft <= m_ulNextWakeup)
  4a:	83 85       	ldd	r24, Z+11	; 0x0b
  4c:	94 85       	ldd	r25, Z+12	; 0x0c
  4e:	a5 85       	ldd	r26, Z+13	; 0x0d
  50:	b6 85       	ldd	r27, Z+14	; 0x0e
  52:	48 17       	cp	r20, r24
  54:	59 07       	cpc	r21, r25
  56:	6a 07       	cpc	r22, r26
  58:	7b 07       	cpc	r23, r27
  5a:	00 f0       	brcs	.+0      	; 0x5c <TimerList_Process+0x5c>
                pstNode->m_ulTimeLeft--;
                if (0 == pstNode->m_ulTimeLeft)
#endif
                {
                    // Yes - set the "callback" flag - we'll execute the callbacks later
                    pstNode->m_ucFlags |= TIMERLIST_FLAG_CALLBACK;
  5c:	82 2f       	mov	r24, r18
  5e:	84 60       	ori	r24, 0x04	; 4
  60:	84 83       	std	Z+4, r24	; 0x04
                                
                    if (pstNode->m_ucFlags & TIMERLIST_FLAG_ONE_SHOT)
  62:	20 ff       	sbrs	r18, 0
  64:	00 c0       	rjmp	.+0      	; 0x66 <TimerList_Process+0x66>
                    {
                        // If this was a one-shot timer, deactivate the timer.
                        pstNode->m_ucFlags |= TIMERLIST_FLAG_EXPIRED;
                        pstNode->m_ucFlags &= ~TIMERLIST_FLAG_ACTIVE;                    
  66:	2d 7f       	andi	r18, 0xFD	; 253
  68:	2c 60       	ori	r18, 0x0C	; 12
  6a:	24 83       	std	Z+4, r18	; 0x04
  6c:	00 c0       	rjmp	.+0      	; 0x6e <TimerList_Process+0x6e>
                    else
                    {
                        // Reset the interval timer.
                        //!ToDo - figure out if we need to deal with any overtime here.
                        // I think we're good though...                        
                        pstNode->m_ulTimeLeft = pstNode->m_ulInterval;
  6e:	07 81       	ldd	r16, Z+7	; 0x07
  70:	10 85       	ldd	r17, Z+8	; 0x08
  72:	21 85       	ldd	r18, Z+9	; 0x09
  74:	32 85       	ldd	r19, Z+10	; 0x0a
  76:	03 87       	std	Z+11, r16	; 0x0b
  78:	14 87       	std	Z+12, r17	; 0x0c
  7a:	25 87       	std	Z+13, r18	; 0x0d
  7c:	36 87       	std	Z+14, r19	; 0x0e
                        
#if KERNEL_TIMERS_TICKLESS
                        // If the time remaining (plus the length of the tolerance interval)
                        // is less than the next expiry interval, set the next expiry interval.
                        K_ULONG ulTmp = pstNode->m_ulTimeLeft + pstNode->m_ulTimerTolerance;
  7e:	87 85       	ldd	r24, Z+15	; 0x0f
  80:	90 89       	ldd	r25, Z+16	; 0x10
  82:	a1 89       	ldd	r26, Z+17	; 0x11
  84:	b2 89       	ldd	r27, Z+18	; 0x12
  86:	80 0f       	add	r24, r16
  88:	91 1f       	adc	r25, r17
  8a:	a2 1f       	adc	r26, r18
  8c:	b3 1f       	adc	r27, r19
  8e:	00 c0       	rjmp	.+0      	; 0x90 <TimerList_Process+0x90>
                }
#if KERNEL_TIMERS_TICKLESS
                else
                {
                    // Not expiring, but determine how K_LONG to run the next timer interval for.
                    pstNode->m_ulTimeLeft -= m_ulNextWakeup;
  90:	84 1b       	sub	r24, r20
  92:	95 0b       	sbc	r25, r21
  94:	a6 0b       	sbc	r26, r22
  96:	b7 0b       	sbc	r27, r23
  98:	83 87       	std	Z+11, r24	; 0x0b
  9a:	94 87       	std	Z+12, r25	; 0x0c
  9c:	a5 87       	std	Z+13, r26	; 0x0d
  9e:	b6 87       	std	Z+14, r27	; 0x0e
  a0:	8c 15       	cp	r24, r12
  a2:	9d 05       	cpc	r25, r13
  a4:	ae 05       	cpc	r26, r14
  a6:	bf 05       	cpc	r27, r15
  a8:	00 f4       	brcc	.+0      	; 0xaa <TimerList_Process+0xaa>
  aa:	6c 01       	movw	r12, r24
  ac:	7d 01       	movw	r14, r26
                        ulNewExpiry = pstNode->m_ulTimeLeft;
                    }
                }
#endif
            }
            pstNode = (Timer_t*)LinkListNode_GetNext( (LinkListNode_t*)pstNode );
  ae:	01 90       	ld	r0, Z+
  b0:	f0 81       	ld	r31, Z
  b2:	e0 2d       	mov	r30, r0
  b4:	00 c0       	rjmp	.+0      	; 0xb6 <TimerList_Process+0xb6>
        while (pstNode)
        {
            pstPrev = NULL;
        
            // If the timer expired, run the callbacks now.
            if (pstNode->m_ucFlags & TIMERLIST_FLAG_CALLBACK)
  b6:	8c 81       	ldd	r24, Y+4	; 0x04
  b8:	82 fd       	sbrc	r24, 2
  ba:	00 c0       	rjmp	.+0      	; 0xbc <TimerList_Process+0xbc>
    
        // Process the expired timers callbacks.
        pstNode = (Timer_t*)LinkList_GetHead( (LinkList_t*)&m_clTimerList );
        while (pstNode)
        {
            pstPrev = NULL;
  bc:	80 e0       	ldi	r24, 0x00	; 0
  be:	90 e0       	ldi	r25, 0x00	; 0
                if (pstNode->m_ucFlags & TIMERLIST_FLAG_ONE_SHOT)
                {
                    pstPrev = pstNode;
                }
            }
            pstNode = (Timer_t*)LinkListNode_GetNext( (LinkListNode_t*)pstNode );
  c0:	09 90       	ld	r0, Y+
  c2:	d8 81       	ld	r29, Y
  c4:	c0 2d       	mov	r28, r0
        
            // Remove one-shot-timers
            if (pstPrev)
  c6:	00 97       	sbiw	r24, 0x00	; 0
  c8:	01 f0       	breq	.+0      	; 0xca <TimerList_Process+0xca>
            {
                TimerList_Remove( pstPrev );
  ca:	0e 94 00 00 	call	0	; 0x0 <TimerList_Process>
            pstNode = (Timer_t*)LinkListNode_GetNext( (LinkListNode_t*)pstNode );
        }
    
        // Process the expired timers callbacks.
        pstNode = (Timer_t*)LinkList_GetHead( (LinkList_t*)&m_clTimerList );
        while (pstNode)
  ce:	20 97       	sbiw	r28, 0x00	; 0
  d0:	01 f4       	brne	.+0      	; 0xd2 <TimerList_Process+0xd2>
  d2:	00 c0       	rjmp	.+0      	; 0xd4 <TimerList_Process+0xd4>
        
            // If the timer expired, run the callbacks now.
            if (pstNode->m_ucFlags & TIMERLIST_FLAG_CALLBACK)
            {
                // Run the callback. these callbacks must be very fast...
                pstNode->m_pfCallback( pstNode->m_pstOwner, pstNode->m_pvData );
  d4:	6d 89       	ldd	r22, Y+21	; 0x15
  d6:	7e 89       	ldd	r23, Y+22	; 0x16
  d8:	ed 81       	ldd	r30, Y+5	; 0x05
  da:	fe 81       	ldd	r31, Y+6	; 0x06
  dc:	8b 89       	ldd	r24, Y+19	; 0x13
  de:	9c 89       	ldd	r25, Y+20	; 0x14
  e0:	09 95       	icall
                pstNode->m_ucFlags &= ~TIMERLIST_FLAG_CALLBACK;
  e2:	8c 81       	ldd	r24, Y+4	; 0x04
  e4:	98 2f       	mov	r25, r24
  e6:	9b 7f       	andi	r25, 0xFB	; 251
  e8:	9c 83       	std	Y+4, r25	; 0x04
            
                // If this was a one-shot timer, let's remove it.
                if (pstNode->m_ucFlags & TIMERLIST_FLAG_ONE_SHOT)
  ea:	80 ff       	sbrs	r24, 0
  ec:	00 c0       	rjmp	.+0      	; 0xee <TimerList_Process+0xee>
  ee:	ce 01       	movw	r24, r28
  f0:	00 c0       	rjmp	.+0      	; 0xf2 <TimerList_Process+0xf2>
        }    

#if KERNEL_TIMERS_TICKLESS
        // Check to see how much time has elapsed since the time we 
        // acknowledged the interrupt... 
        ulOvertime = KernelTimer_GetOvertime();
  f2:	0e 94 00 00 	call	0	; 0x0 <TimerList_Process>
        
        if( ulOvertime >= ulNewExpiry ) {
  f6:	6c 15       	cp	r22, r12
  f8:	7d 05       	cpc	r23, r13
  fa:	8e 05       	cpc	r24, r14
  fc:	9f 05       	cpc	r25, r15
  fe:	00 f0       	brcs	.+0      	; 0x100 <TimerList_Process+0x100>
            m_ulNextWakeup = ulOvertime;
 100:	60 93 00 00 	sts	0x0000, r22
 104:	70 93 00 00 	sts	0x0000, r23
 108:	80 93 00 00 	sts	0x0000, r24
 10c:	90 93 00 00 	sts	0x0000, r25
 110:	00 c0       	rjmp	.+0      	; 0x112 <TimerList_Process+0x112>

    } while (bContinue);

    // This timer elapsed, but there's nothing more to do...
    // Turn the timer off.
    if (ulNewExpiry >= MAX_TIMER_TICKS)
 112:	2f ef       	ldi	r18, 0xFF	; 255
 114:	c2 16       	cp	r12, r18
 116:	d2 06       	cpc	r13, r18
 118:	e2 06       	cpc	r14, r18
 11a:	2f e7       	ldi	r18, 0x7F	; 127
 11c:	f2 06       	cpc	r15, r18
 11e:	01 f4       	brne	.+0      	; 0x120 <TimerList_Process+0x120>
    {
        KernelTimer_Stop();
 120:	0e 94 00 00 	call	0	; 0x0 <TimerList_Process>
 124:	00 c0       	rjmp	.+0      	; 0x126 <TimerList_Process+0x126>
    else 
    {
        // Update the timer with the new "Next Wakeup" value, plus whatever
        // overtime has accumulated since the last time we called this handler

        m_ulNextWakeup = KernelTimer_SetExpiry(ulNewExpiry + ulOvertime);
 126:	6c 0d       	add	r22, r12
 128:	7d 1d       	adc	r23, r13
 12a:	8e 1d       	adc	r24, r14
 12c:	9f 1d       	adc	r25, r15
 12e:	0e 94 00 00 	call	0	; 0x0 <TimerList_Process>
 132:	60 93 00 00 	sts	0x0000, r22
 136:	70 93 00 00 	sts	0x0000, r23
 13a:	80 93 00 00 	sts	0x0000, r24
 13e:	90 93 00 00 	sts	0x0000, r25
#endif

#if KERNEL_USE_QUANTUM
    Quantum_ClearInTimer();
#endif
}
 142:	df 91       	pop	r29
 144:	cf 91       	pop	r28
 146:	1f 91       	pop	r17
 148:	0f 91       	pop	r16
 14a:	ff 90       	pop	r15
 14c:	ef 90       	pop	r14
 14e:	df 90       	pop	r13
 150:	cf 90       	pop	r12
        m_ulNextWakeup = KernelTimer_SetExpiry(ulNewExpiry + ulOvertime);
    }
#endif

#if KERNEL_USE_QUANTUM
    Quantum_ClearInTimer();
 152:	0c 94 00 00 	jmp	0	; 0x0 <TimerList_Process>

timerscheduler.c.o:     file format elf32-avr


Disassembly of section .text.TimerScheduler_Init:

00000000 <TimerScheduler_Init>:


//---------------------------------------------------------------------------
void TimerScheduler_Init( void )
{
    TimerList_Init( );
   0:	0c 94 00 00 	jmp	0	; 0x0 <TimerScheduler_Init>

Disassembly of section .text.TimerScheduler_Add:

00000000 <TimerScheduler_Add>:
}

//---------------------------------------------------------------------------
void TimerScheduler_Add( Timer_t *pstListNode_ )
{
    TimerList_Add( pstListNode_ );
   0:	0c 94 00 00 	jmp	0	; 0x0 <TimerScheduler_Add>

Disassembly of section .text.TimerScheduler_Remove:

00000000 <TimerScheduler_Remove>:
}

//---------------------------------------------------------------------------
void TimerScheduler_Remove( Timer_t *pstListNode_ )
{
    TimerList_Remove( pstListNode_ );
   0:	0c 94 00 00 	jmp	0	; 0x0 <TimerScheduler_Remove>

Disassembly of section .text.TimerScheduler_Process:

00000000 <TimerScheduler_Process>:
}

//---------------------------------------------------------------------------
void TimerScheduler_Process( void )
{
    TimerList_Process( );
   0:	0c 94 00 00 	jmp	0	; 0x0 <TimerScheduler_Process>

tracebuffer.c.o:     file format elf32-avr


writebuf16.c.o:     file format elf32-avr


kernelaware.c.o:     file format elf32-avr


Disassembly of section .text.KernelAware_ProfileInit:

00000000 <KernelAware_ProfileInit>:
								K_USHORT usArg2_,
								KernelAwareCommand_t eCmd_);

//---------------------------------------------------------------------------
void KernelAware_ProfileInit(const K_CHAR *szStr_)
{
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	1f 92       	push	r1
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
    CS_ENTER();
   a:	2f b7       	in	r18, 0x3f	; 63
   c:	29 83       	std	Y+1, r18	; 0x01
   e:	f8 94       	cli
    g_stKAData.Profiler.szName = szStr_;
  10:	90 93 00 00 	sts	0x0000, r25
  14:	80 93 00 00 	sts	0x0000, r24
    g_ucKACommand = KA_COMMAND_PROFILE_INIT;
  18:	81 e0       	ldi	r24, 0x01	; 1
  1a:	80 93 00 00 	sts	0x0000, r24
    CS_EXIT();
  1e:	89 81       	ldd	r24, Y+1	; 0x01
  20:	8f bf       	out	0x3f, r24	; 63
}
  22:	0f 90       	pop	r0
  24:	df 91       	pop	r29
  26:	cf 91       	pop	r28
  28:	08 95       	ret

Disassembly of section .text.KernelAware_ProfileStart:

00000000 <KernelAware_ProfileStart>:

//---------------------------------------------------------------------------
void KernelAware_ProfileStart(void)
{
    g_ucKACommand = KA_COMMAND_PROFILE_START;
   0:	82 e0       	ldi	r24, 0x02	; 2
   2:	80 93 00 00 	sts	0x0000, r24
   6:	08 95       	ret

Disassembly of section .text.KernelAware_ProfileStop:

00000000 <KernelAware_ProfileStop>:
}

//---------------------------------------------------------------------------
void KernelAware_ProfileStop(void)
{
    g_ucKACommand = KA_COMMAND_PROFILE_STOP;
   0:	83 e0       	ldi	r24, 0x03	; 3
   2:	80 93 00 00 	sts	0x0000, r24
   6:	08 95       	ret

Disassembly of section .text.KernelAware_ProfileReport:

00000000 <KernelAware_ProfileReport>:
}

//---------------------------------------------------------------------------
void KernelAware_ProfileReport(void)
{
    g_ucKACommand = KA_COMMAND_PROFILE_REPORT;
   0:	84 e0       	ldi	r24, 0x04	; 4
   2:	80 93 00 00 	sts	0x0000, r24
   6:	08 95       	ret

Disassembly of section .text.KernelAware_ExitSimulator:

00000000 <KernelAware_ExitSimulator>:
}

//---------------------------------------------------------------------------
void KernelAware_ExitSimulator(void)
{
    g_ucKACommand = KA_COMMAND_EXIT_SIMULATOR;
   0:	85 e0       	ldi	r24, 0x05	; 5
   2:	80 93 00 00 	sts	0x0000, r24
   6:	08 95       	ret

Disassembly of section .text.KernelAware_Trace:

00000000 <KernelAware_Trace>:

//---------------------------------------------------------------------------
void KernelAware_Trace( K_USHORT usFile_,
                          K_USHORT usLine_,
                          K_USHORT usCode_ )
{
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	1f 92       	push	r1
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
                          K_USHORT usCode_,
                          K_USHORT usArg1_,
                          K_USHORT usArg2_,
                          KernelAwareCommand_t eCmd_ )
{
    CS_ENTER();
   a:	2f b7       	in	r18, 0x3f	; 63
   c:	29 83       	std	Y+1, r18	; 0x01
   e:	f8 94       	cli
    g_stKAData.Trace.usFile = usFile_;
  10:	90 93 00 00 	sts	0x0000, r25
  14:	80 93 00 00 	sts	0x0000, r24
    g_stKAData.Trace.usLine = usLine_;
  18:	70 93 00 00 	sts	0x0000, r23
  1c:	60 93 00 00 	sts	0x0000, r22
    g_stKAData.Trace.usCode = usCode_;
  20:	50 93 00 00 	sts	0x0000, r21
  24:	40 93 00 00 	sts	0x0000, r20
    g_stKAData.Trace.usArg1 = usArg1_;
  28:	10 92 00 00 	sts	0x0000, r1
  2c:	10 92 00 00 	sts	0x0000, r1
    g_stKAData.Trace.usArg2 = usArg2_;
  30:	10 92 00 00 	sts	0x0000, r1
  34:	10 92 00 00 	sts	0x0000, r1
    g_ucKACommand = eCmd_;
  38:	86 e0       	ldi	r24, 0x06	; 6
  3a:	80 93 00 00 	sts	0x0000, r24
    CS_EXIT();
  3e:	89 81       	ldd	r24, Y+1	; 0x01
  40:	8f bf       	out	0x3f, r24	; 63
void KernelAware_Trace( K_USHORT usFile_,
                          K_USHORT usLine_,
                          K_USHORT usCode_ )
{
    KernelAware_Trace_i( usFile_, usLine_, usCode_, 0, 0, KA_COMMAND_TRACE_0 );
}
  42:	0f 90       	pop	r0
  44:	df 91       	pop	r29
  46:	cf 91       	pop	r28
  48:	08 95       	ret

Disassembly of section .text.KernelAware_Trace1:

00000000 <KernelAware_Trace1>:
//---------------------------------------------------------------------------
void KernelAware_Trace1( K_USHORT usFile_,
                          K_USHORT usLine_,
                          K_USHORT usCode_,
                          K_USHORT usArg1_)
{
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	1f 92       	push	r1
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
                          K_USHORT usCode_,
                          K_USHORT usArg1_,
                          K_USHORT usArg2_,
                          KernelAwareCommand_t eCmd_ )
{
    CS_ENTER();
   a:	ef b7       	in	r30, 0x3f	; 63
   c:	e9 83       	std	Y+1, r30	; 0x01
   e:	f8 94       	cli
    g_stKAData.Trace.usFile = usFile_;
  10:	90 93 00 00 	sts	0x0000, r25
  14:	80 93 00 00 	sts	0x0000, r24
    g_stKAData.Trace.usLine = usLine_;
  18:	70 93 00 00 	sts	0x0000, r23
  1c:	60 93 00 00 	sts	0x0000, r22
    g_stKAData.Trace.usCode = usCode_;
  20:	50 93 00 00 	sts	0x0000, r21
  24:	40 93 00 00 	sts	0x0000, r20
    g_stKAData.Trace.usArg1 = usArg1_;
  28:	30 93 00 00 	sts	0x0000, r19
  2c:	20 93 00 00 	sts	0x0000, r18
    g_stKAData.Trace.usArg2 = usArg2_;
  30:	10 92 00 00 	sts	0x0000, r1
  34:	10 92 00 00 	sts	0x0000, r1
    g_ucKACommand = eCmd_;
  38:	87 e0       	ldi	r24, 0x07	; 7
  3a:	80 93 00 00 	sts	0x0000, r24
    CS_EXIT();
  3e:	89 81       	ldd	r24, Y+1	; 0x01
  40:	8f bf       	out	0x3f, r24	; 63
                          K_USHORT usCode_,
                          K_USHORT usArg1_)
{
    KernelAware_Trace_i( usFile_, usLine_, usCode_, usArg1_, 0 ,KA_COMMAND_TRACE_1 );

}
  42:	0f 90       	pop	r0
  44:	df 91       	pop	r29
  46:	cf 91       	pop	r28
  48:	08 95       	ret

Disassembly of section .text.KernelAware_Trace2:

00000000 <KernelAware_Trace2>:
void KernelAware_Trace2( K_USHORT usFile_,
                          K_USHORT usLine_,
                          K_USHORT usCode_,
                          K_USHORT usArg1_,
                          K_USHORT usArg2_)
{
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17
   4:	cf 93       	push	r28
   6:	df 93       	push	r29
   8:	1f 92       	push	r1
   a:	cd b7       	in	r28, 0x3d	; 61
   c:	de b7       	in	r29, 0x3e	; 62
                          K_USHORT usCode_,
                          K_USHORT usArg1_,
                          K_USHORT usArg2_,
                          KernelAwareCommand_t eCmd_ )
{
    CS_ENTER();
   e:	ef b7       	in	r30, 0x3f	; 63
  10:	e9 83       	std	Y+1, r30	; 0x01
  12:	f8 94       	cli
    g_stKAData.Trace.usFile = usFile_;
  14:	90 93 00 00 	sts	0x0000, r25
  18:	80 93 00 00 	sts	0x0000, r24
    g_stKAData.Trace.usLine = usLine_;
  1c:	70 93 00 00 	sts	0x0000, r23
  20:	60 93 00 00 	sts	0x0000, r22
    g_stKAData.Trace.usCode = usCode_;
  24:	50 93 00 00 	sts	0x0000, r21
  28:	40 93 00 00 	sts	0x0000, r20
    g_stKAData.Trace.usArg1 = usArg1_;
  2c:	30 93 00 00 	sts	0x0000, r19
  30:	20 93 00 00 	sts	0x0000, r18
    g_stKAData.Trace.usArg2 = usArg2_;
  34:	10 93 00 00 	sts	0x0000, r17
  38:	00 93 00 00 	sts	0x0000, r16
    g_ucKACommand = eCmd_;
  3c:	88 e0       	ldi	r24, 0x08	; 8
  3e:	80 93 00 00 	sts	0x0000, r24
    CS_EXIT();
  42:	89 81       	ldd	r24, Y+1	; 0x01
  44:	8f bf       	out	0x3f, r24	; 63
                          K_USHORT usCode_,
                          K_USHORT usArg1_,
                          K_USHORT usArg2_)
{
    KernelAware_Trace_i( usFile_, usLine_, usCode_, usArg1_, usArg2_, KA_COMMAND_TRACE_2 );
}
  46:	0f 90       	pop	r0
  48:	df 91       	pop	r29
  4a:	cf 91       	pop	r28
  4c:	1f 91       	pop	r17
  4e:	0f 91       	pop	r16
  50:	08 95       	ret

Disassembly of section .text.KernelAware_Print:

00000000 <KernelAware_Print>:
    CS_EXIT();
}

//---------------------------------------------------------------------------
void KernelAware_Print(const K_CHAR *szStr_)
{
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	1f 92       	push	r1
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
    CS_ENTER();
   a:	2f b7       	in	r18, 0x3f	; 63
   c:	29 83       	std	Y+1, r18	; 0x01
   e:	f8 94       	cli
    g_stKAData.Print.szString = szStr_;
  10:	90 93 00 00 	sts	0x0000, r25
  14:	80 93 00 00 	sts	0x0000, r24
    g_ucKACommand = KA_COMMAND_PRINT;
  18:	89 e0       	ldi	r24, 0x09	; 9
  1a:	80 93 00 00 	sts	0x0000, r24
    CS_EXIT();
  1e:	89 81       	ldd	r24, Y+1	; 0x01
  20:	8f bf       	out	0x3f, r24	; 63
}
  22:	0f 90       	pop	r0
  24:	df 91       	pop	r29
  26:	cf 91       	pop	r28
  28:	08 95       	ret

Disassembly of section .text.KernelAware_IsSimulatorAware:

00000000 <KernelAware_IsSimulatorAware>:

//---------------------------------------------------------------------------
K_BOOL KernelAware_IsSimulatorAware(void)
{
    return g_bIsKernelAware;
   0:	80 91 00 00 	lds	r24, 0x0000
}
   4:	08 95       	ret

threadport.c.o:     file format elf32-avr


Disassembly of section .text.Thread_Switch:

00000000 <Thread_Switch>:
    // That's it!  the thread is ready to run now.
}

//---------------------------------------------------------------------------
static void Thread_Switch(void)
{
   0:	1f 93       	push	r17
   2:	cf 93       	push	r28
   4:	df 93       	push	r29
#if KERNEL_USE_IDLE_FUNC
    // If there's no next-thread-to-run...
    if (g_pstNext == Kernel_GetIdleThread())
   6:	c0 91 00 00 	lds	r28, 0x0000
   a:	d0 91 00 00 	lds	r29, 0x0000
   e:	0e 94 00 00 	call	0	; 0x0 <Thread_Switch>
  12:	c8 17       	cp	r28, r24
  14:	d9 07       	cpc	r29, r25
  16:	01 f4       	brne	.+0      	; 0x18 <Thread_Switch+0x18>
    {
        g_pstCurrent = Kernel_GetIdleThread();
  18:	0e 94 00 00 	call	0	; 0x0 <Thread_Switch>
  1c:	90 93 00 00 	sts	0x0000, r25
  20:	80 93 00 00 	sts	0x0000, r24

        // Disable the SWI, and re-enable interrupts -- enter nested interrupt
        // mode.
        KernelSWI_DI();
  24:	0e 94 00 00 	call	0	; 0x0 <Thread_Switch>

        K_UCHAR ucSR = _SFR_IO8(SR_);
  28:	1f b7       	in	r17, 0x3f	; 63

        // So long as there's no "next-to-run" thread, keep executing the Idle
        // function to conclusion...

        while (g_pstNext == Kernel_GetIdleThread())
  2a:	c0 91 00 00 	lds	r28, 0x0000
  2e:	d0 91 00 00 	lds	r29, 0x0000
  32:	0e 94 00 00 	call	0	; 0x0 <Thread_Switch>
  36:	c8 17       	cp	r28, r24
  38:	d9 07       	cpc	r29, r25
  3a:	01 f4       	brne	.+0      	; 0x3c <Thread_Switch+0x3c>
        {
           // Ensure that we run this block in an interrupt enabled context (but
           // with the rest of the checks being performed in an interrupt disabled
           // context).
           ASM( "sei" );
  3c:	78 94       	sei
           Kernel_IdleFunc();
  3e:	0e 94 00 00 	call	0	; 0x0 <Thread_Switch>
           ASM( "cli" );
  42:	f8 94       	cli
  44:	00 c0       	rjmp	.+0      	; 0x46 <Thread_Switch+0x46>
        // the scheduler to run, and choose a new thread.  Since we've already
        // saved the context of the thread we've hijacked to run idle, we can
        // proceed to disable the nested interrupt context and switch to the
        // new thread.

        _SFR_IO8(SR_) = ucSR;
  46:	1f bf       	out	0x3f, r17	; 63
        KernelSWI_RI( true );        
  48:	81 e0       	ldi	r24, 0x01	; 1
  4a:	0e 94 00 00 	call	0	; 0x0 <Thread_Switch>
    }
#endif
    g_pstCurrent = (Thread_t*)g_pstNext;
  4e:	80 91 00 00 	lds	r24, 0x0000
  52:	90 91 00 00 	lds	r25, 0x0000
  56:	90 93 00 00 	sts	0x0000, r25
  5a:	80 93 00 00 	sts	0x0000, r24
}
  5e:	df 91       	pop	r29
  60:	cf 91       	pop	r28
  62:	1f 91       	pop	r17
  64:	08 95       	ret

Disassembly of section .text.ThreadPort_InitStack:

00000000 <ThreadPort_InitStack>:
#include <avr/io.h>
#include <avr/interrupt.h>

//---------------------------------------------------------------------------
void ThreadPort_InitStack(Thread_t *pstThread_)
{
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	fc 01       	movw	r30, r24
    K_USHORT usAddr;
    K_UCHAR *pucStack;
    K_USHORT i;

    // Get the address of the thread's entry function
    usAddr = (K_USHORT)(pstThread_->m_pfEntryPoint);
   6:	52 89       	ldd	r21, Z+18	; 0x12
   8:	43 89       	ldd	r20, Z+19	; 0x13

    // Start by finding the bottom of the stack
    pucStack = (K_UCHAR*)pstThread_->m_pwStackTop;
   a:	a4 81       	ldd	r26, Z+4	; 0x04
   c:	b5 81       	ldd	r27, Z+5	; 0x05

    // clear the stack, and initialize it to a known-default value (easier
    // to debug when things go sour with stack corruption or overflow)
    for (i = 0; i < pstThread_->m_usStackSize; i++)
   e:	80 e0       	ldi	r24, 0x00	; 0
  10:	90 e0       	ldi	r25, 0x00	; 0
    {
        pstThread_->m_pwStack[i] = 0xFF;
  12:	6f ef       	ldi	r22, 0xFF	; 255
    // Start by finding the bottom of the stack
    pucStack = (K_UCHAR*)pstThread_->m_pwStackTop;

    // clear the stack, and initialize it to a known-default value (easier
    // to debug when things go sour with stack corruption or overflow)
    for (i = 0; i < pstThread_->m_usStackSize; i++)
  14:	24 85       	ldd	r18, Z+12	; 0x0c
  16:	35 85       	ldd	r19, Z+13	; 0x0d
  18:	82 17       	cp	r24, r18
  1a:	93 07       	cpc	r25, r19
  1c:	00 f4       	brcc	.+0      	; 0x1e <ThreadPort_InitStack+0x1e>
    {
        pstThread_->m_pwStack[i] = 0xFF;
  1e:	c6 81       	ldd	r28, Z+6	; 0x06
  20:	d7 81       	ldd	r29, Z+7	; 0x07
  22:	c8 0f       	add	r28, r24
  24:	d9 1f       	adc	r29, r25
  26:	68 83       	st	Y, r22
    // Start by finding the bottom of the stack
    pucStack = (K_UCHAR*)pstThread_->m_pwStackTop;

    // clear the stack, and initialize it to a known-default value (easier
    // to debug when things go sour with stack corruption or overflow)
    for (i = 0; i < pstThread_->m_usStackSize; i++)
  28:	01 96       	adiw	r24, 0x01	; 1
  2a:	00 c0       	rjmp	.+0      	; 0x2c <ThreadPort_InitStack+0x2c>
    {
        pstThread_->m_pwStack[i] = 0xFF;
    }

    // Our context starts with the entry function
    PUSH_TO_STACK(pucStack, (K_UCHAR)(usAddr & 0x00FF));
  2c:	5c 93       	st	X, r21
    PUSH_TO_STACK(pucStack, (K_UCHAR)((usAddr >> 8) & 0x00FF));
  2e:	ed 01       	movw	r28, r26
  30:	21 97       	sbiw	r28, 0x01	; 1
  32:	48 83       	st	Y, r20

    // R0
    PUSH_TO_STACK(pucStack, 0x00);    // R0
  34:	21 97       	sbiw	r28, 0x01	; 1
  36:	18 82       	st	Y, r1

    // Push status register and R1 (which is used as a constant zero)
    PUSH_TO_STACK(pucStack, 0x80);  // SR
  38:	80 e8       	ldi	r24, 0x80	; 128
  3a:	21 97       	sbiw	r28, 0x01	; 1
  3c:	88 83       	st	Y, r24
    PUSH_TO_STACK(pucStack, 0x00);  // R1
  3e:	21 97       	sbiw	r28, 0x01	; 1
  40:	18 82       	st	Y, r1
  42:	82 e0       	ldi	r24, 0x02	; 2

    // Push other registers
    for (i = 2; i <= 23; i++) //R2-R23
    {
        PUSH_TO_STACK(pucStack, i);
  44:	8a 93       	st	-Y, r24
  46:	8f 5f       	subi	r24, 0xFF	; 255
    // Push status register and R1 (which is used as a constant zero)
    PUSH_TO_STACK(pucStack, 0x80);  // SR
    PUSH_TO_STACK(pucStack, 0x00);  // R1

    // Push other registers
    for (i = 2; i <= 23; i++) //R2-R23
  48:	88 31       	cpi	r24, 0x18	; 24
  4a:	01 f4       	brne	.+0      	; 0x4c <ThreadPort_InitStack+0x4c>
    {
        PUSH_TO_STACK(pucStack, i);
    }

    // Assume that the argument is the only stack variable
    PUSH_TO_STACK(pucStack, (K_UCHAR)(((K_USHORT)(pstThread_->m_pvArg)) & 0x00FF));    //R24
  4c:	84 89       	ldd	r24, Z+20	; 0x14
  4e:	ed 01       	movw	r28, r26
  50:	6b 97       	sbiw	r28, 0x1b	; 27
  52:	88 83       	st	Y, r24
    PUSH_TO_STACK(pucStack, (K_UCHAR)((((K_USHORT)(pstThread_->m_pvArg))>>8) & 0x00FF)); //R25
  54:	85 89       	ldd	r24, Z+21	; 0x15
  56:	21 97       	sbiw	r28, 0x01	; 1
  58:	88 83       	st	Y, r24
  5a:	8a e1       	ldi	r24, 0x1A	; 26

    // Push the rest of the registers in the context
    for (i = 26; i <=31; i++)
    {
        PUSH_TO_STACK(pucStack, i);
  5c:	8a 93       	st	-Y, r24
  5e:	8f 5f       	subi	r24, 0xFF	; 255
    // Assume that the argument is the only stack variable
    PUSH_TO_STACK(pucStack, (K_UCHAR)(((K_USHORT)(pstThread_->m_pvArg)) & 0x00FF));    //R24
    PUSH_TO_STACK(pucStack, (K_UCHAR)((((K_USHORT)(pstThread_->m_pvArg))>>8) & 0x00FF)); //R25

    // Push the rest of the registers in the context
    for (i = 26; i <=31; i++)
  60:	80 32       	cpi	r24, 0x20	; 32
  62:	01 f4       	brne	.+0      	; 0x64 <ThreadPort_InitStack+0x64>
  64:	93 97       	sbiw	r26, 0x23	; 35
    {
        PUSH_TO_STACK(pucStack, i);
    }
    
    // Set the top o' the stack.
    pstThread_->m_pwStackTop = (K_UCHAR*)pucStack;
  66:	b5 83       	std	Z+5, r27	; 0x05
  68:	a4 83       	std	Z+4, r26	; 0x04

    // That's it!  the thread is ready to run now.
}
  6a:	df 91       	pop	r29
  6c:	cf 91       	pop	r28
  6e:	08 95       	ret

Disassembly of section .text.ThreadPort_StartThreads:

00000000 <ThreadPort_StartThreads>:


//---------------------------------------------------------------------------
void ThreadPort_StartThreads()
{
    KernelSWI_Config();                 // configure the task switch SWI
   0:	0e 94 00 00 	call	0	; 0x0 <ThreadPort_StartThreads>
    KernelTimer_Config();               // configure the kernel timer
   4:	0e 94 00 00 	call	0	; 0x0 <ThreadPort_StartThreads>
    
    Scheduler_SetScheduler(1);          // enable the scheduler
   8:	81 e0       	ldi	r24, 0x01	; 1
   a:	0e 94 00 00 	call	0	; 0x0 <ThreadPort_StartThreads>
    Scheduler_Schedule();               // run the scheduler - determine the first thread to run
   e:	0e 94 00 00 	call	0	; 0x0 <ThreadPort_StartThreads>

    Thread_Switch();                     // Set the next scheduled thread to the current thread
  12:	0e 94 00 00 	call	0	; 0x0 <ThreadPort_StartThreads>

    KernelTimer_Start();                // enable the kernel timer
  16:	0e 94 00 00 	call	0	; 0x0 <ThreadPort_StartThreads>
    KernelSWI_Start();                  // enable the task switch SWI
  1a:	0e 94 00 00 	call	0	; 0x0 <ThreadPort_StartThreads>

    // Restore the context...
    Thread_RestoreContext();        // restore the context of the first running thread
  1e:	a0 91 00 00 	lds	r26, 0x0000
  22:	b0 91 00 00 	lds	r27, 0x0000
  26:	14 96       	adiw	r26, 0x04	; 4
  28:	cd 91       	ld	r28, X+
  2a:	cd bf       	out	0x3d, r28	; 61
  2c:	dd 91       	ld	r29, X+
  2e:	de bf       	out	0x3e, r29	; 62
  30:	ff 91       	pop	r31
  32:	ef 91       	pop	r30
  34:	df 91       	pop	r29
  36:	cf 91       	pop	r28
  38:	bf 91       	pop	r27
  3a:	af 91       	pop	r26
  3c:	9f 91       	pop	r25
  3e:	8f 91       	pop	r24
  40:	7f 91       	pop	r23
  42:	6f 91       	pop	r22
  44:	5f 91       	pop	r21
  46:	4f 91       	pop	r20
  48:	3f 91       	pop	r19
  4a:	2f 91       	pop	r18
  4c:	1f 91       	pop	r17
  4e:	0f 91       	pop	r16
  50:	ff 90       	pop	r15
  52:	ef 90       	pop	r14
  54:	df 90       	pop	r13
  56:	cf 90       	pop	r12
  58:	bf 90       	pop	r11
  5a:	af 90       	pop	r10
  5c:	9f 90       	pop	r9
  5e:	8f 90       	pop	r8
  60:	7f 90       	pop	r7
  62:	6f 90       	pop	r6
  64:	5f 90       	pop	r5
  66:	4f 90       	pop	r4
  68:	3f 90       	pop	r3
  6a:	2f 90       	pop	r2
  6c:	1f 90       	pop	r1
  6e:	0f 90       	pop	r0
  70:	0f be       	out	0x3f, r0	; 63
  72:	0f 90       	pop	r0
    ASM("reti");                    // return from interrupt - will return to the first scheduled thread
  74:	18 95       	reti
  76:	08 95       	ret

Disassembly of section .text.__vector_1:

00000000 <__vector_1>:
*/
//---------------------------------------------------------------------------
ISR(INT0_vect) __attribute__ ( ( signal, naked ) );
ISR(INT0_vect)
{
    Thread_SaveContext();       // Push the context (registers) of the current task
   0:	0f 92       	push	r0
   2:	0f b6       	in	r0, 0x3f	; 63
   4:	f8 94       	cli
   6:	0f 92       	push	r0
   8:	1f 92       	push	r1
   a:	11 24       	eor	r1, r1
   c:	2f 92       	push	r2
   e:	3f 92       	push	r3
  10:	4f 92       	push	r4
  12:	5f 92       	push	r5
  14:	6f 92       	push	r6
  16:	7f 92       	push	r7
  18:	8f 92       	push	r8
  1a:	9f 92       	push	r9
  1c:	af 92       	push	r10
  1e:	bf 92       	push	r11
  20:	cf 92       	push	r12
  22:	df 92       	push	r13
  24:	ef 92       	push	r14
  26:	ff 92       	push	r15
  28:	0f 93       	push	r16
  2a:	1f 93       	push	r17
  2c:	2f 93       	push	r18
  2e:	3f 93       	push	r19
  30:	4f 93       	push	r20
  32:	5f 93       	push	r21
  34:	6f 93       	push	r22
  36:	7f 93       	push	r23
  38:	8f 93       	push	r24
  3a:	9f 93       	push	r25
  3c:	af 93       	push	r26
  3e:	bf 93       	push	r27
  40:	cf 93       	push	r28
  42:	df 93       	push	r29
  44:	ef 93       	push	r30
  46:	ff 93       	push	r31
  48:	a0 91 00 00 	lds	r26, 0x0000
  4c:	b0 91 00 00 	lds	r27, 0x0000
  50:	14 96       	adiw	r26, 0x04	; 4
  52:	0d b6       	in	r0, 0x3d	; 61
  54:	0d 92       	st	X+, r0
  56:	0e b6       	in	r0, 0x3e	; 62
  58:	0d 92       	st	X+, r0
    Thread_Switch();            // Switch to the next task
  5a:	0e 94 00 00 	call	0	; 0x0 <__vector_1>
    Thread_RestoreContext();    // Pop the context (registers) of the next task
  5e:	a0 91 00 00 	lds	r26, 0x0000
  62:	b0 91 00 00 	lds	r27, 0x0000
  66:	14 96       	adiw	r26, 0x04	; 4
  68:	cd 91       	ld	r28, X+
  6a:	cd bf       	out	0x3d, r28	; 61
  6c:	dd 91       	ld	r29, X+
  6e:	de bf       	out	0x3e, r29	; 62
  70:	ff 91       	pop	r31
  72:	ef 91       	pop	r30
  74:	df 91       	pop	r29
  76:	cf 91       	pop	r28
  78:	bf 91       	pop	r27
  7a:	af 91       	pop	r26
  7c:	9f 91       	pop	r25
  7e:	8f 91       	pop	r24
  80:	7f 91       	pop	r23
  82:	6f 91       	pop	r22
  84:	5f 91       	pop	r21
  86:	4f 91       	pop	r20
  88:	3f 91       	pop	r19
  8a:	2f 91       	pop	r18
  8c:	1f 91       	pop	r17
  8e:	0f 91       	pop	r16
  90:	ff 90       	pop	r15
  92:	ef 90       	pop	r14
  94:	df 90       	pop	r13
  96:	cf 90       	pop	r12
  98:	bf 90       	pop	r11
  9a:	af 90       	pop	r10
  9c:	9f 90       	pop	r9
  9e:	8f 90       	pop	r8
  a0:	7f 90       	pop	r7
  a2:	6f 90       	pop	r6
  a4:	5f 90       	pop	r5
  a6:	4f 90       	pop	r4
  a8:	3f 90       	pop	r3
  aa:	2f 90       	pop	r2
  ac:	1f 90       	pop	r1
  ae:	0f 90       	pop	r0
  b0:	0f be       	out	0x3f, r0	; 63
  b2:	0f 90       	pop	r0
    ASM("reti");                // Return to the next task
  b4:	18 95       	reti

Disassembly of section .text.__vector_11:

00000000 <__vector_11>:
    Timer_t interrupt ISR - causes a tick, which may cause a context switch
    \fn ISR(TIMER1_COMPA_vect) ;
*/
//---------------------------------------------------------------------------
ISR(TIMER1_COMPA_vect)
{
   0:	1f 92       	push	r1
   2:	0f 92       	push	r0
   4:	0f b6       	in	r0, 0x3f	; 63
   6:	0f 92       	push	r0
   8:	11 24       	eor	r1, r1
   a:	2f 93       	push	r18
   c:	3f 93       	push	r19
   e:	4f 93       	push	r20
  10:	5f 93       	push	r21
  12:	6f 93       	push	r22
  14:	7f 93       	push	r23
  16:	8f 93       	push	r24
  18:	9f 93       	push	r25
  1a:	af 93       	push	r26
  1c:	bf 93       	push	r27
  1e:	ef 93       	push	r30
  20:	ff 93       	push	r31
#if KERNEL_USE_TIMERS    
    TimerScheduler_Process();
  22:	0e 94 00 00 	call	0	; 0x0 <__vector_11>
#endif    
#if KERNEL_USE_QUANTUM    
    Quantum_UpdateTimer();
  26:	0e 94 00 00 	call	0	; 0x0 <__vector_11>
#endif
}
  2a:	ff 91       	pop	r31
  2c:	ef 91       	pop	r30
  2e:	bf 91       	pop	r27
  30:	af 91       	pop	r26
  32:	9f 91       	pop	r25
  34:	8f 91       	pop	r24
  36:	7f 91       	pop	r23
  38:	6f 91       	pop	r22
  3a:	5f 91       	pop	r21
  3c:	4f 91       	pop	r20
  3e:	3f 91       	pop	r19
  40:	2f 91       	pop	r18
  42:	0f 90       	pop	r0
  44:	0f be       	out	0x3f, r0	; 63
  46:	0f 90       	pop	r0
  48:	1f 90       	pop	r1
  4a:	18 95       	reti

kernelswi.c.o:     file format elf32-avr


Disassembly of section .text.KernelSWI_Config:

00000000 <KernelSWI_Config>:
#include <avr/interrupt.h>

//---------------------------------------------------------------------------
void KernelSWI_Config(void)
{
    PORTD &= ~0x04; // Clear INT0
   0:	5a 98       	cbi	0x0b, 2	; 11
    DDRD |= 0x04;    // Set PortD, bit 2 (INT0) As Output
   2:	52 9a       	sbi	0x0a, 2	; 10
    EICRA |= (1 << ISC00) | (1 << ISC01);    // Rising edge on INT0
   4:	e9 e6       	ldi	r30, 0x69	; 105
   6:	f0 e0       	ldi	r31, 0x00	; 0
   8:	80 81       	ld	r24, Z
   a:	83 60       	ori	r24, 0x03	; 3
   c:	80 83       	st	Z, r24
   e:	08 95       	ret

Disassembly of section .text.KernelSWI_Start:

00000000 <KernelSWI_Start>:
}

//---------------------------------------------------------------------------
void KernelSWI_Start(void)
{        
    EIFR &= ~(1 << INTF0);    // Clear any pending interrupts on INT0
   0:	e0 98       	cbi	0x1c, 0	; 28
    EIMSK |= (1 << INT0);    // Enable INT0 interrupt (as K_LONG as I-bit is set)
   2:	e8 9a       	sbi	0x1d, 0	; 29
   4:	08 95       	ret

Disassembly of section .text.KernelSWI_Stop:

00000000 <KernelSWI_Stop>:
}

//---------------------------------------------------------------------------
void KernelSWI_Stop(void)
{
    EIMSK &= ~(1 << INT0);    // Disable INT0 interrupts
   0:	e8 98       	cbi	0x1d, 0	; 29
   2:	08 95       	ret

Disassembly of section .text.KernelSWI_DI:

00000000 <KernelSWI_DI>:
}

//---------------------------------------------------------------------------
K_UCHAR KernelSWI_DI()
{
    K_BOOL bEnabled = ((EIMSK & (1 << INT0)) != 0);
   0:	8d b3       	in	r24, 0x1d	; 29
    EIMSK &= ~(1 << INT0);
   2:	e8 98       	cbi	0x1d, 0	; 29
    return bEnabled;
}
   4:	81 70       	andi	r24, 0x01	; 1
   6:	08 95       	ret

Disassembly of section .text.KernelSWI_RI:

00000000 <KernelSWI_RI>:

//---------------------------------------------------------------------------
void KernelSWI_RI(K_BOOL bEnable_)
{
    if (bEnable_)
   0:	88 23       	and	r24, r24
   2:	01 f0       	breq	.+0      	; 0x4 <KernelSWI_RI+0x4>
    {
        EIMSK |= (1 << INT0);    
   4:	e8 9a       	sbi	0x1d, 0	; 29
   6:	08 95       	ret
    }
    else
    {
        EIMSK &= ~(1 << INT0);    
   8:	e8 98       	cbi	0x1d, 0	; 29
   a:	08 95       	ret

Disassembly of section .text.KernelSWI_Clear:

00000000 <KernelSWI_Clear>:
}

//---------------------------------------------------------------------------
void KernelSWI_Clear(void)
{
    EIFR &= ~(1 << INTF0);     // Clear the interrupt flag for INT0
   0:	e0 98       	cbi	0x1c, 0	; 28
   2:	08 95       	ret

Disassembly of section .text.KernelSWI_Trigger:

00000000 <KernelSWI_Trigger>:
//---------------------------------------------------------------------------
void KernelSWI_Trigger(void)
{
    //if(Thread_IsSchedulerEnabled())
    {
        PORTD &= ~0x04;
   0:	5a 98       	cbi	0x0b, 2	; 11
        PORTD |= 0x04;    
   2:	5a 9a       	sbi	0x0b, 2	; 11
   4:	08 95       	ret

kerneltimer.c.o:     file format elf32-avr


Disassembly of section .text.KernelTimer_Config:

00000000 <KernelTimer_Config>:
#define TIMER_IFR        (1 << OCF1A)

//---------------------------------------------------------------------------
void KernelTimer_Config(void)
{        
    TCCR1B = TCCR1B_INIT;
   0:	8c e0       	ldi	r24, 0x0C	; 12
   2:	80 93 81 00 	sts	0x0081, r24
   6:	08 95       	ret

Disassembly of section .text.KernelTimer_Start:

00000000 <KernelTimer_Start>:
{
#if !KERNEL_TIMERS_TICKLESS
    TCCR1B = ((1 << WGM12) | (1 << CS11) | (1 << CS10));
    OCR1A = ((SYSTEM_FREQ / 1000) / 64);
#else
    TCCR1B |= (1 << CS12);
   0:	e1 e8       	ldi	r30, 0x81	; 129
   2:	f0 e0       	ldi	r31, 0x00	; 0
   4:	80 81       	ld	r24, Z
   6:	84 60       	ori	r24, 0x04	; 4
   8:	80 83       	st	Z, r24
#endif

    TCNT1 = 0;
   a:	10 92 85 00 	sts	0x0085, r1
   e:	10 92 84 00 	sts	0x0084, r1
    TIFR1 &= ~TIMER_IFR;
  12:	b1 98       	cbi	0x16, 1	; 22
    TIMSK1 |= TIMER_IMSK;
  14:	ef e6       	ldi	r30, 0x6F	; 111
  16:	f0 e0       	ldi	r31, 0x00	; 0
  18:	80 81       	ld	r24, Z
  1a:	82 60       	ori	r24, 0x02	; 2
  1c:	80 83       	st	Z, r24
  1e:	08 95       	ret

Disassembly of section .text.KernelTimer_Stop:

00000000 <KernelTimer_Stop>:

//---------------------------------------------------------------------------
void KernelTimer_Stop(void)
{
#if KERNEL_TIMERS_TICKLESS
    TIFR1 &= ~TIMER_IFR;
   0:	b1 98       	cbi	0x16, 1	; 22
    TIMSK1 &= ~TIMER_IMSK;
   2:	ef e6       	ldi	r30, 0x6F	; 111
   4:	f0 e0       	ldi	r31, 0x00	; 0
   6:	80 81       	ld	r24, Z
   8:	8d 7f       	andi	r24, 0xFD	; 253
   a:	80 83       	st	Z, r24
    TCCR1B &= ~(1 << CS12);      // Disable count...    
   c:	e1 e8       	ldi	r30, 0x81	; 129
   e:	f0 e0       	ldi	r31, 0x00	; 0
  10:	80 81       	ld	r24, Z
  12:	8b 7f       	andi	r24, 0xFB	; 251
  14:	80 83       	st	Z, r24
    TCNT1 = 0;
  16:	10 92 85 00 	sts	0x0085, r1
  1a:	10 92 84 00 	sts	0x0084, r1
    OCR1A = 0;
  1e:	10 92 89 00 	sts	0x0089, r1
  22:	10 92 88 00 	sts	0x0088, r1
  26:	08 95       	ret

Disassembly of section .text.KernelTimer_Read:

00000000 <KernelTimer_Read>:
#endif
}

//---------------------------------------------------------------------------
K_USHORT KernelTimer_Read(void)
{
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	00 d0       	rcall	.+0      	; 0x6 <KernelTimer_Read+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <KernelTimer_Read+0x8>
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
#if KERNEL_TIMERS_TICKLESS
    volatile K_USHORT usRead1;
    volatile K_USHORT usRead2;
    
    do {
        usRead1 = TCNT1;
   c:	80 91 84 00 	lds	r24, 0x0084
  10:	90 91 85 00 	lds	r25, 0x0085
  14:	9c 83       	std	Y+4, r25	; 0x04
  16:	8b 83       	std	Y+3, r24	; 0x03
        usRead2 = TCNT1;            
  18:	80 91 84 00 	lds	r24, 0x0084
  1c:	90 91 85 00 	lds	r25, 0x0085
  20:	9a 83       	std	Y+2, r25	; 0x02
  22:	89 83       	std	Y+1, r24	; 0x01
    } while (usRead1 != usRead2);
  24:	2b 81       	ldd	r18, Y+3	; 0x03
  26:	3c 81       	ldd	r19, Y+4	; 0x04
  28:	89 81       	ldd	r24, Y+1	; 0x01
  2a:	9a 81       	ldd	r25, Y+2	; 0x02
  2c:	28 17       	cp	r18, r24
  2e:	39 07       	cpc	r19, r25
  30:	01 f4       	brne	.+0      	; 0x32 <KernelTimer_Read+0x32>
    
    return usRead1;    
  32:	8b 81       	ldd	r24, Y+3	; 0x03
  34:	9c 81       	ldd	r25, Y+4	; 0x04
#else
    return 0;
#endif
}
  36:	0f 90       	pop	r0
  38:	0f 90       	pop	r0
  3a:	0f 90       	pop	r0
  3c:	0f 90       	pop	r0
  3e:	df 91       	pop	r29
  40:	cf 91       	pop	r28
  42:	08 95       	ret

Disassembly of section .text.KernelTimer_SubtractExpiry:

00000000 <KernelTimer_SubtractExpiry>:

//---------------------------------------------------------------------------
K_ULONG KernelTimer_SubtractExpiry(K_ULONG ulInterval_)
{
#if KERNEL_TIMERS_TICKLESS
    OCR1A -= (K_USHORT)ulInterval_;        
   0:	e8 e8       	ldi	r30, 0x88	; 136
   2:	f0 e0       	ldi	r31, 0x00	; 0
   4:	20 81       	ld	r18, Z
   6:	31 81       	ldd	r19, Z+1	; 0x01
   8:	26 1b       	sub	r18, r22
   a:	37 0b       	sbc	r19, r23
   c:	31 83       	std	Z+1, r19	; 0x01
   e:	20 83       	st	Z, r18
    return (K_ULONG)OCR1A;
  10:	60 81       	ld	r22, Z
  12:	71 81       	ldd	r23, Z+1	; 0x01
  14:	80 e0       	ldi	r24, 0x00	; 0
  16:	90 e0       	ldi	r25, 0x00	; 0
#else
    return 0;
#endif
}
  18:	08 95       	ret

Disassembly of section .text.KernelTimer_TimeToExpiry:

00000000 <KernelTimer_TimeToExpiry>:

//---------------------------------------------------------------------------
K_ULONG KernelTimer_TimeToExpiry(void)
{
#if KERNEL_TIMERS_TICKLESS
    K_USHORT usRead = KernelTimer_Read();
   0:	0e 94 00 00 	call	0	; 0x0 <KernelTimer_TimeToExpiry>
   4:	bc 01       	movw	r22, r24
    K_USHORT usOCR1A = OCR1A;
   6:	80 91 88 00 	lds	r24, 0x0088
   a:	90 91 89 00 	lds	r25, 0x0089

    if (usRead >= usOCR1A)
   e:	68 17       	cp	r22, r24
  10:	79 07       	cpc	r23, r25
  12:	00 f4       	brcc	.+0      	; 0x14 <KernelTimer_TimeToExpiry+0x14>
    {
        return 0;
    }
    else
    {
        return (K_ULONG)(usOCR1A - usRead);    
  14:	9c 01       	movw	r18, r24
  16:	26 1b       	sub	r18, r22
  18:	37 0b       	sbc	r19, r23
  1a:	b9 01       	movw	r22, r18
  1c:	80 e0       	ldi	r24, 0x00	; 0
  1e:	90 e0       	ldi	r25, 0x00	; 0
  20:	08 95       	ret
    K_USHORT usRead = KernelTimer_Read();
    K_USHORT usOCR1A = OCR1A;

    if (usRead >= usOCR1A)
    {
        return 0;
  22:	60 e0       	ldi	r22, 0x00	; 0
  24:	70 e0       	ldi	r23, 0x00	; 0
  26:	cb 01       	movw	r24, r22
        return (K_ULONG)(usOCR1A - usRead);    
    }
#else
    return 0;
#endif
}
  28:	08 95       	ret

Disassembly of section .text.KernelTimer_GetOvertime:

00000000 <KernelTimer_GetOvertime>:

//---------------------------------------------------------------------------
K_ULONG KernelTimer_GetOvertime(void)
{
    return KernelTimer_Read();
   0:	0e 94 00 00 	call	0	; 0x0 <KernelTimer_GetOvertime>
   4:	bc 01       	movw	r22, r24
   6:	80 e0       	ldi	r24, 0x00	; 0
   8:	90 e0       	ldi	r25, 0x00	; 0
}
   a:	08 95       	ret

Disassembly of section .text.KernelTimer_SetExpiry:

00000000 <KernelTimer_SetExpiry>:
//---------------------------------------------------------------------------
K_ULONG KernelTimer_SetExpiry(K_ULONG ulInterval_)
{
#if KERNEL_TIMERS_TICKLESS
    K_USHORT usSetInterval;
    if (ulInterval_ > 65535)
   0:	61 15       	cp	r22, r1
   2:	71 05       	cpc	r23, r1
   4:	21 e0       	ldi	r18, 0x01	; 1
   6:	82 07       	cpc	r24, r18
   8:	91 05       	cpc	r25, r1
   a:	00 f0       	brcs	.+0      	; 0xc <KernelTimer_SetExpiry+0xc>
    {
        usSetInterval = 65535;
   c:	6f ef       	ldi	r22, 0xFF	; 255
   e:	7f ef       	ldi	r23, 0xFF	; 255
    else 
    {
        usSetInterval = (K_USHORT)ulInterval_ ;
    }

    OCR1A = usSetInterval;
  10:	70 93 89 00 	sts	0x0089, r23
  14:	60 93 88 00 	sts	0x0088, r22
    return (K_ULONG)usSetInterval;
  18:	80 e0       	ldi	r24, 0x00	; 0
  1a:	90 e0       	ldi	r25, 0x00	; 0
#else
    return 0;
#endif
}
  1c:	08 95       	ret

Disassembly of section .text.KernelTimer_ClearExpiry:

00000000 <KernelTimer_ClearExpiry>:

//---------------------------------------------------------------------------
void KernelTimer_ClearExpiry(void)
{
#if KERNEL_TIMERS_TICKLESS
    OCR1A = 65535;                    // Clear the compare value
   0:	8f ef       	ldi	r24, 0xFF	; 255
   2:	9f ef       	ldi	r25, 0xFF	; 255
   4:	90 93 89 00 	sts	0x0089, r25
   8:	80 93 88 00 	sts	0x0088, r24
   c:	08 95       	ret

Disassembly of section .text.KernelTimer_DI:

00000000 <KernelTimer_DI>:

//---------------------------------------------------------------------------
K_UCHAR KernelTimer_DI(void)
{
#if KERNEL_TIMERS_TICKLESS
    K_BOOL bEnabled = ((TIMSK1 & (TIMER_IMSK)) != 0);
   0:	ef e6       	ldi	r30, 0x6F	; 111
   2:	f0 e0       	ldi	r31, 0x00	; 0
   4:	80 81       	ld	r24, Z
    TIFR1 &= ~TIMER_IFR;      // Clear interrupt flags
   6:	b1 98       	cbi	0x16, 1	; 22
    TIMSK1 &= ~TIMER_IMSK;    // Disable interrupt
   8:	90 81       	ld	r25, Z
   a:	9d 7f       	andi	r25, 0xFD	; 253
   c:	90 83       	st	Z, r25
    return bEnabled;
#else
    return 0;
#endif
}
   e:	86 95       	lsr	r24
  10:	81 70       	andi	r24, 0x01	; 1
  12:	08 95       	ret

Disassembly of section .text.KernelTimer_RI:

00000000 <KernelTimer_RI>:

//---------------------------------------------------------------------------
void KernelTimer_RI(K_BOOL bEnable_)
{
#if KERNEL_TIMERS_TICKLESS
    if (bEnable_)    
   0:	88 23       	and	r24, r24
   2:	01 f0       	breq	.+0      	; 0x4 <KernelTimer_RI+0x4>
    {
        TIMSK1 |= (1 << OCIE1A);    // Enable interrupt
   4:	80 91 6f 00 	lds	r24, 0x006F
   8:	82 60       	ori	r24, 0x02	; 2
   a:	00 c0       	rjmp	.+0      	; 0xc <KernelTimer_RI+0xc>
    }
    else
    {
        TIMSK1 &= ~(1 << OCIE1A);
   c:	80 91 6f 00 	lds	r24, 0x006F
  10:	8d 7f       	andi	r24, 0xFD	; 253
  12:	80 93 6f 00 	sts	0x006F, r24
  16:	08 95       	ret

Disassembly of section .text.KernelTimer_EI:

00000000 <KernelTimer_EI>:
}

//---------------------------------------------------------------------------
void KernelTimer_EI(void)
{
    KernelTimer_RI(0);
   0:	80 e0       	ldi	r24, 0x00	; 0
   2:	0c 94 00 00 	jmp	0	; 0x0 <KernelTimer_EI>

kernelprofile.c.o:     file format elf32-avr


Disassembly of section .text.Profiler_Init:

00000000 <Profiler_Init>:
K_ULONG m_ulEpoch;

//---------------------------------------------------------------------------
void Profiler_Init( void )
{
    TCCR0A = 0;
   0:	14 bc       	out	0x24, r1	; 36
    TCCR0B = 0;
   2:	15 bc       	out	0x25, r1	; 37
    TIFR0 = 0;
   4:	15 ba       	out	0x15, r1	; 21
    TIMSK0 = 0;
   6:	10 92 6e 00 	sts	0x006E, r1
    m_ulEpoch = 0;
   a:	10 92 00 00 	sts	0x0000, r1
   e:	10 92 00 00 	sts	0x0000, r1
  12:	10 92 00 00 	sts	0x0000, r1
  16:	10 92 00 00 	sts	0x0000, r1
  1a:	08 95       	ret

Disassembly of section .text.Profiler_Start:

00000000 <Profiler_Start>:
}

//---------------------------------------------------------------------------
void Profiler_Start( void )
{
    TIFR0 = 0;
   0:	15 ba       	out	0x15, r1	; 21
    TCNT0 = 0;
   2:	16 bc       	out	0x26, r1	; 38
    TCCR0B |= (1 << CS01);
   4:	85 b5       	in	r24, 0x25	; 37
   6:	82 60       	ori	r24, 0x02	; 2
   8:	85 bd       	out	0x25, r24	; 37
    TIMSK0 |= (1 << TOIE0);
   a:	ee e6       	ldi	r30, 0x6E	; 110
   c:	f0 e0       	ldi	r31, 0x00	; 0
   e:	80 81       	ld	r24, Z
  10:	81 60       	ori	r24, 0x01	; 1
  12:	80 83       	st	Z, r24
  14:	08 95       	ret

Disassembly of section .text.Profiler_Stop:

00000000 <Profiler_Stop>:
}    

//---------------------------------------------------------------------------
void Profiler_Stop( void )
{
    TIFR0 = 0;
   0:	15 ba       	out	0x15, r1	; 21
    TCCR0B &= ~(1 << CS01);
   2:	85 b5       	in	r24, 0x25	; 37
   4:	8d 7f       	andi	r24, 0xFD	; 253
   6:	85 bd       	out	0x25, r24	; 37
    TIMSK0 &= ~(1 << TOIE0);
   8:	ee e6       	ldi	r30, 0x6E	; 110
   a:	f0 e0       	ldi	r31, 0x00	; 0
   c:	80 81       	ld	r24, Z
   e:	8e 7f       	andi	r24, 0xFE	; 254
  10:	80 83       	st	Z, r24
  12:	08 95       	ret

Disassembly of section .text.Profiler_Read:

00000000 <Profiler_Read>:
}    
//---------------------------------------------------------------------------
K_USHORT Profiler_Read( void )
{
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	1f 92       	push	r1
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
    K_USHORT usRet;
    CS_ENTER();
   a:	8f b7       	in	r24, 0x3f	; 63
   c:	89 83       	std	Y+1, r24	; 0x01
   e:	f8 94       	cli
    TCCR0B &= ~(1 << CS01);
  10:	85 b5       	in	r24, 0x25	; 37
  12:	8d 7f       	andi	r24, 0xFD	; 253
  14:	85 bd       	out	0x25, r24	; 37
    usRet = TCNT0;
  16:	86 b5       	in	r24, 0x26	; 38
    TCCR0B |= (1 << CS01);
  18:	95 b5       	in	r25, 0x25	; 37
  1a:	92 60       	ori	r25, 0x02	; 2
  1c:	95 bd       	out	0x25, r25	; 37
    CS_EXIT();
  1e:	99 81       	ldd	r25, Y+1	; 0x01
  20:	9f bf       	out	0x3f, r25	; 63
    return usRet;
}
  22:	90 e0       	ldi	r25, 0x00	; 0
  24:	0f 90       	pop	r0
  26:	df 91       	pop	r29
  28:	cf 91       	pop	r28
  2a:	08 95       	ret

Disassembly of section .text.Profiler_Process:

00000000 <Profiler_Process>:

//---------------------------------------------------------------------------
void Profiler_Process( void )
{
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	1f 92       	push	r1
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
    CS_ENTER();
   a:	8f b7       	in	r24, 0x3f	; 63
   c:	89 83       	std	Y+1, r24	; 0x01
   e:	f8 94       	cli
    m_ulEpoch++;
  10:	80 91 00 00 	lds	r24, 0x0000
  14:	90 91 00 00 	lds	r25, 0x0000
  18:	a0 91 00 00 	lds	r26, 0x0000
  1c:	b0 91 00 00 	lds	r27, 0x0000
  20:	01 96       	adiw	r24, 0x01	; 1
  22:	a1 1d       	adc	r26, r1
  24:	b1 1d       	adc	r27, r1
  26:	80 93 00 00 	sts	0x0000, r24
  2a:	90 93 00 00 	sts	0x0000, r25
  2e:	a0 93 00 00 	sts	0x0000, r26
  32:	b0 93 00 00 	sts	0x0000, r27
    CS_EXIT();
  36:	89 81       	ldd	r24, Y+1	; 0x01
  38:	8f bf       	out	0x3f, r24	; 63
}
  3a:	0f 90       	pop	r0
  3c:	df 91       	pop	r29
  3e:	cf 91       	pop	r28
  40:	08 95       	ret

Disassembly of section .text.Profiler_GetEpoch:

00000000 <Profiler_GetEpoch>:

//---------------------------------------------------------------------------
K_ULONG Profiler_GetEpoch( void )
{ 
	return m_ulEpoch; 
   0:	60 91 00 00 	lds	r22, 0x0000
   4:	70 91 00 00 	lds	r23, 0x0000
   8:	80 91 00 00 	lds	r24, 0x0000
   c:	90 91 00 00 	lds	r25, 0x0000
}
  10:	08 95       	ret

Disassembly of section .text.__vector_16:

00000000 <__vector_16>:

//---------------------------------------------------------------------------
ISR(TIMER0_OVF_vect)
{
   0:	1f 92       	push	r1
   2:	0f 92       	push	r0
   4:	0f b6       	in	r0, 0x3f	; 63
   6:	0f 92       	push	r0
   8:	11 24       	eor	r1, r1
   a:	2f 93       	push	r18
   c:	3f 93       	push	r19
   e:	4f 93       	push	r20
  10:	5f 93       	push	r21
  12:	6f 93       	push	r22
  14:	7f 93       	push	r23
  16:	8f 93       	push	r24
  18:	9f 93       	push	r25
  1a:	af 93       	push	r26
  1c:	bf 93       	push	r27
  1e:	ef 93       	push	r30
  20:	ff 93       	push	r31
    Profiler_Process();
  22:	0e 94 00 00 	call	0	; 0x0 <__vector_16>
}
  26:	ff 91       	pop	r31
  28:	ef 91       	pop	r30
  2a:	bf 91       	pop	r27
  2c:	af 91       	pop	r26
  2e:	9f 91       	pop	r25
  30:	8f 91       	pop	r24
  32:	7f 91       	pop	r23
  34:	6f 91       	pop	r22
  36:	5f 91       	pop	r21
  38:	4f 91       	pop	r20
  3a:	3f 91       	pop	r19
  3c:	2f 91       	pop	r18
  3e:	0f 90       	pop	r0
  40:	0f be       	out	0x3f, r0	; 63
  42:	0f 90       	pop	r0
  44:	1f 90       	pop	r1
  46:	18 95       	reti
